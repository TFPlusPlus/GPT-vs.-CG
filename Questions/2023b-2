2023b01

Consider a surface that reflects the colour yellow when three lights are shining on it: one red, one green, one blue.
What will be the reflected colour if the red light is removed?
a. Yellow
b. Green
c. Black
d. Red
e. Cyan

The correct answer is:
Green

2023b02a

Given is a 3D medical imaging data set of a head which specifies for each point the radiodensity of the material, i.e., to what extend the material blocks x-rays. For example, bone has a higher value (is less transmissible) than muscle, skin, and fluid. What surface representation is most suitable for rendering the bone layer of the head as illustrated in the image below?
Image description: A 3D model of a skull.
Select one:
a. Parametric surfaces
b. CSG (Constructive Solid Geometry)
c. Subdivision surfaces
d. Implicit surfaces
e. First using a CGS object and then smoothing it using a subdivision surface.

The correct answer is: Implicit surfaces

2023b02b

Given is a 3D medical imaging data set of a head which specifies for each point the radiodensity of the material, i.e., to what extend the material blocks x-rays. For example, bone has a higher value (is less transmissible) than muscle, skin, and fluid. What surface representation is most suitable for rendering the bone layer of the head as illustrated in the image below?
Image description: A 3D model of a skull in white, there are a lot of intricate details in the model.
Select one:
a. Parametric surfaces
b. CSG (Constructive Solid Geometry)
c. Subdivision surfaces
d. Implicit surfaces
e. First using a CGS object and then smoothing it using a subdivision surface.

The correct answer is: Implicit surfaces

2023b03

Which of the following statements about rendering in OpenGL is false (if any)?
Select one:
a. We can render a cube consisting of 6 square polygons without a depth buffer if we render back faces first and then front faces.
b. When displaying an animated scene we need to use double buffering to avoid rendering artifacts.
c. None of the other statements is false, i.e., they are all true.
d. OpenGL uses the winding order of polygons to determine front and back faces.
e. When rendering closed 3D surfaces, such as a sphere or cube, we must enable back-face culling since otherwise the resulting image will look wrong.

The correct answer is: When rendering closed 3D surfaces, such as a sphere or cube, we must enable back-face culling since otherwise the resulting image will look wrong.

2023b04

Given is a equilateral triangle. What colours do we need to specify for the vertices in order to make the centre point dark grey (RGB value (1/3, 1/3, 1/3))?
Select one:
a. The vertices must be cyan, red and yellow.
b. The vertices must be magenta, green and blue.
c. The vertices must be cyan, magenta, and yellow.
d. The vertices must be red, yellow and blue.
e. The vertices must be red, green and blue.

The correct answer is: The vertices must be red, green and blue.

2023b05

Which of the following statements about parametric curves and surfaces is true?
Select one:
a. The normal of a parametric surface p(s,t) is obtained by interpolating p(0,0), p(0,1), p(1,0), and p(1,1).
b. When defining a surface-of-revolution the profile curve can be a spline curve, e.g., a Catmul-Rom spline.
c. Squares and discs can not be represented as parametric surfaces.
d. The Hermit curve is a quadratic spline.
e. Bezier curves are always cubic, e.g., quadratic Bezier curves do not exist.

The correct answer is: When defining a surface-of-revolution the profile curve can be a spline curve, e.g., a Catmul-Rom spline.

2023b06

Given is a light source at the position
L=(1, 3, 0)^T
and an object with the point
P=(1, 2, 1)
.
If we draw the projected shadow of the object on the plane y=1, what is the position P' of the point P projected on the plane y=1?
Hint: Make yourself an illustration of the situation.
Select one:
a. P'=(2, 1, 3)^T
b. P'=(1, 1, 2)^T
c. P'=(2, 1, 0)^T
d. P'=(0, 1, 1)^T
e. P'=(1, 1, 3)^T

The correct answer is:
P'=(1, 1, 2)^T

2023b07a

Given are the following vertices:
const int numVertices=7;
const float vertices[numVertices][2] = { {50,50},{300,50},{50,150},{50,200},{200,200},{50,300},{300,300} };
Consider the image shown below.
Image description: The image shows a square with a triangle cropped out. The vertices of the square are 0, 1, 6, 5. The vertices of the triangle are 2, 4, 3.
Which calling sequence of these vertices (using glVertex2fv) results in the shape in the image above, if we use the OpenGL commands glBegin(GL_TRIANGLE_FAN) and glEnd()?
Select one:
a. 4, 1, 0, 2, 3, 5, 6
b. 6, 1, 0, 2, 4, 3, 5
c. 0, 1, 2, 3, 4, 5, 6
d. 4, 3, 5, 6, 1, 0, 2
e. 1, 0, 2, 4, 3, 5, 6

The correct answer is: 4, 3, 5, 6, 1, 0, 2

2023b07b

Given are the following vertices:
const int numVertices=7;
const float vertices[numVertices][2] = { {50,50},{300,50},{50,150},{50,200},{200,200},{50,300},{300,300} };
Consider the image shown below.
Image description: The image shows a square with a triangle cropped out. The vertices of the square are 0, 1, 6, 5 counterclockwise. The vertices of the triangle are 2, 4, 3 counterclockwise. Lines from the 4th vertex to every other vertex are included in the shape.
Which calling sequence of these vertices (using glVertex2fv) results in the shape in the image above, if we use the OpenGL commands glBegin(GL_TRIANGLE_FAN) and glEnd()?
Select one:
a. 4, 1, 0, 2, 3, 5, 6
b. 6, 1, 0, 2, 4, 3, 5
c. 0, 1, 2, 3, 4, 5, 6
d. 4, 3, 5, 6, 1, 0, 2
e. 1, 0, 2, 4, 3, 5, 6

The correct answer is: 4, 3, 5, 6, 1, 0, 2

2023b08

Given is a plane 3x+2y-z=3 and a ray
$$p(t)= \begin{pmatrix} 1 \\ 0  \\ 1 \end{pmatrix} + t * \begin{pmatrix} -1 \\ c  \\ 0 \end{pmatrix}.$$
For what value of c is the ray parallel to the plane?
Select one:
a. c=0
b. c=0.5
c. c=1.5
d. c=-0.5
e. c=1

The correct answer is: c=1.5

2023b09a

Given is a function drawHouse() which draws a wire frame house in the xy-plane as shown in the image below:
Image description: A shape of a house is drawn in the xy-plane. The house is made up of a square with a triangle on top.
We now transform the house in two different ways before drawing it:
Drawing 1:
glScalef(2.0, 1.0, 1.0);
drawHouse();
Drawing 2:
glScalef(2.0, 1.0, -1.0);
drawHouse();
Which of the following statements is correct?
Select one:
a. The two drawings look the same, but the MODEL_VIEW matrices used to transform the house before drawing are different.
b. The two drawings look different, and the MODEL_VIEW matrices used to transform the house before drawing are different.
c. The two drawings look the same, and the MODEL_VIEW matrices used to transform the house before drawing are the same.
d. The transformation is not possible (generates an error).
e. The two drawings look different, but the MODEL_VIEW matrices used to transform the house before drawing are the same.

The correct answer is: The two drawings look the same, but the MODEL_VIEW matrices used to transform the house before drawing are different.

2023b09b

Given is a function drawHouse() which draws a wire frame house in the xy-plane as shown in the image below:
Image description: A shape of a house is drawn in the xy-plane. The house is made up of a square with a triangle on top. The square is made up of four points, (0, 0), (2, 0), (2, 2), and (0, 2). The triangle is made up of three points, (0, 2), (2, 2), and (1, 3).
We now transform the house in two different ways before drawing it:
Drawing 1:
glScalef(2.0, 1.0, 1.0);
drawHouse();
Drawing 2:
glScalef(2.0, 1.0, -1.0);
drawHouse();
Which of the following statements is correct?
Select one:
a. The two drawings look the same, but the MODEL_VIEW matrices used to transform the house before drawing are different.
b. The two drawings look different, and the MODEL_VIEW matrices used to transform the house before drawing are different.
c. The two drawings look the same, and the MODEL_VIEW matrices used to transform the house before drawing are the same.
d. The transformation is not possible (generates an error).
e. The two drawings look different, but the MODEL_VIEW matrices used to transform the house before drawing are the same.

The correct answer is: The two drawings look the same, but the MODEL_VIEW matrices used to transform the house before drawing are different.

2023b10

Which of the 3D homogeneous matrices below first translates a point by the vector
$$P = \begin{pmatrix} 2 \\ 3 \\ 1  \end{pmatrix}$$
and then rotates it by 90 degree anti-clockwise around the y-axis?
Answer
a. None of the others.
b. $$\begin{pmatrix} 1 & 0 & 0 & 2 \\ 0 & 1 & 0 & 3$$
$$\\ 0 & 0 & 1 & 1 \\ 0 & 0 & 0 & 1$$
$$\end{pmatrix}$$
c. $$\begin{pmatrix} 0 & 0 & -1 & -1 \\ 0 & 1 & 0 & 3$$
$$\\ 1 & 0 & 0 & 2 \\ 0 & 0 & 0 & 1$$
$$\end{pmatrix}$$
d. $$\begin{pmatrix} -1 & 0 & 0 & -2 \\ 0 & 1 & 0 & 3 \\ 0 & 0 & -1 & -1 \\ 0 & 0 & 0 & 1$$
$$\end{pmatrix}$$
e. $$\begin{pmatrix} 0 & 0 & 1 & 1 \\ 0 & 1 & 0 & 3 \\ -1 & 0 & 0 & -2 \\ 0 & 0 & 0 & 1 \end{pmatrix}$$

The correct answer is:
$$\begin{pmatrix} 0 & 0 & 1 & 1 \\ 0 & 1 & 0 & 3 \\ -1 & 0 & 0 & -2 \\ 0 & 0 & 0 & 1 \end{pmatrix}$$

2023b11

Given is a triangle with the vertices
$$A = \begin{pmatrix} 4 \\ 0 \\ 0  \end{pmatrix}, \mbox{   } B = \begin{pmatrix} -1 \\ 0 \\ 0  \end{pmatrix}, \mbox{   }C = \begin{pmatrix} 0 \\ 2 \\ 0  \end{pmatrix}$$
The RGB colours at these three points are
$$C_A=(0.0, 0.0, 1.0), \mbox{   }C_B=(0.6, 0.4, 0.2), \mbox{   }C_C=(0.5, 1.0, 0.0)$$
.
If the triangle is rendered using OpenGL, what is the colour at the point
$$P = \begin{pmatrix} 0 \\ 1 \\ 0  \end{pmatrix}?$$
Tip: Make yourself an illustration. Note that the triangle lies on the xy-plane. You should be able to determine the weighting factors for the colour interpolation using your illustration, without doing any complex calculations.
Select one:
a. C_P=(0.49, 0.66, 0.18)
b. C_P=(0.45, 0.7, 0.15)
c. C_P=(0.55, 0.69, 0.2)
d. C_P=(0.5, 0.6, 0.15)
e. C_P=(0.52, 0.65, 0.17)

The correct answer is:
C_P=(0.49, 0.66, 0.18)

2023b12a

Given is the following texture image:
Image description: The image shows a 4x4 grid of colours. From left to right, then top to bottom, the colours are red, light green, dark blue, brown, yellow, purple, cyan, dark orange, pink, white, lime, grey, black, light blue, light orange, dark green.
What texture coordinates do we need to specify if we want to use this texture image to create the textured triangle shown below?
Image description: The image shows a shifted version of the base image, with the bottom left corner being the top left corner of the pink tile, the bottom right corner being the bottom right corner of the light orange tile, and the top right corner being the top right corner of the dark blue tile.
Select one:
a. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.5)
Texture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)
Texture coordinates for the top vertex of the triangle: (0.75, 1.0)
b. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.0)
Texture coordinates for the bottom-right vertex of the triangle: (1.0, 0.0)
Texture coordinates for the top vertex of the triangle: (1.0, 1.0)
c. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.0)
Texture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)
Texture coordinates for the top vertex of the triangle: (0.75, 1.0)
d. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.75)
Texture coordinates for the bottom-right vertex of the triangle: (0.5, 0.5)
Texture coordinates for the top vertex of the triangle: (0.75, 1.0)
e. Texture coordinates for the bottom-left vertex of the triangle: (0.75, 0.0)
Texture coordinates for the bottom-right vertex of the triangle: (0.75, 1.0)
Texture coordinates for the top vertex of the triangle: (0.0, 0.5)

The correct answer is: Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.5)
Texture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)
Texture coordinates for the top vertex of the triangle: (0.75, 1.0)

2023b12b

Given is the following texture image:
Image description: The image shows a 4x4 grid of colours.
What texture coordinates do we need to specify if we want to use this texture image to create the textured triangle shown below?
Image description: The image shows a shifted version of the base image. Using grid coordinates from the base image, where the bottom left corner of the base image is (0, 0) and the top right corner of the base image is (4, 4), then the bottom left corner is (0, 2), the bottom right corner is (3, 0), and the top right corner is (3, 4).
Select one:
a. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.5)
Texture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)
Texture coordinates for the top vertex of the triangle: (0.75, 1.0)
b. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.0)
Texture coordinates for the bottom-right vertex of the triangle: (1.0, 0.0)
Texture coordinates for the top vertex of the triangle: (1.0, 1.0)
c. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.0)
Texture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)
Texture coordinates for the top vertex of the triangle: (0.75, 1.0)
d. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.75)
Texture coordinates for the bottom-right vertex of the triangle: (0.5, 0.5)
Texture coordinates for the top vertex of the triangle: (0.75, 1.0)
e. Texture coordinates for the bottom-left vertex of the triangle: (0.75, 0.0)
Texture coordinates for the bottom-right vertex of the triangle: (0.75, 1.0)
Texture coordinates for the top vertex of the triangle: (0.0, 0.5)

The correct answer is: Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.5)
Texture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)
Texture coordinates for the top vertex of the triangle: (0.75, 1.0)

2023b13a

Image description: The image shows the base texture, a shape to be textured, and the resulting textured shape. The base texture is the picture of a mountain, the shape to be texture is made up from three shapes: a rectangle with vertices P1, P2, P5, P3 counterclockwise, where P1 is the bottom left corner of the whole shape, the width of the rectangle is 2, and the height of the rectangle is 0.5; a rectangle with vertices P6, P8, P10, P9 counterwise, where P10 is the top right corner of the whole shape, the width of the rectangle is 2, and the height of the rectangle is 0.5; a square with vertices P4, P5, P7, P6 counterwise, where the center of the shape aligns with the center of the whole shape, the width of the square is 1. The resulting textured shape is the same as the shape to be textured, but with the base texture mapped onto it, repeated 3 times horizontally and 2 times vertically.
Select one:
a. Texture coordinate for P1: (0, 0)
Texture coordinate for P2: (4, 0)
Texture coordinate for P3: (0, 1)
Texture coordinate for P4: (2, 1)
Texture coordinate for P5: (4, 1)
Texture coordinate for P6: (2, 3)
Texture coordinate for P7: (4, 3)
Texture coordinate for P8: (6, 3)
Texture coordinate for P9: (2, 4)
Texture coordinate for P10: (6, 4)
b. Texture coordinate for P1: (0, 0)
Texture coordinate for P2: (2, 0)
Texture coordinate for P3: (0, 0.5)
Texture coordinate for P4: (1, 0.5)
Texture coordinate for P5: (2, 0.5)
Texture coordinate for P6: (1, 1.5)
Texture coordinate for P7: (2, 1.5)
Texture coordinate for P8: (3, 1.5)
Texture coordinate for P9: (1, 2)
Texture coordinate for P10: (3, 2)
c. Texture coordinate for P1: (0, 0)
Texture coordinate for P2: (2, 0)
Texture coordinate for P3: (0, 1)
Texture coordinate for P4: (2, 1)
Texture coordinate for P5: (4, 1)
Texture coordinate for P6: (2, 2)
Texture coordinate for P7: (4, 2)
Texture coordinate for P8: (6, 2)
Texture coordinate for P9: (2, 3)
Texture coordinate for P10: (6, 3)
d. Texture coordinate for P1: (0, 0)
Texture coordinate for P2: (4, 0)
Texture coordinate for P3: (0, 0.5)
Texture coordinate for P4: (2, 0.5)
Texture coordinate for P5: (4, 0.5)
Texture coordinate for P6: (2, 1.5)
Texture coordinate for P7: (4, 1.5)
Texture coordinate for P8: (6, 1.5)
Texture coordinate for P9: (2, 2)
Texture coordinate for P10: (6, 2)
e. None of the others.

The correct answer is: Texture coordinate for P1: (0, 0)
Texture coordinate for P2: (2, 0)
Texture coordinate for P3: (0, 0.5)
Texture coordinate for P4: (1, 0.5)
Texture coordinate for P5: (2, 0.5)
Texture coordinate for P6: (1, 1.5)
Texture coordinate for P7: (2, 1.5)
Texture coordinate for P8: (3, 1.5)
Texture coordinate for P9: (1, 2)
Texture coordinate for P10: (3, 2)

2023b13b

Image description: The image shows the base texture, a shape to be textured, and the resulting textured shape. The base texture is the picture of a mountain, the shape to be texture is made up from three shapes: a rectangle with vertices P1, P2, P5, P3 counterclockwise, where P1 is the bottom left corner of the whole shape, the width of the rectangle is 2, and the height of the rectangle is 0.5; a rectangle with vertices P6, P8, P10, P9 counterwise, where P10 is the top right corner of the whole shape, the width of the rectangle is 2, and the height of the rectangle is 0.5; a square with vertices P4, P5, P7, P6 counterwise, where the center of the shape aligns with the center of the whole shape, the width of the square is 1. The resulting textured shape is the same as the shape to be textured, but with the base texture mapped onto it, repeated 3 times horizontally and 2 times vertically. The bottom left corner of the base texture is mapped to the bottom left corner of the shape to be textured, and the top right corner of the base texture is mapped to the top right corner of the shape to be textured. The base texture has not been shapeshifted, only cropped.
Select one:
a. Texture coordinate for P1: (0, 0)
Texture coordinate for P2: (4, 0)
Texture coordinate for P3: (0, 1)
Texture coordinate for P4: (2, 1)
Texture coordinate for P5: (4, 1)
Texture coordinate for P6: (2, 3)
Texture coordinate for P7: (4, 3)
Texture coordinate for P8: (6, 3)
Texture coordinate for P9: (2, 4)
Texture coordinate for P10: (6, 4)
b. Texture coordinate for P1: (0, 0)
Texture coordinate for P2: (2, 0)
Texture coordinate for P3: (0, 0.5)
Texture coordinate for P4: (1, 0.5)
Texture coordinate for P5: (2, 0.5)
Texture coordinate for P6: (1, 1.5)
Texture coordinate for P7: (2, 1.5)
Texture coordinate for P8: (3, 1.5)
Texture coordinate for P9: (1, 2)
Texture coordinate for P10: (3, 2)
c. Texture coordinate for P1: (0, 0)
Texture coordinate for P2: (2, 0)
Texture coordinate for P3: (0, 1)
Texture coordinate for P4: (2, 1)
Texture coordinate for P5: (4, 1)
Texture coordinate for P6: (2, 2)
Texture coordinate for P7: (4, 2)
Texture coordinate for P8: (6, 2)
Texture coordinate for P9: (2, 3)
Texture coordinate for P10: (6, 3)
d. Texture coordinate for P1: (0, 0)
Texture coordinate for P2: (4, 0)
Texture coordinate for P3: (0, 0.5)
Texture coordinate for P4: (2, 0.5)
Texture coordinate for P5: (4, 0.5)
Texture coordinate for P6: (2, 1.5)
Texture coordinate for P7: (4, 1.5)
Texture coordinate for P8: (6, 1.5)
Texture coordinate for P9: (2, 2)
Texture coordinate for P10: (6, 2)
e. None of the others.

The correct answer is: Texture coordinate for P1: (0, 0)
Texture coordinate for P2: (2, 0)
Texture coordinate for P3: (0, 0.5)
Texture coordinate for P4: (1, 0.5)
Texture coordinate for P5: (2, 0.5)
Texture coordinate for P6: (1, 1.5)
Texture coordinate for P7: (2, 1.5)
Texture coordinate for P8: (3, 1.5)
Texture coordinate for P9: (1, 2)
Texture coordinate for P10: (3, 2)

2023b14

An object is defined with respect to the xyz (world) coordinate system. What OpenGL command can be used to to align that object with a new uvn-coordinate system sharing the same origin and with the unit vectors: 
$$u = \begin{pmatrix} -1 \\ 0 \\ 0  \end{pmatrix}, \mbox{    }  v = \begin{pmatrix} 0 \\ -1 \\ 0  \end{pmatrix}, \mbox{    } n = \begin{pmatrix} 0 \\ 0 \\ -1  \end{pmatrix} \mbox{  }?$$
a. glRotatef(180, -1, -1, -1)
b. glRotatef(180, 0, 0, 1)
c. glScalef(-1, -1, -1)
d. glTranslatef(-1, -1, -1)
e. glRotatef(180, 1, 1, 1)

The correct answer is: glScalef(-1, -1, -1)

2023b15

Given is a quadratic spline with the power basis
$$T=\begin{pmatrix} t^2 & t & 1\end{pmatrix}$$
and the basis matrix:
$$\begin{pmatrix} 1 & -2 & 1 \\ -2 & 2 & 0 \\ 1 & 0 & 0 \end{pmatrix}$$
Which statement about the resulting basis functions B_1(t), B_2(t), and B_3(t) is true?
Select one:
a. B_1(t)=-2*t^2+1
b. The sum of the three basis functions is always 0.
c. The basis functions are all cubic.
d. The basis functions are the basis functions of a quadratic Bezier curve.
e. B_3(1)=0

The correct answer is: The basis functions are the basis functions of a quadratic Bezier curve.

2023b16a

Given is a profile curve c(t)=(x(t), 0, z(t)), 0 ≤ t ≤ 1, which lies in the xz-plane. The resulting surface-of-revolution is shown in the image below. What is the parametric equation of the profile curve indicated in blue in the image below?
Image description: A surface of revolution is shown with a blue line on the surface. The blue line connects the points (0, 0, 3) and (3, 0, 2), then (3, 0, 2) and (4, 0, 0).
Select one:
$$a. c(t)=\begin{cases}$$
$$\begin{pmatrix} 6*t \\ 0 \\ 3-2*t \end{pmatrix} & \text{if } 0 \le t \le 0.5\\$$
$$\begin{pmatrix} 2*t+2 \\ 0 \\ 4*(1-t) \end{pmatrix} & \text{if } 0.5 \le t \le 1$$
$$\end{cases}$$
$$b. c(t)=\begin{cases}$$
$$\begin{pmatrix} 3*t \\ 0 \\ 3-2*t \end{pmatrix} & \text{if } 0 \le t \le 0.5\\$$
$$\begin{pmatrix} t+3 \\ 0 \\ 4*(1-t) \end{pmatrix} & \text{if } 0.5 \le t \le 1$$
$$\end{cases}$$
$$c. c(t)=\begin{cases}$$
$$\begin{pmatrix} 6*t \\ 0 \\ 3-t \end{pmatrix} & \text{if } 0 \le t \le 0.5\\$$
$$\begin{pmatrix} 2*t+2 \\ 0 \\ 2-t \end{pmatrix} & \text{if } 0.5 \le t \le 1$$
$$\end{cases}$$
$$d. c(t)=\begin{cases}$$
$$\begin{pmatrix} 3*t \\ 0 \\ 3-t \end{pmatrix} & \text{if } 0 \le t \le 0.5\\$$
$$\begin{pmatrix} t+3 \\ 0 \\ 2-t \end{pmatrix} & \text{if } 0.5 \le t \le 1$$
$$\end{cases}$$
$$e. c(t)=\begin{cases}$$
$$\begin{pmatrix} 3*t \\ 0 \\ 3-0.5*t \end{pmatrix} & \text{if } 0 \le t \le 0.5\\$$
$$\begin{pmatrix} 2*t+1 \\ 0 \\ 3-2*t \end{pmatrix} & \text{if } 0.5 \le t \le 1$$
$$\end{cases}$$

The correct answer is:
$$c(t)=\begin{cases}$$
$$\begin{pmatrix} 6*t \\ 0 \\ 3-2*t \end{pmatrix} & \text{if } 0 \le t \le 0.5\\$$
$$\begin{pmatrix} 2*t+2 \\ 0 \\ 4*(1-t) \end{pmatrix} & \text{if } 0.5 \le t \le 1$$
$$\end{cases}$$

2023b16b

Given is a profile curve c(t)=(x(t), 0, z(t)), 0 ≤ t ≤ 1, which lies in the xz-plane. The resulting surface-of-revolution is shown in the image below. What is the parametric equation of the profile curve indicated in blue in the image below?
Image description: A surface of revolution is shown with its profile curve on the xz-plane. The blue line connects the points (0, 0, 3) and (3, 0, 2), then (3, 0, 2) and (4, 0, 0).
Select one:
$$a. c(t)=\begin{cases}$$
$$\begin{pmatrix} 6*t \\ 0 \\ 3-2*t \end{pmatrix} & \text{if } 0 \le t \le 0.5\\$$
$$\begin{pmatrix} 2*t+2 \\ 0 \\ 4*(1-t) \end{pmatrix} & \text{if } 0.5 \le t \le 1$$
$$\end{cases}$$
$$b. c(t)=\begin{cases}$$
$$\begin{pmatrix} 3*t \\ 0 \\ 3-2*t \end{pmatrix} & \text{if } 0 \le t \le 0.5\\$$
$$\begin{pmatrix} t+3 \\ 0 \\ 4*(1-t) \end{pmatrix} & \text{if } 0.5 \le t \le 1$$
$$\end{cases}$$
$$c. c(t)=\begin{cases}$$
$$\begin{pmatrix} 6*t \\ 0 \\ 3-t \end{pmatrix} & \text{if } 0 \le t \le 0.5\\$$
$$\begin{pmatrix} 2*t+2 \\ 0 \\ 2-t \end{pmatrix} & \text{if } 0.5 \le t \le 1$$
$$\end{cases}$$
$$d. c(t)=\begin{cases}$$
$$\begin{pmatrix} 3*t \\ 0 \\ 3-t \end{pmatrix} & \text{if } 0 \le t \le 0.5\\$$
$$\begin{pmatrix} t+3 \\ 0 \\ 2-t \end{pmatrix} & \text{if } 0.5 \le t \le 1$$
$$\end{cases}$$
$$e. c(t)=\begin{cases}$$
$$\begin{pmatrix} 3*t \\ 0 \\ 3-0.5*t \end{pmatrix} & \text{if } 0 \le t \le 0.5\\$$
$$\begin{pmatrix} 2*t+1 \\ 0 \\ 3-2*t \end{pmatrix} & \text{if } 0.5 \le t \le 1$$
$$\end{cases}$$

The correct answer is:
$$c(t)=\begin{cases}$$
$$\begin{pmatrix} 6*t \\ 0 \\ 3-2*t \end{pmatrix} & \text{if } 0 \le t \le 0.5\\$$
$$\begin{pmatrix} 2*t+2 \\ 0 \\ 4*(1-t) \end{pmatrix} & \text{if } 0.5 \le t \le 1$$
$$\end{cases}$$

2023b17a

What is the parametric equation of the donut-shaped surface p(t)=(x(s,t), y(s,t), z(s,t)), 0 ≤ s,t ≤ 1 shown in the image below?
Hint 1: The surface is a surface-of-revolution as discussed in the lecture. The profile curve is an ellipsoid shown in the image below in blue.
Image description: A donut-shaped surface is shown with a blue line on the surface. The blue line is an ellipse covering three squares in the coordinate system, from (1, 0, 0) to (4, 0, 1).
Select one:
a. p(t)=
$$\begin{pmatrix} (1.5*cos(2 \pi t) + 2.5) cos (2 \pi s) \\ (1.5*cos(2 \pi t) + 2.5) sin (2 \pi s) \\ sin (2 \pi t) \end{pmatrix}$$
b. p(t)=
$$\begin{pmatrix} 1.5*cos(2 \pi t) cos (2 \pi s) +2.5  \\ 1.5*cos(2 \pi$$
$$t) sin (2 \pi s)  \\ sin (2 \pi t) \end{pmatrix}$$
c. p(t)=
$$\begin{pmatrix} 1.5*cos(2 \pi t) cos (2 \pi s) + 2.5  \\ 1.5*cos(2 \pi$$
$$t) sin (2 \pi s) +2.5 \\ sin (2 \pi t) \end{pmatrix}$$
d. p(t)=
$$\begin{pmatrix} 3*cos(2 \pi t) cos (2 \pi s) \\ cos(2 \pi$$
$$t) sin (2 \pi s) \\ sin (2 \pi s) \end{pmatrix}$$
e. p(t)=
$$\begin{pmatrix} 3*cos(2 \pi t) cos (2 \pi s) + 2.5 \\ cos(2 \pi$$
$$t) sin (2 \pi s) \\ sin (2 \pi s) \end{pmatrix}$$

The correct answer is:
p(t)=
$$\begin{pmatrix} (1.5*cos(2 \pi t) + 2.5) cos (2 \pi s) \\ (1.5*cos(2 \pi t) + 2.5) sin (2 \pi s) \\ sin (2 \pi t) \end{pmatrix}$$

2023b17b

What is the parametric equation of the donut-shaped surface p(t)=(x(s,t), y(s,t), z(s,t)), 0 ≤ s,t ≤ 1 shown in the image below?
Hint 1: The surface is a surface-of-revolution as discussed in the lecture. The profile curve is an ellipsoid shown in the image below in blue.
Image description: A donut-shaped surface is shown with its profile curve on the xz-plane. The blue line is an ellipse with the center (2.5, 0, 0.5), width 3, and height 1.
Select one:
a. p(t)=
$$\begin{pmatrix} (1.5*cos(2 \pi t) + 2.5) cos (2 \pi s) \\ (1.5*cos(2 \pi t) + 2.5) sin (2 \pi s) \\ sin (2 \pi t) \end{pmatrix}$$
b. p(t)=
$$\begin{pmatrix} 1.5*cos(2 \pi t) cos (2 \pi s) +2.5  \\ 1.5*cos(2 \pi$$
$$t) sin (2 \pi s)  \\ sin (2 \pi t) \end{pmatrix}$$
c. p(t)=
$$\begin{pmatrix} 1.5*cos(2 \pi t) cos (2 \pi s) + 2.5  \\ 1.5*cos(2 \pi$$
$$t) sin (2 \pi s) +2.5 \\ sin (2 \pi t) \end{pmatrix}$$
d. p(t)=
$$\begin{pmatrix} 3*cos(2 \pi t) cos (2 \pi s) \\ cos(2 \pi$$
$$t) sin (2 \pi s) \\ sin (2 \pi s) \end{pmatrix}$$
e. p(t)=
$$\begin{pmatrix} 3*cos(2 \pi t) cos (2 \pi s) + 2.5 \\ cos(2 \pi$$
$$t) sin (2 \pi s) \\ sin (2 \pi s) \end{pmatrix}$$

The correct answer is:
p(t)=
$$\begin{pmatrix} (1.5*cos(2 \pi t) + 2.5) cos (2 \pi s) \\ (1.5*cos(2 \pi t) + 2.5) sin (2 \pi s) \\ sin (2 \pi t) \end{pmatrix}$$

2023b18

Which of the matrices below is the correct MODEL_VIEW matrix after executing the following OpenGL commands:
glMatrixMode(GL_MODELVIEW );
glLoadIdentity();
glRotatef(-90, 0, 0, 1);
glTranslatef(2, 0, 1);
glScalef(1, 3, 2);
Question 18Answer
a. $$\begin{pmatrix} 0 & 1 & 0 & 2 \\ 3 & 0 & 0 & 0$$
$$\\ 0 & 0 & 2 & 1 \\ 0 & 0 & 0 & 1$$
$$\end{pmatrix}$$
b. $$\begin{pmatrix} 0 & -1 & 0 & 2 \\ 3 & 0 & 0 & 0$$
$$\\ 0 & 0 & 2 & 1 \\ 0 & 0 & 0 & 1$$
$$\end{pmatrix}$$
c. $$\begin{pmatrix} 1 & 0 & 0 & 2 \\ 0 & 3 & 0 & 0 \\ 0 & 0 & 2 & 1 \\ 0 & 0 & 0 & 1$$
$$\end{pmatrix}$$
d. $$\begin{pmatrix} 0 & 1 & 0 & 2 \\ -3 & 0 & 0 & 0$$
$$\\ 0 & 0 & 2 & 1 \\ 0 & 0 & 0 & 1$$
$$\end{pmatrix}$$
e. $$\begin{pmatrix} 0 & 3 & 0 & 0 \\ -1 & 0 & 0 & -2 \\ 0 & 0 & 2 & 1 \\ 0 & 0 & 0 & 1 \end{pmatrix}$$

The correct answer is:
$$\begin{pmatrix} 0 & 3 & 0 & 0 \\ -1 & 0 & 0 & -2 \\ 0 & 0 & 2 & 1 \\ 0 & 0 & 0 & 1 \end{pmatrix}$$

2023b19

Given is a uvn-coordinate system with the origin 
$$O_{uvn} = \begin{pmatrix} 2 \\ -1  \\ -2 \end{pmatrix}$$
and the coordinate axis 
$${\bf u} = \begin{pmatrix} -1 \\ 0  \\ 0 \end{pmatrix}\text{ ,  } {\bf v} = \begin{pmatrix} 0 \\ 0  \\ 1 \end{pmatrix}\text{  and } {\bf n} = \begin{pmatrix} 0 \\ -1  \\ 0 \end{pmatrix}$$
Given is a point P with the uvn-coordinates 
$${\bf p}_{uvn} = \begin{pmatrix} 2 \\ 1  \\ 3 \end{pmatrix}$$
.
What are the xyz-coordinates (world coordinates) of this point?
Select one:
a. $$\begin{pmatrix} -3 \\ 1  \\ -3 \end{pmatrix}$$
b. $$\begin{pmatrix} 0  \\ -4  \\ -1 \end{pmatrix}$$
c. $$\begin{pmatrix} -1 \\ -3  \\ -2 \end{pmatrix}$$
d. $$\begin{pmatrix} -1 \\ -2  \\ -1 \end{pmatrix}$$
e. $$\begin{pmatrix} 1 \\ -3  \\ -5 \end{pmatrix}$$

The correct answer is:
$$\begin{pmatrix} 0  \\ -4  \\ -1 \end{pmatrix}$$

2023b20a

A plane n.p=d defines a half-space, where the half space are all points where n.p<=d.
For example, for the plane x=0 the half space are all points with an x-coordinate <=0.
Using this definition we can now define a "cut-sphere" as the intersection of a sphere S and a half-space defined by the plane P. I.e., the "cut-sphere" contains all points which are inside the sphere and inside the half-space defined by P. The image below shows an example.
Image description: The image shows a sphere shown in red with a chunk cut off, in front of a blue and green background. Some shadows of the object are cast on the ground.
Which of the statements below about the ray intersection with a "cut-sphere" (defined by a sphere S and a plane P) is false?
NOTE: You can assume that the "cut-sphere" is in front of the eye point.
Select one:
a. If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P and the sphere S AND the intersection parameter with the plane P is between the two intersection parameters with the sphere S, then the intersection point with the "cut-sphere" is equal to the first intersection point with the sphere S.
b. If the dot product of the ray direction and the normal of P is positive AND the ray intersects the plane P before it intersects the sphere S, then the "cut-sphere" object does not exist (i.e., the intersection of the sphere and half-space is empty).
c. If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P before it intersects the sphere S, then the "cut-sphere" object is equal to the sphere S (i.e., the intersection of the sphere and half-space is the sphere and nothing gets cut off.).
d. The surface normal of a cut-sphere is either the normal of the sphere S or the normal of the plane P dependent on where the ray intersects the "cut-sphere" first.
e. If the dot product of the ray direction and the normal of P is positive AND the ray intersects the plane P after it intersects the sphere S, then the intersection point with the "cut-sphere" is given by the intersection point with the sphere S.

The correct answer is: If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P and the sphere S AND the intersection parameter with the plane P is between the two intersection parameters with the sphere S, then the intersection point with the "cut-sphere" is equal to the first intersection point with the sphere S.

2023b20b

A plane n.p=d defines a half-space, where the half space are all points where n.p<=d.
For example, for the plane x=0 the half space are all points with an x-coordinate <=0.
Using this definition we can now define a "cut-sphere" as the intersection of a sphere S and a half-space defined by the plane P. I.e., the "cut-sphere" contains all points which are inside the sphere and inside the half-space defined by P. The image below shows an example.
Image description: The image shows a spherical cap, or a sphere with a portion cut off. The cut portion of the sphere is not shown, and the background behind that portion is shown, since light would past through the cut portion of the sphere.
Which of the statements below about the ray intersection with a "cut-sphere" (defined by a sphere S and a plane P) is false?
NOTE: You can assume that the "cut-sphere" is in front of the eye point.
Select one:
a. If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P and the sphere S AND the intersection parameter with the plane P is between the two intersection parameters with the sphere S, then the intersection point with the "cut-sphere" is equal to the first intersection point with the sphere S.
b. If the dot product of the ray direction and the normal of P is positive AND the ray intersects the plane P before it intersects the sphere S, then the "cut-sphere" object does not exist (i.e., the intersection of the sphere and half-space is empty).
c. If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P before it intersects the sphere S, then the "cut-sphere" object is equal to the sphere S (i.e., the intersection of the sphere and half-space is the sphere and nothing gets cut off.).
d. The surface normal of a cut-sphere is either the normal of the sphere S or the normal of the plane P dependent on where the ray intersects the "cut-sphere" first.
e. If the dot product of the ray direction and the normal of P is positive AND the ray intersects the plane P after it intersects the sphere S, then the intersection point with the "cut-sphere" is given by the intersection point with the sphere S.

The correct answer is: If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P and the sphere S AND the intersection parameter with the plane P is between the two intersection parameters with the sphere S, then the intersection point with the "cut-sphere" is equal to the first intersection point with the sphere S.

2023b21

Consider the 5x5 grayscale image, J, defined by the grid lattice below. Given also, is the a 3x3 Gaussian Kernel, K.
What is the resulting value at pixel location (2,2) of the image obtained by applying Gaussian Kernel K, to image J?
Image J:
4	8	8	8	8	8
3	16	16	16	16	16
2	48	48	48	48	48
1	32	32	32	32	32
0	8	8	8	8	8
        0	1	2	3	4
Gaussian Kernel K:
2	1/16	1/8	1/16
1	1/8	1/4	1/8
0	1/16	1/8	1/16
        0	1	2
Note: Do not process all pixels that are within a 1 pixel border around the image.
Select one:
a. None of the others
b. 40
c. 36
d. 32
e. 28

The correct answer is: 36

2023b22

Consider the 4x4 binary image, J, defined by the grid lattice below. Given also, is the square-like 3x3 structuring element,S, which contains all "1"-value pixels and has the origin at the center (1,1). The horizontal is x axis and the vertical is y axis. Each pixel location is denoted as (x,y) of position index.
Use "Padding 0" (Extending border values outside with zeros).
What is the resulting value at pixel location (3, 2) of the image obtained after performing a binary dilation of image J with structuring element S?
Image J:
3	1	0	1	0
2	0	1	0	0
1	1	0	1	0
0	1	0	0	1
        0	1	2	3
Structuring Element S
2	1	1	1
1	1	1	1
0	1	1	1
        0	1	2
Select one:
a. 1
b. None of the others
c. 0
d. 2
e. Undefined

The correct answer is: 1

2023b23

Consider the 4x4 table representing the greyscale (8-bit) image J below. What is the image value at the pixel location (x=0, y=2) after performing the histogram equalization? The image value has to be rounded to the nearest integer.
3	16	64	32	8
2	16	16	16	16
1	64	16	16	8
0	16	8	32	64
        0	1	2	3
The bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.
Select one:
a. None of the others
b. 157
c. 128
d. 16
e. 136

The correct answer is: 157

2023b24

Consider the 4x4 table representing the greyscale image J below. What is the pixel value for the cumulative histogram count of 11?
3	8	4	16	16
2	32	32	32	8
1	0	0	128	8
0	8	255	16	8
        0	1	2	3
The bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.
Select one:
a. 0
b. 3
c. 4
d. None of the others
e. 16

The correct answer is: 16

2023b25

Consider the 5x5 binary image, J, defined by the grid lattice below. Given also, is the cross-like 3x3 structuring element,S, which contains "1"-value pixels except at the corners and has the origin at the center (1,1).
What is the value at pixel location (2,2) of the morphological gradient of image J with structuring element S?
Image J:
4	0	0	0	0	0
3	0	0	1	0	0
2	0	1	1	1	0
1	0	0	1	0	0
0	0	0	0	0	0
        0	1	2	3	4	
Structuring Element S:
2	0	1	0
1	1	1	1
0	0	1	0
        0	1	2
Note: Do not process all pixels that are within a 1 pixel border around the image.
Select one:
a. 0
b. Undefined
c. 2
d. 1
e. None of the others

The correct answer is: 0

2023b26

Consider the greyscale image J defined below What will be the threshold (rounded to the nearest integer) computed after running three iterations of the adaptive threshold technique as described in class?
3	128	16	64	16
2	128	32	32	16
1	128	128	8	128
0	8	8	16	64
        0	1	2	3
The bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.
Select one:
a. 63
b. 73
c. 56
d. 58
e. 68

The correct answer is: 63

2023b27

Consider the 4x4 table representing the grayscale image J below. What is the result when a 3x3 median filter is applied? For boundary handling, use BoundaryPaddingZero.
3	0	8	16	64
2	8	16	32	64
1	16	32	64	128
0	64	64	128	128
        0	1	2	3
The bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.
What is the value of median filtered image at x=0, y=3?
What is the value of median filtered image at x=2, y=1?
What is the value of median filtered image at x=3, y=1?

The correct answer is: 0, 64, 64

2023b28

Which coefficients of the linear mapping operation, g(x,y)=af(x,y) + b, will map the pixel value f(x,y)=75 to g(x,y)=88 and pixel value f(x,y)=155 to g(x,y)=216?
Which effect does this linear mapping operation defined by a and b have, when applied to an image?

The correct answer is: a is 1.6 and b is -32, contrast is increased and brightness is decreased

2023b29

Consider the 4x4 table representing the greyscale (8-bit) image J below. Compute the effect of a logarithmic contrast stretching on the image, which aims to increase the dynamic range of darker regions in the image.
The logarithmic contrast stretching operation transforms the input image J(x,y) pixelwise to an output image G(x,y) according to the equation:
$$G(x,y) = \frac{log(1+J(x,y))}{log(1 + Q)}$$
Here Q is the maximal greyvalue of the greyscale range of the input image.
The logarithmic function is applied to each input pixel of the 8 bit input range, and generates an output in the range between 0 and 1. You finally have to transform this output range to the same (8-bit) range that the input image has. Round to the nearest integer.
After computation of G, what is the pixel value of the final resulting image at the pixel location (x=1, y=0)?
3	8	8       8       8
2	16      4       4       16
1	32      128	255     32
0	16	64	64      16
        0	1	2	3
The bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.
Select one:
a. 101
b. None of the others.
c. 161
d. 223
e. 255
f. 192
g. 130
h. 74

The correct answer is: 192

2023b30a

Given is an RGB colour cube with side length 2 as illustrated in the image below"
Image description: The image shows a RGB colour cube with side length 2. The colours shown are green, cyan, blue, pink, red, and yellow in counterclockwise order, where red is on the x-axis.
Please write OpenGL code to transform the cube as shown in the image below. The cube should be scaled by 2 in z-direction, the face with the black, green, blue and cyan vertex should form an angle of 70 degree with the yz-plane, and the edge from black to blue should be parallel to the z-axis with a distance of 2 and should lie on the yz-plane.
Image description: The image shows the RGB colour cube, but transformed as described above.
IMPORTANT:
Please only use OpenGL transformations, e.g. glTranslatef, glRotatef
Please do NOT draw the cube itself - this is done automatically by the uploaded code

NULL

2023b30b

Given is an RGB colour cube with side length 2 as illustrated in the image below"
Image description: The image shows a RGB colour cube with side length 2. The point representing white is on (2, 2, 2), the point representing blue is on (0, 0, 2), and the point representing red is on (2, 0, 0).
Please write OpenGL code to transform the cube as shown in the image below. The cube should be scaled by 2 in z-direction, the face with the black, green, blue and cyan vertex should form an angle of 70 degree with the yz-plane, and the edge from black to blue should be parallel to the z-axis with a distance of 2 and should lie on the yz-plane.
Image description: The image shows the RGB colour cube, but transformed as described above.
IMPORTANT:
Please only use OpenGL transformations, e.g. glTranslatef, glRotatef
Please do NOT draw the cube itself - this is done automatically by the uploaded code

NULL

2023b31a

Given is a function drawTorus() which draws a torus with colored "blobs" centred at the origin and aligned with the z-axis as shown in the image below.
Image description: The image shows a torus centered at the origin and aligned with z-axis. The torus is coloured with green, blue, yellow, and pink in counterclockwise order, where green is on the x-axis.
Please write OpenGL code to render the two tori displayed in the image below:
Image description: The image shows two tori. The first torus is centered at the (1, 1, 0), with yellow, pink, green, and blue in counterclockwise order, where yellow is on the y-axis. The second torus is centered at (0, 1, 1), with green, blue, yellow, and pink in counterclockwise order, where yellow is on the y-axis.
Note that the first torus lies on the xy-plane with centre (1, 1, 0), and the second  torus lies on the yz-plane with centre (0, 1, 1).
IMPORTANT:
Your code must draw the tori in the order described above. Your code should have the format:
<insert your transformations>
drawTorus();
<insert your transformations>
drawTorus();
Note: transformations refers to OpenGL transformations, e.g. glRotatef, glTranslatef, glScalef, glPushMatrix and glPopMatrix

NULL

2023b31b

Given is a function drawTorus() which draws a torus with colored "blobs" centred at the origin and aligned with the z-axis as shown in the image below.
Image description: The image shows a torus centered at the origin and on the x-y plane. The torus is coloured with green, blue, yellow, and pink in counterclockwise order, where green is on the x-axis.
Please write OpenGL code to render the two tori displayed in the image below:
Image description: The image shows two tori. The first torus is centered at the (1, 1, 0) and on the x-y plane, with yellow, pink, green, and blue in counterclockwise order, where yellow is on the y-axis. The second torus is centered at (0, 1, 1) and on the y-z plane, with green, blue, yellow, and pink in counterclockwise order, where yellow is on the y-axis.
Note that the first torus lies on the xy-plane with centre (1, 1, 0), and the second  torus lies on the yz-plane with centre (0, 1, 1).
IMPORTANT:
Your code must draw the tori in the order described above. Your code should have the format:
<insert your transformations>
drawTorus();
<insert your transformations>
drawTorus();
Note: transformations refers to OpenGL transformations, e.g. glRotatef, glTranslatef, glScalef, glPushMatrix and glPopMatrix

NULL

2023b32a

Write a function animateBouncyBall(), which takes as parameters the position p of a ball and its velocity v and a plane in dot-normal form given by n (unit normal) and d. The function updates the ball's position and velocity for one animation step. Your function should have the following signature:
void animateBouncyBall(Vector3& p, Vector3& v, Vector3& n, double& d)
Note: The "&" symbol represents a reference variable, i.e., any change to this variable will be visible outside the function. You can use it like a normal variable of type Vector3.
You can assume that the ball's position p is initially on the outside of the plane (the side the normal points to). Your function should update p such that its new value is p+v and the velocity v stays unchanged. However, if the new point p+v is on the other side of the plane, then you must reflect the vector v on the plane and the new velocity is v_reflected and the new point is p+v_reflected.
Note: You can ignore that the point p is not exactly on the plane when reflected.
The image below illustrates how the position and velocity of the ball change if the function animateBouncyBall() is called multiple times.
Image description: The image shows a line in a coordinate system, and a ball travelling towards the line, after it makes contact with the plane it is reflected to a different direction.
You can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z, and that the following functions are available to you:
double dot(Vector3 u, Vector3 v) //dot product
Vector3 cross(Vector3 u, Vector3 v) //cross product
You can assume that the Vector3 class has the following member functions available to you:
Vector3 Vector3.normalized() //returns a vector pointing in the same direction with length 1
double Vector3.magnitude() //returns the length of the vector
You can assume that the Vector3 class supports the following operators returning an object of type Vector3:
Vector3 + Vector3
Vector3 - Vector3
Vector3 * double // Note: the order is important, the scalar has to come after the vector when multiplying
For example:
Test1
Vector3 n=Vector3(1, 0, 0); // plane unit normal
double d=0;                 // plane distance from origin
Vector3 p = Vector3(0.5, 0.0, 0.0);
Vector3 v = Vector3(-0.2, 0.0, 0.0);
printf("position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\n", p.x, p.y, p.z, v.x, v.y, v.z);
animateBouncyBall(p, v, n, d);
printf("position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\n", p.x, p.y, p.z, v.x, v.y, v.z);
animateBouncyBall(p, v, n, d);
printf("position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\n", p.x, p.y, p.z, v.x, v.y, v.z);
animateBouncyBall(p, v, n, d);
printf("position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\n", p.x, p.y, p.z, v.x, v.y, v.z);
animateBouncyBall(p, v, n, d);
printf("position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\n", p.x, p.y, p.z, v.x, v.y, v.z);
Result1
position=(0.50,0.00,0.00) velocity=(-0.20,0.00,0.00)
position=(0.30,0.00,0.00) velocity=(-0.20,0.00,0.00)
position=(0.10,0.00,0.00) velocity=(-0.20,0.00,0.00)
position=(0.30,0.00,0.00) velocity=(0.20,0.00,0.00)
position=(0.50,0.00,0.00) velocity=(0.20,0.00,0.00)

NULL

2023b32b

Write a function animateBouncyBall(), which takes as parameters the position p of a ball and its velocity v and a plane in dot-normal form given by n (unit normal) and d. The function updates the ball's position and velocity for one animation step. Your function should have the following signature:
void animateBouncyBall(Vector3& p, Vector3& v, Vector3& n, double& d)
Note: The "&" symbol represents a reference variable, i.e., any change to this variable will be visible outside the function. You can use it like a normal variable of type Vector3.
You can assume that the ball's position p is initially on the outside of the plane (the side the normal points to). Your function should update p such that its new value is p+v and the velocity v stays unchanged. However, if the new point p+v is on the other side of the plane, then you must reflect the vector v on the plane and the new velocity is v_reflected and the new point is p+v_reflected.
Note: You can ignore that the point p is not exactly on the plane when reflected.
The image below illustrates how the position and velocity of the ball change if the function animateBouncyBall() is called multiple times.
Image description: The image shows a line in a coordinate system, and a ball travelling towards the line, and the direction is denoted as v, after it makes contact with the plane it is reflected to a different direction, denoted as v_reflected. The normal of the reflection is denoted as n. The angle of incidence is equal to the angle of reflection.
You can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z, and that the following functions are available to you:
double dot(Vector3 u, Vector3 v) //dot product
Vector3 cross(Vector3 u, Vector3 v) //cross product
You can assume that the Vector3 class has the following member functions available to you:
Vector3 Vector3.normalized() //returns a vector pointing in the same direction with length 1
double Vector3.magnitude() //returns the length of the vector
You can assume that the Vector3 class supports the following operators returning an object of type Vector3:
Vector3 + Vector3
Vector3 - Vector3
Vector3 * double // Note: the order is important, the scalar has to come after the vector when multiplying
For example:
Test1
Vector3 n=Vector3(1, 0, 0); // plane unit normal
double d=0;                 // plane distance from origin
Vector3 p = Vector3(0.5, 0.0, 0.0);
Vector3 v = Vector3(-0.2, 0.0, 0.0);
printf("position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\n", p.x, p.y, p.z, v.x, v.y, v.z);
animateBouncyBall(p, v, n, d);
printf("position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\n", p.x, p.y, p.z, v.x, v.y, v.z);
animateBouncyBall(p, v, n, d);
printf("position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\n", p.x, p.y, p.z, v.x, v.y, v.z);
animateBouncyBall(p, v, n, d);
printf("position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\n", p.x, p.y, p.z, v.x, v.y, v.z);
animateBouncyBall(p, v, n, d);
printf("position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\n", p.x, p.y, p.z, v.x, v.y, v.z);
Result1
position=(0.50,0.00,0.00) velocity=(-0.20,0.00,0.00)
position=(0.30,0.00,0.00) velocity=(-0.20,0.00,0.00)
position=(0.10,0.00,0.00) velocity=(-0.20,0.00,0.00)
position=(0.30,0.00,0.00) velocity=(0.20,0.00,0.00)
position=(0.50,0.00,0.00) velocity=(0.20,0.00,0.00)

NULL

2023b33a

In this question we want to create the front and right side of the texture mapped muesli box shown in the image below:
Image description: The image shows a muesli box in a 3D coordinate system.
The 3D model uses a quadstrip for the front and right side and a quadrilateral for the top side, which are textured using the texture image below. Note that the sections of the texture image used for the front and right side of the box are rectangular (illustrated in green in the image below) and the section of the texture image used for the top side of the box is a trapezoid (illustrated in blue in the image below).
Image description: The image shows a flat texture image of a muesli box, the texture coordinates of the front are (0.12, 0.12), (0.49, 0.12), (0.49, 0.88), and (0.12, 0.88); those of the right are (0.49, 0.12), (0.62, 0.12), (0.62, 0.88), and (0.49, 0.88); and those of the top are (0.12, 0.88), (0.49, 0.88), (0.47, 0.99), and (0.14, 0.99).
Please only use the texture coordinates indicated in the image above in order to define the missing values for s1, s2, s3, s4, s5 and t1, t2, t3 in the code shown in the answer box. Please do not change anything else.
Template code:
s1 = 0;  // please replace with the correct texture coordinate 
s2 = 0;  // please replace with the correct texture coordinate  
s3 = 0;  // please replace with the correct texture coordinate 
s4 = 0;  // please replace with the correct texture coordinate 
s5 = 0;  // please replace with the correct texture coordinate 
t1 = 0;  // please replace with the correct texture coordinate  
t2 = 0;  // please replace with the correct texture coordinate 
t3 = 0;  // please replace with the correct texture coordinate 
// front and right face face
glBegin(GL_QUAD_STRIP);
glTexCoord2f(s1, t1);
glVertex3f(0, 0, 0.7);
glTexCoord2f(s1, t2);
glVertex3f(0, 4, 0.7);
glTexCoord2f(s2, t1);
glVertex3f(2, 0, 0.7);
glTexCoord2f(s2, t2);
glVertex3f(2, 4, 0.7);
glTexCoord2f(s3, t1);
glVertex3f(2, 0, 0);
glTexCoord2f(s3, t2);
glVertex3f(2, 4, 0);
glEnd();
// top face
glBegin(GL_QUADS);
glTexCoord2f(s1, t2);
glVertex3f(0, 4, 0.7);
glTexCoord2f(s2, t2);
glVertex3f(2, 4, 0.7);
glTexCoord2f(s5, t3);
glVertex3f(2, 4, 0);
glTexCoord2f(s4, t3);
glVertex3f(0, 4, 0);
glEnd();

NULL

2023b33b

In this question we want to create the front and right side of the texture mapped muesli box shown in the image below:
Image description: The image shows a cuboid, where the surface is textured like a muesli box, in a 3D coordinate system, with the front, top, and side shown.
The 3D model uses a quadstrip for the front and right side and a quadrilateral for the top side, which are textured using the texture image below. Note that the sections of the texture image used for the front and right side of the box are rectangular (illustrated in green in the image below) and the section of the texture image used for the top side of the box is a trapezoid (illustrated in blue in the image below).
Image description: The image shows a flat texture image of an unravelled muesli box, the texture coordinates of the front are (0.12, 0.12), (0.49, 0.12), (0.49, 0.88), and (0.12, 0.88); those of the right are (0.49, 0.12), (0.62, 0.12), (0.62, 0.88), and (0.49, 0.88); and those of the top are (0.12, 0.88), (0.49, 0.88), (0.47, 0.99), and (0.14, 0.99).
Please only use the texture coordinates indicated in the image above in order to define the missing values for s1, s2, s3, s4, s5 and t1, t2, t3 in the code shown in the answer box. Please do not change anything else.
Template code:
s1 = 0;  // please replace with the correct texture coordinate 
s2 = 0;  // please replace with the correct texture coordinate  
s3 = 0;  // please replace with the correct texture coordinate 
s4 = 0;  // please replace with the correct texture coordinate 
s5 = 0;  // please replace with the correct texture coordinate 
t1 = 0;  // please replace with the correct texture coordinate  
t2 = 0;  // please replace with the correct texture coordinate 
t3 = 0;  // please replace with the correct texture coordinate 
// front and right face face
glBegin(GL_QUAD_STRIP);
glTexCoord2f(s1, t1);
glVertex3f(0, 0, 0.7);
glTexCoord2f(s1, t2);
glVertex3f(0, 4, 0.7);
glTexCoord2f(s2, t1);
glVertex3f(2, 0, 0.7);
glTexCoord2f(s2, t2);
glVertex3f(2, 4, 0.7);
glTexCoord2f(s3, t1);
glVertex3f(2, 0, 0);
glTexCoord2f(s3, t2);
glVertex3f(2, 4, 0);
glEnd();
// top face
glBegin(GL_QUADS);
glTexCoord2f(s1, t2);
glVertex3f(0, 4, 0.7);
glTexCoord2f(s2, t2);
glVertex3f(2, 4, 0.7);
glTexCoord2f(s5, t3);
glVertex3f(2, 4, 0);
glTexCoord2f(s4, t3);
glVertex3f(0, 4, 0);
glEnd();

NULL

2023b34a

Given is a cubic spline curve c(t)=T M G with the geometric constraint vector
G=(p0, p1, p2, p3)^T
The basis matrix of the spline curve is
$$\bf{M}=\begin{pmatrix} -4.5 & 13.5 & -13.5 & 4.5 \\ 9 & -22.5 & 18 & -4.5$$
$$\\ -5.5 & 9 & -4.5 & 1 \\ 1 & 0 & 0 & 0 \end{pmatrix}$$
The spline curve is used as profile curve for a surface-of-revolution.
Implement this curve by defining its basis functions and completing the code fragment below.
Please write your answer into the answer space using the following format:
double Basis1(double t){ return <Insert code>;} 
double Basis2(double t){ return <Insert code>;}
double Basis3(double t){ return <Insert code>;} 
double Basis4(double t){ return <Insert code>;} 
CVec3df curve(float t)
{
  // return the curve point c(t) of type CVec3df   
}
The first test case uses the geometric constraints:
const CVec3df p0(1, 0, 0);
const CVec3df p1(1.6666, 0, 0.2);
const CVec3df p2(2.3333, 0, 1.5);
const CVec3df p3(3, 0, 1);
and should result into the image below:
Image description: A surface of revolution is shown with a blue curve on the surface.
You can assume that the CVec3df class supports the following operators returning an object of type CVec3df:
CVec3df + CVec3df
CVec3df * double // Note: the order is important, the scalar has to come after the vector when multiplying

NULL

2023b34b

Given is a cubic spline curve c(t)=T M G with the geometric constraint vector
G=(p0, p1, p2, p3)^T
The basis matrix of the spline curve is
$$\bf{M}=\begin{pmatrix} -4.5 & 13.5 & -13.5 & 4.5 \\ 9 & -22.5 & 18 & -4.5$$
$$\\ -5.5 & 9 & -4.5 & 1 \\ 1 & 0 & 0 & 0 \end{pmatrix}$$
The spline curve is used as profile curve for a surface-of-revolution.
Implement this curve by defining its basis functions and completing the code fragment below.
Please write your answer into the answer space using the following format:
double Basis1(double t){ return <Insert code>;} 
double Basis2(double t){ return <Insert code>;}
double Basis3(double t){ return <Insert code>;} 
double Basis4(double t){ return <Insert code>;} 
CVec3df curve(float t)
{
  // return the curve point c(t) of type CVec3df   
}
The first test case uses the geometric constraints:
const CVec3df p0(1, 0, 0);
const CVec3df p1(1.6666, 0, 0.2);
const CVec3df p2(2.3333, 0, 1.5);
const CVec3df p3(3, 0, 1);
and should result into the image below:
Image description: A surface of revolution is shown with a profile curve on the surface. The profile curve is described as the spline curve above.
You can assume that the CVec3df class supports the following operators returning an object of type CVec3df:
CVec3df + CVec3df
CVec3df * double // Note: the order is important, the scalar has to come after the vector when multiplying

NULL

2023b35

Given is a function drawCube() which draws a unit cube centered at the origin with coloured dots on its top (see image below). The top front corner has a yellow dot, the top-back corner has a cyan dot and the top-left and top-right corners have grey and magenta dots, respectively.
Please write OpenGL code to render a double barrel ball gun as illustrated in the image below. The ball gun consists of a stand (bottom part), a horizontal bar on top of it, and two barrels on the left and right of the horizontal bar. All objects have a square cross section with a width of width. The stand and the barrels have a length of length. The horizontal bar as a length of distance. The barrels form an angle of θ (theta) with the xz-plane. The rotation axis is the centre line of the horizontal bar. The stand is centred on the y-axis. The whole ball gun is rotated by an angle φ (phi) around its centre axis.
IMPORTANT:
In order for the automarker to work correctly you:
(1) must use the function drawCube() to draw each robot arm
(2) must draw the components in the order explained in the image above on the right: first the stand, then the horizontal bar, then the barrel on the positive z-axis and then the barrel on the negative x-axis.
(3) must use the variables width, length, distance, phi, and theta, which have different values in the test cases.
(4) must make sure that the dots at the top of each cube are in the correct positions. If you rotate the cuboids around their axes the object looks the same, but the transformation matrices are different and the automarker will mark it as wrong.
Tip: Start by drawing the stand and the horizontal bar. Rotating the stand will rotate the whole ball gun. In addition to glRotatef, glTranslatef, and glScalef, you might also want to use glPushMatrix() and glPopMatrix().

NULL

2023b36a

In this exercise you need to complete the function below defining a Ray-CutSphere Intersection:
double CutSphere::Intersect(Vector source, Vector d)
NOTE: The pre-loaded answer box contains already code for the ray sphere intersection and sorts the intersection points such that t1 is the first intersection point with the original sphere.
Add additional code such that the function returns instead the intersection points with the "cut-sphere".
The cutting plane n.p=a is defined by the variables n (type Vector) and a (type double).
HINT: Compute the ray-plane intersection and develop an algorithm to decide whether the ray intersects the round (un-cut part) of the sphere, the cutting plane, or doesn't intersect the cut sphere at all (e.g. the ray might pass through the cut-off part of the sphere)
IMPORTANT: If the ray first intersects the cutting plane of the cut sphere (the flat part of it) then you need to set cuttingPlaneIntersected = true; . This is used in the normal calculation and without the automarker will mark your solution as false.
Note: The following variables and functions are already defined for you to use:
The plane n.p=a is defined by the variables n (type Vector) and a (type double).
Vector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector
Vector: v1-v2 - subtracts v2 from v1 and returns resulting vector
Vector: v1 * t - scales the vector v1 by t and returns resulting vector
Vector v.Scale(float a, float b, float c) - scales each component of the vector v
float v1.Dot(Vector v2) - returns the dot product of vector v1 and v2
Vector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2
After completing the code in the pre-loaded answer box you should get the images below:
Image description: The image shows a sphere shown in red with a chunk cut off, in front of a blue and green background. Some shadows of the object are cast on the ground.
Image description: The image shows the cut off chunk placed on the ground, in front of a blue and green background. Some shadows of the object are cast on the ground.
Template code:
double CutSphere::Intersect(Vector source, Vector d)
{
	// A, B, and C are the parameters of quadratic equation for finding the 
	// ray intersection parameter t (see slide 16 of the "Ray Tracing" lecture notes)
	float A = d.Dot(d);
	float B = 2 * source.Dot(d);
	float C = source.Dot(source) - 1;
	float t; // the parameter t for the closest intersection point or ray with the sphere. If no intersection t=-1.0
	// BEGIN SOLUTION RAY-SPHERE INTERSECTION
	if (B * B - 4 * A * C <= 0) return t=-1;  // no hit
	float t1;
	if (B > 0)   // for numerical precision
		t1 = (-B - sqrt(B * B - 4 * A * C)) / (2 * A);
	else
		t1 = (-B + sqrt(B * B - 4 * A * C)) / (2 * A);
	float t2 = C / (A * t1); // easier way to get t2
	// END SOLUTION RAY-SPHERE INTERSECTION
	// if t1>t2 swap, so t1 is always first intersection point
	float temp;
	if (t1 > t2) {
		temp = t1;
		t1 = t2;
		t2 = temp;
	}
	t = t1;
	cuttingPlaneIntersected = false; // variable of type bool - true if ray first intersects the flat part of the cut sphere
	// ===================================================================
	// == The above method code computes the intersection parameters of ==
	// == the ray with the sphere. Add additional code such that the    ==
	// == function returns instead the intersections points with the    ==
	// == "cut-sphere".                                                 ==
	// == Tip: Compute the ray-plane interscetion and develop an        ==
	// ==      algorithm to decide whether the ray intersected the      ==
	// ==      round (un-cut part) of the sphere, the cutting plane,    ==
	// ==      or doesn't intersect the cut spere at all (e.g. the ray  ==
	// ==      might pass through the cut-off part of the sphere        ==
    // == IMPORTANT: If the ray first intersects the cutting plane of   ==
	// ==            the cut sphere (the flat part of it) then you need ==
	// ==            to set cuttingPlaneIntersected = true;             ==
	// ==            This is used in the normal calculation and without ==
	// ==            the automarker will mark your solution as false    ==
	// ===================================================================
    // Please complete the missing code
	return t;
}

NULL

2023b36b

In this exercise you need to complete the function below defining a Ray-CutSphere Intersection:
double CutSphere::Intersect(Vector source, Vector d)
NOTE: The pre-loaded answer box contains already code for the ray sphere intersection and sorts the intersection points such that t1 is the first intersection point with the original sphere.
Add additional code such that the function returns instead the intersection points with the "cut-sphere".
The cutting plane n.p=a is defined by the variables n (type Vector) and a (type double).
HINT: Compute the ray-plane intersection and develop an algorithm to decide whether the ray intersects the round (un-cut part) of the sphere, the cutting plane, or doesn't intersect the cut sphere at all (e.g. the ray might pass through the cut-off part of the sphere)
IMPORTANT: If the ray first intersects the cutting plane of the cut sphere (the flat part of it) then you need to set cuttingPlaneIntersected = true; . This is used in the normal calculation and without the automarker will mark your solution as false.
Note: The following variables and functions are already defined for you to use:
The plane n.p=a is defined by the variables n (type Vector) and a (type double).
Vector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector
Vector: v1-v2 - subtracts v2 from v1 and returns resulting vector
Vector: v1 * t - scales the vector v1 by t and returns resulting vector
Vector v.Scale(float a, float b, float c) - scales each component of the vector v
float v1.Dot(Vector v2) - returns the dot product of vector v1 and v2
Vector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2
After completing the code in the pre-loaded answer box you should get the images below:
Image description: The image shows a sphere shown in red with a chunk cut off, in front of a blue and green background. Some shadows of the object are cast on the ground.
Image description: The image shows the cut off chunk placed on the ground, in front of a blue and green background. Some shadows of the object are cast on the ground.
Template code:
double CutSphere::Intersect(Vector source, Vector d)
{
	// A, B, and C are the parameters of quadratic equation for finding the 
	// ray intersection parameter t (see slide 16 of the "Ray Tracing" lecture notes)
	float A = d.Dot(d);
	float B = 2 * source.Dot(d);
	float C = source.Dot(source) - 1;
	float t; // the parameter t for the closest intersection point or ray with the sphere. If no intersection t=-1.0
	// BEGIN SOLUTION RAY-SPHERE INTERSECTION
	if (B * B - 4 * A * C <= 0) return t=-1;  // no hit
	float t1;
	if (B > 0)   // for numerical precision
		t1 = (-B - sqrt(B * B - 4 * A * C)) / (2 * A);
	else
		t1 = (-B + sqrt(B * B - 4 * A * C)) / (2 * A);
	float t2 = C / (A * t1); // easier way to get t2
	// END SOLUTION RAY-SPHERE INTERSECTION
	// if t1>t2 swap, so t1 is always first intersection point
	float temp;
	if (t1 > t2) {
		temp = t1;
		t1 = t2;
		t2 = temp;
	}
	t = t1;
	cuttingPlaneIntersected = false; // variable of type bool - true if ray first intersects the flat part of the cut sphere
	// ===================================================================
	// == The above method code computes the intersection parameters of ==
	// == the ray with the sphere. Add additional code such that the    ==
	// == function returns instead the intersections points with the    ==
	// == "cut-sphere".                                                 ==
	// == Tip: Compute the ray-plane interscetion and develop an        ==
	// ==      algorithm to decide whether the ray intersected the      ==
	// ==      round (un-cut part) of the sphere, the cutting plane,    ==
	// ==      or doesn't intersect the cut spere at all (e.g. the ray  ==
	// ==      might pass through the cut-off part of the sphere        ==
    // == IMPORTANT: If the ray first intersects the cutting plane of   ==
	// ==            the cut sphere (the flat part of it) then you need ==
	// ==            to set cuttingPlaneIntersected = true;             ==
	// ==            This is used in the normal calculation and without ==
	// ==            the automarker will mark your solution as false    ==
	// ===================================================================
    // Please complete the missing code
	return t;
}

NULL

2023b37a

In this exercise you need to complete the normal calculation for the Ray-CutSphere Intersection from the previous question. Note that you can complete this question even if you were unable to implement the intersection function correctly.
Please implement the function
Vector CutSphere::Normal(Vector p)
NOTE: The function should return the correct normal of the "cut: unit sphere at the ray intersection point p. Note that the cut-sphere is a unit sphere with centre at the origin. The normal of the cutting plane is n (type Vector).
NOTE 2: You can assume that the boolean variable cuttingPlaneIntersected is defined and that it is true if p lies on the flat part of the "cut" unit sphere and false otherwise.
Note: The following variables and functions are already defined for you to use:
The plane n.p=a is defined by the variables n (type Vector) and a (type double).
Vector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector
Vector: v1-v2 - subtracts v2 from v1 and returns resulting vector
Vector: v1 * t - scales the vector v1 by t and returns resulting vector
Vector v.Scale(float a, float b, float c) - scales each component of the vector v
float v1.Dot(Vector v2) - returns the dot product of vector v1 and v2
Vector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2
Vector v.Normalize() - returns the normalised version of the vector v
After completing the code in the pre-loaded answer box you should get the image below:
Image description: The image shows a sphere shown in red with a chunk cut off, in front of a blue and green background. Some shadows of the object are cast on the ground.

NULL

2023b37b

In this exercise you need to complete the normal calculation for the Ray-CutSphere Intersection from the previous question. Note that you can complete this question even if you were unable to implement the intersection function correctly.
Please implement the function
Vector CutSphere::Normal(Vector p)
NOTE: The function should return the correct normal of the "cut: unit sphere at the ray intersection point p. Note that the cut-sphere is a unit sphere with centre at the origin. The normal of the cutting plane is n (type Vector).
NOTE 2: You can assume that the boolean variable cuttingPlaneIntersected is defined and that it is true if p lies on the flat part of the "cut" unit sphere and false otherwise.
Note: The following variables and functions are already defined for you to use:
The plane n.p=a is defined by the variables n (type Vector) and a (type double).
Vector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector
Vector: v1-v2 - subtracts v2 from v1 and returns resulting vector
Vector: v1 * t - scales the vector v1 by t and returns resulting vector
Vector v.Scale(float a, float b, float c) - scales each component of the vector v
float v1.Dot(Vector v2) - returns the dot product of vector v1 and v2
Vector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2
Vector v.Normalize() - returns the normalised version of the vector v
After completing the code in the pre-loaded answer box you should get the image below:
Image description: The image shows a spherical cap, or a sphere with a portion cut off. The cut portion of the sphere is not shown, and the background behind that portion is shown, since light would past through the cut portion of the sphere.

NULL
