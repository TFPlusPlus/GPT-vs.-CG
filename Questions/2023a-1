2023a01

Given are two vectors
{\bf u} = \begin{pmatrix} 3 \\ 1  \\ c \end{pmatrix}
and
{\bf v} = \begin{pmatrix} 2 \\ 4  \\ -2 \end{pmatrix}
.
For what value of c are u and v orthogonal?
Select one:
a. -4
b. -2
c. 0
d. 3
e. 5

The correct answer is: 5

2023a02

Given is a plane P with a normal n and an unknown vector v.
The projection of v onto the plane is vP and the projection of the vector v onto the normal n has a length of k.
What is the vector v?
Select one:
a. {\bf v}=\frac{{\bf v_{plane}}}{|{\bf v_{plane}}|}-k\frac{{\bf n}}{|{\bf n}|}
b. {\bf v}=\frac{{\bf v_{plane}}}{|{\bf v_{plane}}|}+k\frac{{\bf n}}{|{\bf n}|}
c. None of the others
d. {\bf v}={\bf v_{plane}}-k\frac{{\bf n}}{|{\bf n}|}
e. {\bf v}={\bf v_{plane}}+k\frac{{\bf n}}{|{\bf n}|}

The correct answer is:
{\bf v}={\bf v_{plane}}+k\frac{{\bf n}}{|{\bf n}|}

2023a03

Given are two vectors
{\bf u} = \begin{pmatrix} 0 \\ 1  \\ 3 \end{pmatrix}
and
{\bf v} = \begin{pmatrix} c \\ 0  \\ 0 \end{pmatrix}
.
Assuming c>0, which of the statements below about the cross product of u and v is true?
Select one:
a. The resulting vector is zero, i.e., it is the origin.
b. None of the others
c. The resulting vector lies in the xy-plane, i.e., its z-coordinate is zero
d. The resulting vector lies in the yz-plane, i.e., its x-coordinate is zero
e. The resulting vector lies in the xz-plane, i.e., its y-coordinate is zero

The correct answer is: The resulting vector lies in the yz-plane, i.e., its x-coordinate is zero

2023a04

\small\text{Consider a plane $P$ defined by the equation $2x - 2y - z = 3$ and a point $Q = \begin{pmatrix} 3 \\ -2  \\ 1 \end{pmatrix}$.}
\small\text{What is the absolute distance of the point $Q$ to the plane $P$?}
Select one:
a. 3
b. 2
c. 0 (the point is on the plane)
d. 1
e. 4

The correct answer is: 2

2023a05

Which of the 3D homogeneous matrices below first translates a point by the vector
P = \begin{pmatrix} 1 \\ 2 \\ 3  \end{pmatrix}
and then rotates it by 90 degree around the x-axis?
Answer
a. \begin{pmatrix} 1 & 0 & 0 & 1 \\ 0 & 0 & 1 & 3 \\ 0 & -1 & 0 & -2 \\ 0 & 0 & 0 & 1 
\end{pmatrix}
b. \begin{pmatrix} 1 & 0 & 0 & 1 \\ 0 & 0 & -1 & 2 \\ 0 & 1 & 0 & 3 \\ 0 & 0 & 0 & 1 
\end{pmatrix}
c. \begin{pmatrix} 1 & 0 & 0 & 1 \\ 0 & 0 & -1 & -3 \\ 0 & 1 & 0 & 2 \\ 0 & 0 & 0 & 1 \end{pmatrix}
d. None of the others.
e. \begin{pmatrix} 1 & 0 & 0 & 1 \\ 0 & 0 & 1 & 2
 \\ 0 & -1 & 0 & 3 \\ 0 & 0 & 0 & 1 
\end{pmatrix}

The correct answer is:
\begin{pmatrix} 1 & 0 & 0 & 1 \\ 0 & 0 & -1 & -3 \\ 0 & 1 & 0 & 2 \\ 0 & 0 & 0 & 1 \end{pmatrix}

2023a06

What is the minimum number of vertices required to draw 20 connected quadrilaterals (like a row of a chessboard) using GL_QUAD_STRIP?
Select one:
a. 80
b. 60
c. 22
d. 42
e. 40

The correct answer is: 42

2023a07

A light source with magenta light illuminates a cyan coloured object. What is the perceived colour of the object?
Select one:
a. Green
b. Blue
c. White
d. Red
e. Black

The correct answer is: Blue

2023a08

Which of the following statements is false?
Select one:
a. The interaction of light with a material can be described using a spectral response function.
b. Materials can absorb, reflect, and/or transmit light.
c. The saturation (or purity) of a colour describes the percentage of luminance residing in the dominant component of the spectrum.
d. Different spectral density functions are perceived as different colours.
e. The spectral density function shows the strength of the variations(energy) as a function of frequency.

The correct answer is: Different spectral density functions are perceived as different colours.

2023a09

Given is a triangle with the RGB vertex colours (0.8, 0.6, 0.2) at vertex A, (0.1, 0.1, 0.1) at vertex B, and (0.2, 0.0, 0.6) at vertex C. What us the RGB colour of the point half-way between vertex A and B?
Select one:
a. (0.7, 0.5, 0.1)
b. It depends on the orientation of the triangle.
c. (0.45, 0.35, 0.15)
d. (0.5, 0.3, 0.4)
e. (0.9, 0.7, 0.3)

The correct answer is: (0.45, 0.35, 0.15)

2023a10

Which of the following statements about colour spaces is false?
Select one:
a. The colour gamut describes the range of colours that can be reproduced on an output device.
b. If we represent two pure spectral colours (i.e., rainbow colours) in HSV coordinates, then linearly interpolating these colours gives also a pure spectral colour (rainbow colour).
c. If we represent two pure spectral colours (i.e., rainbow colours) in RGB coordinates, then linearly interpolating these colours gives also a pure spectral colour (rainbow colour).
d. The HSV colour space is more convenient and intuitive than the RGB colour space for colour design.
e. The RGB colour space mirrors the way colours are represented in display devices, i.e., as combination of red, green and blue light.

The correct answer is: If we represent two pure spectral colours (i.e., rainbow colours) in RGB coordinates, then linearly interpolating these colours gives also a pure spectral colour (rainbow colour).

2023a11

The CIE XYZ colour space may be represented as a projection on the 2D plane: x + y + Z = 1.
Given the color (2, 4, 2), what is the corresponding 2D colour in the CIE chromaticity diagram?
Select one:
a. (0.25, 0.5)
b. (0.5, 1.0)
c. (2, 4)
d. (1, 2)
e. (0.2, 0.4)

The correct answer is: (0.25, 0.5)

2023a12

Which of the following statements about shadows is false?
Select one:
a. Shadow maps are calculated by rendering a scene from the light's perspective.
b. The shadow of a cube is always a square or rectangle regardless of the orientation of the cube and position of the light source.
c. Without shadows it is difficult to perceive the position of an object with respect to a ground plane.
d. The projected shadow of a 3D object cast on a ground plane can be computed by multiplying all vertices of the object with a matrix.
e. Shadow maps can be used to compute shadows for any surface.

The correct answer is: The shadow of a cube is always a square or rectangle regardless of the orientation of the cube and position of the light source.

2023a13

Given is a uvn-coordinate system with the origin 
O_{uvn} = \begin{pmatrix} 1 \\ 2  \\ -1 \end{pmatrix}
and the coordinate axis 
{\bf u} = \begin{pmatrix} 0 \\ -1  \\ 0 \end{pmatrix}\text{ ,  } {\bf v} = \begin{pmatrix} 1 \\ 0  \\ 0 \end{pmatrix}\text{  and } {\bf n} = \begin{pmatrix} 0 \\ 0  \\ 1 \end{pmatrix}
Given is a point P with the uvn-coordinates 
{\bf p}_{uvn} = \begin{pmatrix} 2 \\ 1  \\ 3 \end{pmatrix}
.
What are the xyz-coordinates (world coordinates) of this point?
Select one:
a. \begin{pmatrix} 1 \\ 1  \\ 4 \end{pmatrix}
b. \begin{pmatrix} 1 \\ -1  \\ 4 \end{pmatrix}
c. \begin{pmatrix} 3 \\ 3  \\ 2 \end{pmatrix}
d. \begin{pmatrix} 2 \\ 0  \\ 2 \end{pmatrix}
e. \begin{pmatrix} 3 \\ -3  \\ 2 \end{pmatrix}

The correct answer is:
\begin{pmatrix} 2 \\ 0  \\ 2 \end{pmatrix}

2023a14

Given is a scene containing an illuminated object. The scene contains a single light source with ambient intensity Ia=0.2 and diffuse intensity Id=0.5. The illuminated object has the ambient reflection coefficient ρa=0.5 and ρd=0.9. Given is a point p=(0,0,0)T on the surface of the object. The surface normal at p is (0,0,1)T, the light position is (2,1,2)T, and the viewpoint is  (3,0,0)T.
Using the (achromatic) Phong Illumination equation discussed in the lecture and assignment, what is the diffuse component of the reflected light at p?
NOTE 1: Please assume that there is no distance dependency, i.e. kc=1.0 and kl=kq=0.0.
NOTE 2: In order to work out your answer you may not need all of the parameters specified above.
Select one:
a. 0.4
b. 0.35
c. 1/3
d. 0.45
e. 0.3

The correct answer is: 0.3

2023a15

Write a function areaTriangle(), that takes as parameters three 3D vectors representing points, and returns a floating point value representing the area of the triangle. Your function should have the following signature:
double areaTriangle(Vector3 p0, Vector3 p1, Vector3 p2)
You can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z, and that the following functions are available to you:
double dot(Vector3 u, Vector3 v) //dot product
Vector3 cross(Vector3 u, Vector3 v) //cross product
You can assume that the Vector3 class has the following member functions available to you:
Vector3 Vector3.normalized() //returns a vector pointing in the same direction with length 1
double Vector3.magnitude() //returns the length of the vector
You can assume that the Vector3 class supports the following operators returning objects of type Vector3:
Vector3 + Vector3
Vector3 - Vector3
For example:
Test1
Vector3 p0 = Vector3(0.0, 0.0, 0.0);
Vector3 p1 = Vector3(3.0, 0.0, 0.0);
Vector3 p2 = Vector3(0.0, 2.0, 0.0);
printf("area = %.2lf", areaTriangle(p0,p1,p2));
Result1
area = 3.00
Test2
Vector3 p0 = Vector3(0.0, 0.0, 0.0);
Vector3 p1 = Vector3(3.0, 0.0, 0.0);
Vector3 p2 = Vector3(1.5, 5.0, 0.0);
printf("area = %.2lf", areaTriangle(p0,p1,p2));
Result2
area = 7.50
Test3
Vector3 p0 = Vector3(1.0, 0.0, 2.0);
Vector3 p1 = Vector3(2.0, 1.0, 3.5);
Vector3 p2 = Vector3(3.0, 2.0, 5.0);
printf("area = %.2lf", areaTriangle(p0,p1,p2));
Result3
area = 0.00

NULL

2023a16

Write a function MixHSV(), that takes as a parameter two HSV colours with each component in the range [0...1], and returns the HSV colour which is the average of the two input colours. Your function should have the following signature:
HSVColour MixHSV(HSVColour c1, HSVColour c2)
You can assume that HSVColour is a class that represents a colour in the 3D HSV space and exposes fields named H, S, and V.
For example:
Test1
HSVColour mixedColour = MixHSV(HSVColour(0.6, 1.0, 1.0), HSVColour(0.8, 1.0, 1.0));
printf("Mixed HSV colour = (%.2lf, %.2lf, %.2lf)", mixedColour.H, mixedColour.S, mixedColour.V); 
Result1
Mixed HSV colour = (0.70, 1.00, 1.00)
Test2
HSVColour mixedColour = MixHSV(HSVColour(0.0, 0.0, 0.0), HSVColour(1.0, 1.0, 1.0));
printf("Mixed HSV colour = (%.2lf, %.2lf, %.2lf)", mixedColour.H, mixedColour.S, mixedColour.V); 
Result2
Mixed HSV colour = (0.50, 0.50, 0.50)

NULL

2023a17a

Given are the vertices
const int numVertices=9;
const float vertices[numVertices][2] = { {100,50},{300,50},{150,150},{250,150},{50,200},{150,200},{250,200},{350,200},{200,300} };
Which calling sequence of these vertices results in the shape below if we use the OpenGL commands glBegin(GL_TRIANGLE_FAN) and glEnd()?
Image description: The image shows a star shape with the bottom two vertices connected by a line. The vertices are labelled according to the vertices array above.
Write OpenGL code for drawing the shape. You can assume that the following function is defined:
void v(int i) {glVertex2fv(vertices[i]);}
Your code should have the following form:
glBegin(GL_TRIANGLE_FAN);
v(<start_index>); // draw first vertex
// draw as many additional vertices as necessary using the above format
glEnd();
IMPORTANT:
1) Use as first vertex the vertex with the smallest possible index resulting in the correct shape. The vertices must be defined in clockwise order.
If you get the correct image but an error in the test case then this might indicate that you used anticlockwise order, or that your first vertex index is not correct, or that you have drawn more vertices than necessary.

NULL

2023a17b

Given are the vertices
const int numVertices=9;
const float vertices[numVertices][2] = { {100,50},{300,50},{150,150},{250,150},{50,200},{150,200},{250,200},{350,200},{200,300} };
Which calling sequence of these vertices results in the shape below if we use the OpenGL commands glBegin(GL_TRIANGLE_FAN) and glEnd()?
Image description: The image shows a star shape with the bottom two vertices connected by a line. The vertices are labelled according to the vertices array above. Lines connecting the 2nd vertex to every other vertex are all inside the shape.
Write OpenGL code for drawing the shape. You can assume that the following function is defined:
void v(int i) {glVertex2fv(vertices[i]);}
Your code should have the following form:
glBegin(GL_TRIANGLE_FAN);
v(<start_index>); // draw first vertex
// draw as many additional vertices as necessary using the above format
glEnd();
IMPORTANT:
1) Use as first vertex the vertex with the smallest possible index resulting in the correct shape. The vertices must be defined in clockwise order.
If you get the correct image but an error in the test case then this might indicate that you used anticlockwise order, or that your first vertex index is not correct, or that you have drawn more vertices than necessary.

NULL

2023a18a

Given are the vertices
const int numVertices=8;
const float vertices[numVertices][2] = {{50,50},{100,50},{200,50},{250,50},{50,300},{100,300},{200,300},{250,300} };
Which calling sequence of these vertices results in the shape below if we use the OpenGL commands glBegin(GL_TRIANGLE_STRIP) and glEnd()?
Image description: The image shows an N-shaped triangle strip. The vertices are labelled according to the vertices array above.
Write OpenGL code for drawing the shape. You can assume that the following function is defined:
void v(int i) {glVertex2fv(vertices[i]);}
Your code should have the following form:
glBegin(GL_TRIANGLE_STRIP);
v(<start_index>); // draw first vertex
// draw as many additional vertices as necessary using the above format
glEnd();
IMPORTANT:
1) Use as first vertex the vertex with the smallest possible index resulting in the correct shape.  Do not repeat any vertices. Note that some triangles are allowed to slightly overlap.
If you get the correct image but an error in the test case then this might indicate that your first vertex index is not correct, or that you have drawn more vertices than necessary.

NULL

2023a18b

Given are the vertices
const int numVertices=8;
const float vertices[numVertices][2] = {{50,50},{100,50},{200,50},{250,50},{50,300},{100,300},{200,300},{250,300} };
Which calling sequence of these vertices results in the shape below if we use the OpenGL commands glBegin(GL_TRIANGLE_STRIP) and glEnd()?
Image description: The image shows an N-shaped triangle strip. The vertices are labelled according to the vertices array above. The vertices 0, 1, 4, 5 form a rectangle, the vertices 4, 5, 2, 3 form a parallelogram, and the vertices 2, 3, 6, 7 form a rectangle.
Write OpenGL code for drawing the shape. You can assume that the following function is defined:
void v(int i) {glVertex2fv(vertices[i]);}
Your code should have the following form:
glBegin(GL_TRIANGLE_STRIP);
v(<start_index>); // draw first vertex
// draw as many additional vertices as necessary using the above format
glEnd();
IMPORTANT:
1) Use as first vertex the vertex with the smallest possible index resulting in the correct shape.  Do not repeat any vertices. Note that some triangles are allowed to slightly overlap.
If you get the correct image but an error in the test case then this might indicate that your first vertex index is not correct, or that you have drawn more vertices than necessary.

NULL

2023a19

Write a function RGB2SV(), that takes as a parameter an RGB colour with each component in the range [0...1], and returns a vector where the x-coordinate is the saturation of the RGB colour and the y-coordinate is the value (intensity) of the RGB colour.
The function should have the following format:
Vector2 RGB2SV(RGBColour c)
You can assume that RGBColour is a class that represents a colour in the 3D RGB space and exposes fields named R, G, and B.
You can assume that Vector2 is a class that represents a 2D vector, and exposes fields named x and y.
HINT:
Given an RGB colour (R, G, B) the saturation S and value V are computed as follows:
V=max(R, G, B)
delta=max(R, G, B) - min(R, G, B)
S=delta/V if V>0 and otherwise S=0
NOTE: You can compute the maximum and minimum of two floating point values using the functions max(x,y) and min(x,y)
For example:
Test1
RGBColour c = RGBColour(0.0, 0.0, 0.0);
Vector2 saturationAndValue = RGB2SV(c);
printf("Saturation = %.2lf, Value = %.2lf", saturationAndValue.x, saturationAndValue.y);
Result1
Saturation = 0.00, Value = 0.00
Test2
RGBColour c = RGBColour(1.0, 1.0, 1.0);
Vector2 saturationAndValue = RGB2SV(c);
printf("Saturation = %.2lf, Value = %.2lf", saturationAndValue.x, saturationAndValue.y);
Result2
Saturation = 0.00, Value = 1.00
Test3
RGBColour c = RGBColour(1.0, 0.3, 0.3);
Vector2 saturationAndValue = RGB2SV(c);
printf("Saturation = %.2lf, Value = %.2lf", saturationAndValue.x, saturationAndValue.y);
Result3
Saturation = 0.70, Value = 1.00
Test4
RGBColour c = RGBColour(0.5, 0.3, 0.3);
Vector2 saturationAndValue = RGB2SV(c);
printf("Saturation = %.2lf, Value = %.2lf", saturationAndValue.x, saturationAndValue.y);
Result4
Saturation = 0.40, Value = 0.50

NULL

2023a20

Write a function areaTriangleFan(), that takes as parameters the number of points of the triangle fan, an array with the points defining the triangle fan, and returns a floating point value representing the area of the triangle fan. Your function should have the following signature:
double areaTriangleFan(int numVertices, Vector3 *vertices)
You can assume that the triangle fan is defined the same as the corresponding OpenGL primitive, i.e., the first vertex forms triangles with each pair of consecutive vertices. You can also assume that the input is a valid triangle fan and that it has at least 3 vertices.
HINT:
Think about how OpenGL divides a triangle fan into triangles.
You can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z, and that the following functions are available to you:
double dot(Vector3 u, Vector3 v) //dot product
Vector3 cross(Vector3 u, Vector3 v) //cross product
You can assume that the Vector3 class has the following member functions available to you:
Vector3 Vector3.normalized() //returns a vector pointing in the same direction with length 1
double Vector3.magnitude() //returns the length of the vector
You can assume that the Vector3 class supports the following operators returning an object of type Vector3:
Vector3 + Vector3
Vector3 - Vector3
For example:
Test1
int numVertices = 3;
Vector3 vertices[numVertices]={Vector3(0.0, 0.0, 0.0),Vector3(3.0, 0.0, 0.0),Vector3(0.0, 2.0, 0.0)};
printf("area = %.2lf", areaTriangleFan(numVertices, vertices));
Result1
area = 3.00
Test2
int numVertices = 4;
Vector3 vertices[numVertices]={Vector3(2.0, 2.0, 0.0),Vector3(0.0, 0.0, 0.0),Vector3(4.0, 2.0, 0.0),Vector3(0.0, 5.0, 0.0)};
printf("area = %.2lf", areaTriangleFan(numVertices, vertices));
Result2
area = 5.00

NULL

2023a21a

Phong Shading interpolates the surface normal of a polygon and computes the perceived colour of each pixel using the Phong Illumination model. In OpenGL this is usually implemented using so-called fragment shaders.
In order to apply Phong shading to a triangle we need to interpolate the normals at the vertices of the triangle. In this exercise you will implement a function barycentricInterpolation, which interpolates the normals of a triangle for a given point p on the triangle. The signature of the function is:
CVec3df barycentricInterpolation(CVec3df p, CVec3df p0, CVec3df p1, CVec3df p2, CVec3df n0, CVec3df n1, CVec3df n2)
The point p is a point on the triangle. The vertices of the triangle are p0, p1, and p2, and the corresponding normals are n0, n1, and n2. The function returns the interpolated normal at the point p. The interpolation must be performed using barycentric interpolation as discussed in the lecture.
After completing this function you should get the following output:
Image description: The image shows a grey triangle with some white spots on a yellow background.
NOTE 1:
You can use the function
double areaTriangle(CVec3df p0, CVec3df p1, CVec3df p2)
which returns the area of the triangle defined by three points p0, p1 and p2.
NOTE 2:
The class CVec3df implements a 3D vector as a 3D array. The class defines operations for adding two vectors and scaling vectors, e.g.:
CVec3df a,b,c;
c=a+b;
c=5.0*a;
double xCoor=a[0];    // x-coordinate
double yCoor=a[1];    // y-coordinate
double zCoor=a[2];    // z-coordinate

NULL

2023a21b

Phong Shading interpolates the surface normal of a polygon and computes the perceived colour of each pixel using the Phong Illumination model. In OpenGL this is usually implemented using so-called fragment shaders.
In order to apply Phong shading to a triangle we need to interpolate the normals at the vertices of the triangle. In this exercise you will implement a function barycentricInterpolation, which interpolates the normals of a triangle for a given point p on the triangle. The signature of the function is:
CVec3df barycentricInterpolation(CVec3df p, CVec3df p0, CVec3df p1, CVec3df p2, CVec3df n0, CVec3df n1, CVec3df n2)
The point p is a point on the triangle. The vertices of the triangle are p0, p1, and p2, and the corresponding normals are n0, n1, and n2. The function returns the interpolated normal at the point p. The interpolation must be performed using barycentric interpolation as discussed in the lecture.
After completing this function you should get the following output:
Image description: The image shows a moderately bright triangle with some brighter spots on a plain, yellow background.
NOTE 1:
You can use the function
double areaTriangle(CVec3df p0, CVec3df p1, CVec3df p2)
which returns the area of the triangle defined by three points p0, p1 and p2.
NOTE 2:
The class CVec3df implements a 3D vector as a 3D array. The class defines operations for adding two vectors and scaling vectors, e.g.:
CVec3df a,b,c;
c=a+b;
c=5.0*a;
double xCoor=a[0];    // x-coordinate
double yCoor=a[1];    // y-coordinate
double zCoor=a[2];    // z-coordinate

NULL

2023a22a

Given is a triangle with the vertices:
const int numVertices=3;
const float vertices[numVertices][2] = {{-50,0},{50,0},{0,120}};
The triangles has a width of 100 and a height of 120 and is oriented along the y-axis.
Use this triangle to draw a sun / flower shape as shown in the images below. The given program draws a red circle with centre (250, 250) and radius 100. Please draw n triangles around this red circle in anti-clockwise direction starting with the triangle at the top. To place the triangles around the red circle they are transformed as follows:
1) The triangle given above is translated by 100 in y-direction
2) The i-th triangle is rotated by i/n*360 degree around the origin. For example, if n=4 then the first triangle is rotated by 0 degree, the second by 90 degree, the third by 180 degree, and the fourth by 270 degree.
3) Translate the rotated triangle by 250 in x- and y-direction
IMPORTANT:
1) The number n of triangles is  given by the variable numTriangles. Please do not change it.
2) Please draw the n triangles in anti-clockwise order starting with the triangle at the top (0 degree rotation). Each triangle is drawn using GL_TRIANGLES and the vertex order 0, 1, 2
3) You are not allowed to use OpenGL transformations, i.e., you need to compute the transformed vertices before you draw them. You can use the functions cos(x) and sin(x).  Note that these functions use an argument in radian. In order to use an angle in degree you can write: cos(2*PI*angleInDegree/360.0f)
Note that the constant PI is already predefined.
4) Note that if two arguments are integers C/C++ uses integer division, e.g. 7/3=2. In order to get floating point division one of the arguments must be a floating point number, e.g., 7.0f/3 or ((float) 7)/3
5) Please draw the transformed vertices using the function
myVertex2D(float x, float y)
which calls the corresponding glVertex command and outputs information for the automarker.
The image below shows the expected output for n=4, n=8, and n=20.
Image description: The image shows three red circles, each with four, eight, and twenty yellow triangles around it. The triangles are oriented in a flower pattern.

NULL

2023a22b

Given is a triangle with the vertices:
const int numVertices=3;
const float vertices[numVertices][2] = {{-50,0},{50,0},{0,120}};
The triangles has a width of 100 and a height of 120 and is oriented along the y-axis.
Use this triangle to draw a sun / flower shape as shown in the images below. The given program draws a red circle with centre (250, 250) and radius 100. Please draw n triangles around this red circle in anti-clockwise direction starting with the triangle at the top. To place the triangles around the red circle they are transformed as follows:
1) The triangle given above is translated by 100 in y-direction
2) The i-th triangle is rotated by i/n*360 degree around the origin. For example, if n=4 then the first triangle is rotated by 0 degree, the second by 90 degree, the third by 180 degree, and the fourth by 270 degree.
3) Translate the rotated triangle by 250 in x- and y-direction
IMPORTANT:
1) The number n of triangles is  given by the variable numTriangles. Please do not change it.
2) Please draw the n triangles in anti-clockwise order starting with the triangle at the top (0 degree rotation). Each triangle is drawn using GL_TRIANGLES and the vertex order 0, 1, 2
3) You are not allowed to use OpenGL transformations, i.e., you need to compute the transformed vertices before you draw them. You can use the functions cos(x) and sin(x).  Note that these functions use an argument in radian. In order to use an angle in degree you can write: cos(2*PI*angleInDegree/360.0f)
Note that the constant PI is already predefined.
4) Note that if two arguments are integers C/C++ uses integer division, e.g. 7/3=2. In order to get floating point division one of the arguments must be a floating point number, e.g., 7.0f/3 or ((float) 7)/3
5) Please draw the transformed vertices using the function
myVertex2D(float x, float y)
which calls the corresponding glVertex command and outputs information for the automarker.
The image below shows the expected output for n=4, n=8, and n=20.
Image description: The left part of the image shows a red circle, around this circle there are 4 triangles. The first triangle is at the top and is rotated by 0 degrees. The second triangle is rotated by 90 degrees, the third by 180 degrees, and the fourth by 270 degrees. The triangles are oriented such that they form a flower shape. The center part of the image shows a red circle, around this circle there are 8 triangles. The first triangle is at the top and is rotated by 0 degrees. The second triangle is rotated by 45 degrees, the third by 90 degrees, the fourth by 135 degreess, the fifth by 180 degrees, the sixth by 225 degrees, the seventh by 270 degrees, and the eighth by 315 degrees. The triangles are oriented such that they form a flower shape. The right part shows the same as the center part but with 20 triangles.

NULL

