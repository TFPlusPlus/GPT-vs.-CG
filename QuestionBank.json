[
    {
        "id": "2022a01",
        "question": "Given a triangle comprised of the following vertex array:\nvertices = {(0.0, 0.0, 0.0), (2.0, 3.0, 0.0), (-3.0, 3.0, -1.0)}\nIf the triangle is drawn using the indices {0, 1, 2}, and anticlockwise winding order represents front faces, which of the following represents the surface normal of the front face of the triangle?\na. $$\\frac{1}{\\sqrt{238}}\\begin{pmatrix} 3 \\\\ -2 \\\\-15 \\end{pmatrix}$$\nb. $$\\frac{1}{\\sqrt{238}}\\begin{pmatrix} 3 \\\\ -15 \\\\-2 \\end{pmatrix}$$\nc. $$\\frac{1}{\\sqrt{238}}\\begin{pmatrix} -3 \\\\ 2 \\\\15 \\end{pmatrix}$$\nd. None of the others.\ne. $$\\frac{1}{\\sqrt{238}}\\begin{pmatrix} -3 \\\\ 15 \\\\2 \\end{pmatrix}$$",
        "answer": "The correct answer is:\n$$\\frac{1}{\\sqrt{238}}\\begin{pmatrix} -3 \\\\ 2 \\\\15 \\end{pmatrix}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a02",
        "question": "The orthogonal projection of vector\n$$\\textbf{u} = \\begin{pmatrix}0\\\\2\\\\3 \\end{pmatrix}$$\nonto vector\n$$\\textbf{v} = \\begin{pmatrix} 1 \\\\3\\\\0 \\end{pmatrix}$$\nis equal to:\nSelect one:\na. $$\\frac{6}{10}\\begin{pmatrix}0 \\\\2 \\\\3 \\end{pmatrix}$$\nb. $$\\frac{6}{10}\\begin{pmatrix}1 \\\\3 \\\\0 \\end{pmatrix}$$\nc. None of the others\nd. $$\\frac{6}{\\sqrt{10}} \\begin{pmatrix}0\\\\2 \\\\3 \\end{pmatrix}$$\ne. $$\\frac{6}{\\sqrt{10}}$$",
        "answer": "The correct answer is:\n$$\\frac{6}{10}\\begin{pmatrix}1 \\\\3 \\\\0 \\end{pmatrix}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a03",
        "question": "Given a plane\nP\ndefined by the equation:\n2x+2y+z=2\n, and a point\n$$Q = \\begin{pmatrix} 1 \\\\1 \\\\-2 \\end{pmatrix}$$\n,\nWhat is the smallest absolute distance between\nP\nand\nQ\n?\nSelect one:\na. None of the others\nb. 1\nc. 13\nd. 2\ne. 0\n, Q is on the plane, P.",
        "answer": "The correct answer is:\n0\n, Q is on the plane, P.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a04",
        "question": "Consider a matrix of 3D geometric transformations in homogeneous coordinates. Which of the following statements about the matrix\n$$M = \\begin{bmatrix}-1 & 0 & 0 & -4 \\\\ 0 & -1 & 0 & -1 \\\\ 0 & 0 & 1 & -4 \\\\ 0 & 0 & 0 & 1\\end{bmatrix}$$\nis true?\nSelect one:\na. M represents a shear parallel to the z axis with magnitude 4 followed by a scaling along the x axis and y axis by -1.\nb. M represents a rotation about the z axis by -180 degrees followed by a translation by\n$$M = \\begin{bmatrix}-1 & 0 & 0 & -4 \\\\ 0 & -1 & 0 & -1 \\\\ 0 & 0 & 1 & -4 \\\\ 0 & 0 & 0 & 1\\end{bmatrix}$$\n.\nc. M represents a scaling along the x axis and y axis by -1 followed by a shear parallel to the z axis with magnitude 4.\nd. None of the others\ne. M represents a translation by\n$$\\begin{pmatrix}4 \\\\ 1 \\\\ -4\\end{pmatrix}$$\nfollowed by a rotation about the z axis by -180 degrees.",
        "answer": "The correct answer is: M represents a translation by\n$$\\begin{pmatrix}4 \\\\ 1 \\\\ -4\\end{pmatrix}$$\nfollowed by a rotation about the z axis by -180 degrees.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a05a",
        "question": "Given are the vertices (labelled in the image)\nconst int numVertices=8;\nconst float vertices[numVertices][2] = {{100,100},{400,100},{100,200},{400,200},{100,300},{400,300},{100,400},{400,400}};\nWhich of the following represents a possible indices array that will generate the image shown below if we use the OpenGL commands glBegin(GL_TRIANGLES) and glEnd()?\nImage description: An hourglass shape is shown with the vertices labelled with its index in the array.\na. None of the others.\nb. {0, 1, 2, 0, 3, 2, 0, 5, 2, 0, 7, 2, 1, 4, 3, 1, 6, 3, 4, 5, 7, 4, 7, 6}\nc. {0, 1, 2, 3, 4, 5, 6, 7}\nd. {4, 5, 7, 4, 7, 6, 0, 1, 3, 0, 3, 2, 0, 5, 7, 0, 7, 2, 4, 1, 3, 4, 3, 6}\ne. {0, 1, 3, 0, 3, 2, 1, 3, 4, 4, 3, 6, 4, 6, 7, 4, 7, 5, 7, 2, 5, 7, 0, 5}",
        "answer": "The correct answer is:\n{4, 5, 7, 4, 7, 6, 0, 1, 3, 0, 3, 2, 0, 5, 7, 0, 7, 2, 4, 1, 3, 4, 3, 6}",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a05b",
        "question": "Given are the vertices (labelled in the image)\nconst int numVertices=8;\nconst float vertices[numVertices][2] = {{100,100},{400,100},{100,200},{400,200},{100,300},{400,300},{100,400},{400,400}};\nWhich of the following represents a possible indices array that will generate the image shown below if we use the OpenGL commands glBegin(GL_TRIANGLES) and glEnd()?\nImage description: The shape is formed with multiple shapes listed here. The first shape is a rectangle with the vertices 4, 5, 6, 7; the second shape is a rectangle with the vertices 0, 1, 2, 3; the third shape is a parallelogram with the vertices 0, 2, 5, 7; the fourth shape is a parallelogram with the vertices 1, 3, 4, 6.\na. None of the others.\nb. {0, 1, 2, 0, 3, 2, 0, 5, 2, 0, 7, 2, 1, 4, 3, 1, 6, 3, 4, 5, 7, 4, 7, 6}\nc. {0, 1, 2, 3, 4, 5, 6, 7}\nd. {4, 5, 7, 4, 7, 6, 0, 1, 3, 0, 3, 2, 0, 5, 7, 0, 7, 2, 4, 1, 3, 4, 3, 6}\ne. {0, 1, 3, 0, 3, 2, 1, 3, 4, 4, 3, 6, 4, 6, 7, 4, 7, 5, 7, 2, 5, 7, 0, 5}",
        "answer": "The correct answer is:\n{4, 5, 7, 4, 7, 6, 0, 1, 3, 0, 3, 2, 0, 5, 7, 0, 7, 2, 4, 1, 3, 4, 3, 6}",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a06",
        "question": "Which of the following statements about drawing meshes is true?\na. By using a mesh data structure, multiple instances of a mesh may be drawn using the same mesh data and different transformations.\nb. Meshes can only be used when drawing with triangle primitives.\nc. By using a mesh data structure, multiple instances of a mesh may be drawn without increasing rendering time.\nd. None of the others.\ne. Using an indices array to represent vertex usage will always result in less memory being required to represent a mesh.",
        "answer": "The correct answer is:\nBy using a mesh data structure, multiple instances of a mesh may be drawn using the same mesh data and different transformations.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a07",
        "question": "Consider a surface that reflects the colour magenta when three lights are shining on it: one red, one green, one blue.\nWhat will be the reflected colour if the blue light is removed?\na. Green\nb. Yellow\nc. Black\nd. Magenta\ne. Red",
        "answer": "The correct answer is:\nRed",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a08",
        "question": "The CIE XYZ colour space may be represented as a projection on the 2D plane: x + y + Z = 1.\nGiven the color (3, 9, 3), what is the corresponding 2D colour?\nSelect one:\na. None of the others\nb. (3, 9)\nc. (0.2, 0.6)\nd. (3, 15)\ne. (0.3, 0.9)",
        "answer": "The correct answer is: (0.2, 0.6)",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a09",
        "question": "Which of the following statements is true for a spectral density function (SDF)?\nSelect one:\na. None of the others\nb. All light sources can be defined by their SDF.\nc. The SDF describes the light absorption of a surface.\nd. Only natural light can be defined by the SDF.\ne. Only artificial light sources can be defined by their SDF.",
        "answer": "The correct answer is: All light sources can be defined by their SDF.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a10a",
        "question": "Consider the following image of a sphere:\nImage description: A sphere is shown surrounded by darkness.\nAssuming a scene where the light intensities and reflection coefficients for ambient, diffuse, and specular are non-zero, which types of reflection are enabled for this scene?\na. Ambient, Diffuse, and Specular\nb. Diffuse only\nc. Ambient and Diffuse\nd. Diffuse and Specular\ne. Ambient Only",
        "answer": "The correct answer is:\nDiffuse only",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a10b",
        "question": "Consider the following image of a sphere:\nImage description: A sphere is shown in space. The space surrounding it is black, the sphere itself is shown with a medium level of brightness, and there are no highlights shown on the sphere.\nAssuming a scene where the light intensities and reflection coefficients for ambient, diffuse, and specular are non-zero, which types of reflection are enabled for this scene?\na. Ambient, Diffuse, and Specular\nb. Diffuse only\nc. Ambient and Diffuse\nd. Diffuse and Specular\ne. Ambient Only",
        "answer": "The correct answer is:\nDiffuse only",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a11",
        "question": "Consider a viewport of 800x800 pixels, with a coordinate system that ranges from 0-800 in the x and y axes, where (0, 0) is the bottom left corner of the viewport, and (800, 800) is the top right corner of the viewport.\nIn this viewport are drawn three triangles, where triangle T1 is drawn in red, triangle T2 is drawn in green, and triangle T3 is drawn in blue. The triangles are also being redrawn in wireframe, such that border pixels are drawn in black. The clear-colour for the viewport is white.\nThe triangles are being drawn in the order T1, T2, T3, with projection and depth testing set up such that if two triangles occupy the same pixel, the pixel will always be the colour of the more recently drawn triangle.\nIf the projected vertex locations of the triangles in the viewport are as follows:\nT1: {(0, 0, 0), (0, 800, 0), (800, 800, 0)}\nT2: {(260, 800, 0), (540, 800, 0), (380, 390, 0)}\nT3 {(120, 440, 0), (420, 440, 0), (410, 380, 0)}\nWhat colour will the pixel located at the viewport coordinates (410, 410) be?\na. Blue\nb. White\nc. Black\nd. Red\ne. Green",
        "answer": "The correct answer is:\nBlue",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a12",
        "question": "Which of the following statements about the Phong illumination model is false?\nSelect one:\na. Ambient reflection is constant over the entire surface.\nb. Diffuse reflection does not vary with the angle between surface normal and view vector.\nc. Diffuse reflection models rough surfaces such as clay and cardboard.\nd. Diffuse reflection does not vary with the angle between surface normal and light direction.\ne. Ambient reflection does NOT depend on the surface normal.",
        "answer": "The correct answer is: Diffuse reflection does not vary with the angle between surface normal and light direction.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a13",
        "question": "Write a function colinear(), that takes as parameters three 3D vectors representing points, and returns a boolean: true if all three points lie on the same line, false otherwise. Your function should have the following signature:\nbool colinear(Vector3 p, Vector3 q, Vector3 r)\nYou can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z, and that the following functions are available to you:\ndouble dot(Vector3 u, Vector3 v) //dot product\nVector3 cross(Vector3 u, Vector3 v) //cross product\nYou can assume that the Vector3 class has the following member functions available to you:\nVector3 Vector3.normalized() //returns a vector pointing in the same direction with length 1\ndouble Vector3.magnitude() //returns the length of the vector\nYou can assume that the Vector3 class supports the following operators:\nVector3 + Vector3\nVector3 - Vector3",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a14",
        "question": "Write a function surfaceNormal(), which takes as parameters an array of 3D vectors representing the vertices of an arbitrarily shaped polygon, and an integer representing the number of vertices that make up the polygon. Your function should compute and return a unit vector that best represents the surface normal of the polygon.\nYou should assume that vertices are given in anticlockwise order, and that front faces are determined using anticlockwise winding order.\nYou should not assume that the polygon is well formed. Vertices may be co-linear, and they are not necessarily co-planar.\nYour function should have the following signature:\nVector3 surfaceNormal(Vector3 vertices[], int numVertices)\nYou can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z, and that the following functions are available to you:\ndouble dot(Vector3 u, Vector3 v) //dot product\nVector3 cross(Vector3 u, Vector3 v) //cross product\nYou can assume that the Vector3 class has the following member functions available to you:\nVector3 Vector3::normalized() //returns a vector pointing in the same direction with length 1\ndouble Vector3::magnitude() //returns the length of the vector\nYou can assume that the Vector3 class supports the following operators:\nVector3 + Vector3\nVector3 - Vector3\nVector3 * double",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a15a",
        "question": "Write a function drawGrid(), that generates the image below:\nImage description: An arbitrary sheet floating in space.\nYour function should have the following signature:\nvoid drawGrid(double width, double height)\nThe grid consists of rows/columns of squares that span the x-z plane, with each square being made up of two triangles. The width parameter gives the number of of squares the grid contains on the x-axis, and the height parameter gives the number of squares the grid contains on the z-axis.\nEach square is exactly one unit wide on both the x and z axes.\nThe y axis value of each vertex is derived from its location on the x and z axes. The y-axis value is equal to the cosine (in radians) of the x-axis value + the cosine (in radians) of the z-axis value.\nYou must use GL_TRIANGLES to draw the mesh. You do not need to specify vertex colours.\nThe vertices must be given in anticlockwise order for the triangles as seen from above. In each pair of triangles, the triangle closer to the origin must be drawn starting from the closest vertex to the origin (minimum x and z), and the triangle farther away from the origin must be drawn starting from the farthest vertex from the origin (maximum x and z).\nThe grid should fill in each column (each group of height tiles that share x-axis values) before proceeding to the next column.\nThe image above shows the grid drawn in wireframe. You do not need to specify that drawing will be done in wireframe.\nYou can assume that if required, you have access to a Vector3 class that represents a 3D vector, and exposes fields named x, y, and z.\nYou can assume that you have access to standard trigonometric functions such as cos(), and that they assume input parameters are in radians by default.\nImportant note:\nCoderunner requires certain OpenGL functions to use special versions:\nInstead of glVertex3d(), use CRVertex3d()",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a15b",
        "question": "Write a function drawGrid(), that generates the image below:\nImage description: An arbitrary sheet floating in space. The sheet is made up of a grid of squares, with each square being made up of two triangles. The sheet is shown in wireframe.\nYour function should have the following signature:\nvoid drawGrid(double width, double height)\nThe grid consists of rows/columns of squares that span the x-z plane, with each square being made up of two triangles. The width parameter gives the number of of squares the grid contains on the x-axis, and the height parameter gives the number of squares the grid contains on the z-axis.\nEach square is exactly one unit wide on both the x and z axes.\nThe y axis value of each vertex is derived from its location on the x and z axes. The y-axis value is equal to the cosine (in radians) of the x-axis value + the cosine (in radians) of the z-axis value.\nYou must use GL_TRIANGLES to draw the mesh. You do not need to specify vertex colours.\nThe vertices must be given in anticlockwise order for the triangles as seen from above. In each pair of triangles, the triangle closer to the origin must be drawn starting from the closest vertex to the origin (minimum x and z), and the triangle farther away from the origin must be drawn starting from the farthest vertex from the origin (maximum x and z).\nThe grid should fill in each column (each group of height tiles that share x-axis values) before proceeding to the next column.\nThe image above shows the grid drawn in wireframe. You do not need to specify that drawing will be done in wireframe.\nYou can assume that if required, you have access to a Vector3 class that represents a 3D vector, and exposes fields named x, y, and z.\nYou can assume that you have access to standard trigonometric functions such as cos(), and that they assume input parameters are in radians by default.\nImportant note:\nCoderunner requires certain OpenGL functions to use special versions:\nInstead of glVertex3d(), use CRVertex3d()",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a16a",
        "question": "Write a function projectVertex(), that computes the projection of a vertex on to a plane for the purpose of creating a shadow.\nThe plane is given in the form ax + by + cz + d = 0\nYour function should have the following signature:\nVector3 projectVertex(Vector3 vertex, double a, double b, double c, double d)\nThe function should return the location of a vertex given by the vertex parameter when projected from the origin on to a plane given by the a, b, c,  & d parameters.\nIf working correctly, the program will produce the following output:\nImage description: A ruby shape on top of a dark triangle on top of a grey square.\nYou can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z.\nYour code can assume that this is a straightforward case for generating shadows: the light source (the origin of the projection) is located at (0, 0, 0), and you do not need to account for any transformations on the object.\nYou do not need to handle the actual display of the object or the shadow, only the calculation of the shadow vertex location.",
        "answer": "Vector3 projectVertex(Vector3 vertex, double a, double b, double c, double d) {\ndouble t = -d / (a * vertex.x + b * vertex.y + c * vertex.z);\nreturn Vector3(t * vertex.x, t * vertex.y, t * vertex.z);\n}",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a16b",
        "question": "Write a function projectVertex(), that computes the projection of a vertex on to a plane for the purpose of creating a shadow.\nThe plane is given in the form ax + by + cz + d = 0\nYour function should have the following signature:\nVector3 projectVertex(Vector3 vertex, double a, double b, double c, double d)\nThe function should return the location of a vertex given by the vertex parameter when projected from the origin on to a plane given by the a, b, c,  & d parameters.\nIf working correctly, the program will produce the following output:\nImage description: A red object resembling the shape of a ruby is shown floating in space, with a grey square representing the plane, a triangular shadow of the object is shown on the plane as black.\nYou can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z.\nYour code can assume that this is a straightforward case for generating shadows: the light source (the origin of the projection) is located at (0, 0, 0), and you do not need to account for any transformations on the object.\nYou do not need to handle the actual display of the object or the shadow, only the calculation of the shadow vertex location.",
        "answer": "Vector3 projectVertex(Vector3 vertex, double a, double b, double c, double d) {\ndouble t = -d / (a * vertex.x + b * vertex.y + c * vertex.z);\nreturn Vector3(t * vertex.x, t * vertex.y, t * vertex.z);\n}",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a17a",
        "question": "Write a function phongDirectionalSource() which implements the achromatic version of the Phong Illumination equation for a directional light source.\nIf the function is implemented correctly you should get the following result (Note: this image is rendered using only your implementation and does not use OpenGL lights or materials)\nImage description: A white circle on top of a grey circle on top of a yellow background.\nYour function should have the following signature:\ndouble phongDirectionalSource(double ambientIntensity, double diffuseIntensity, double specularIntensity, double ambientReflecCoef, double diffuseReflecCoef, double specularReflecCoef, double shininess, Vector3 pointOnSurface, Vector3 surfaceNormal, Vector3 incomingLightDirection, Vector3 viewPoint)\nA Vector3 class representing a 3D vector is available to you, with the following member functions:\nVector3 Vector3::normalized() //returns a vector pointing in the same direction with length 1\ndouble Vector3::magnitude() //returns the length of the vector\nvoid Vector3::normalize() //normalises the vector (destructive)\nIn addition, you can assume the + and - operators are available for the Vector3 class.\nYou can assume that the following functions are also defined:\ndouble dot(Vector3 a, Vector3 b) //returns the dot product of a and b\nVector3 cross (Vector3 a, Vector3 b) //returns the cross product of a and b\ndouble pow(double a, double b) //returns a to the power of b\nHint: The parameter incomingLightDirection refers to the direction of travel of light rays emitted from the light source.",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022a17b",
        "question": "Write a function phongDirectionalSource() which implements the achromatic version of the Phong Illumination equation for a directional light source.\nIf the function is implemented correctly you should get the following result (Note: this image is rendered using only your implementation and does not use OpenGL lights or materials)\nImage description: The background is bright yellow, and a grey sphere is shown with a medium level of lighting, with a bright white highlight covering a small portion of the surface of the sphere.\nYour function should have the following signature:\ndouble phongDirectionalSource(double ambientIntensity, double diffuseIntensity, double specularIntensity, double ambientReflecCoef, double diffuseReflecCoef, double specularReflecCoef, double shininess, Vector3 pointOnSurface, Vector3 surfaceNormal, Vector3 incomingLightDirection, Vector3 viewPoint)\nA Vector3 class representing a 3D vector is available to you, with the following member functions:\nVector3 Vector3::normalized() //returns a vector pointing in the same direction with length 1\ndouble Vector3::magnitude() //returns the length of the vector\nvoid Vector3::normalize() //normalises the vector (destructive)\nIn addition, you can assume the + and - operators are available for the Vector3 class.\nYou can assume that the following functions are also defined:\ndouble dot(Vector3 a, Vector3 b) //returns the dot product of a and b\nVector3 cross (Vector3 a, Vector3 b) //returns the cross product of a and b\ndouble pow(double a, double b) //returns a to the power of b\nHint: The parameter incomingLightDirection refers to the direction of travel of light rays emitted from the light source.",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b01",
        "question": "Consider a plane\nP\ndefined by the equation\n2x+z=1\nand a point\n$$M = \\begin{pmatrix}-3\\\\2 \\\\ 7 \\end{pmatrix}$$\non this plane.\nWhich statement about the normalized vector\nv\nbeing orthogonal to the plane\nP\nat\nM\nis true?\nSelect one:\n$$a. v = \\frac{1}{\\sqrt{62}}\\begin{pmatrix}-3\\\\2\\\\7 \\end{pmatrix}$$\n$$b. v = \\frac{1}{\\sqrt{5}}\\begin{pmatrix}-3\\\\2\\\\7 \\end{pmatrix}$$\nc. None of the others\n$$d. v = \\frac{1}{\\sqrt{5}}\\begin{pmatrix}2\\\\0\\\\1 \\end{pmatrix}$$\n$$e. v = \\frac{1}{\\sqrt{62}}\\begin{pmatrix}2\\\\0\\\\1 \\end{pmatrix}$$",
        "answer": "The correct answer is:\n$$v = \\frac{1}{\\sqrt{5}}\\begin{pmatrix}2\\\\0\\\\1 \\end{pmatrix}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b02",
        "question": "Consider the point\nP\n, represented in 3D homogenous coordinates as\n$$P = \\begin{pmatrix} 3 \\\\ 2 \\\\3 \\\\1 \\end{pmatrix}$$\n.\nWhat statement about\nP'\n, the transformed point\nP\nafter first performing a translation by\n$$\\begin{pmatrix} 1 \\\\ -1 \\\\ -1 \\\\ 0 \\end{pmatrix}$$\n, then a rotation by -90 degrees around the z-axis, then a scaling by 2 in the x and y axes is true?\na. None of the others.\n$$b. P' = \\begin{pmatrix} 8 \\\\ 2 \\\\ -2 \\\\ 1 \\end{pmatrix}$$\n$$c. P' = \\begin{pmatrix} -2 \\\\ 8 \\\\ 2 \\\\ 1 \\end{pmatrix}$$\n$$d. P' = \\begin{pmatrix} 2 \\\\ -8 \\\\ 2 \\\\ 1 \\end{pmatrix}$$\n$$e. P' = \\begin{pmatrix} 8 \\\\ 8 \\\\ 2 \\\\ 1 \\end{pmatrix}$$",
        "answer": "The correct answer is:\n$$P' = \\begin{pmatrix} 2 \\\\ -8 \\\\ 2 \\\\ 1 \\end{pmatrix}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b03",
        "question": "Consider a scene with a single light source, that emits white light. This light passes through one translucent object such that red light is reflected while other light is transmitted. After passing through this object, the light then hits a second, opaque object that appears yellow.\nYou can assume that no objects in the scene other than the light source emit light, and that the only light interactions that may occur are transmission, reflection, and absorption.\nWhich of the following statements about the second object is true?\na. The object's surface must reflect red light, and absorb blue and green light.\nb. The object's surface must absorb blue light, reflect green light, and may either absorb or reflect red light.\nc. The object's surface must reflect red and green light, and absorb blue light.\nd. The scene as described is not possible.\ne. None of the others.",
        "answer": "The correct answer is:\nThe scene as described is not possible.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b04",
        "question": "You are working for \"Fancy Fun Furniture\", a company selling furniture online using VR representations. Your manager asks you to create models of different tables and chairs, which all have a blocky appearance with rounded edges and corners. What modelling technique would be most suitable for this?\nSelect one:\na. Define all polygons manual\nb. Parametric surfaces\nc. Point clouds\nd. Subdivision surfaces\ne. Implicit surfaces",
        "answer": "The correct answer is: Subdivision surfaces",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b05",
        "question": "Given is a equilateral triangle. What colours do you need to specify for the vertices in order to make the centre point light grey (RGB value (2/3, 2/3, 2/3))?\nSelect one:\na. The vertices must be red, yellow and blue.\nb. The vertices must be cyan, magenta, and yellow.\nc. The vertices must be magenta, green and blue.\nd. The vertices must be cyan, red and yellow.\ne. The vertices must be red, green and blue.",
        "answer": "The correct answer is: The vertices must be cyan, magenta, and yellow.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b06",
        "question": "Given is a 3D model of a clock where the normal at the centre of the clock face is aligned with the z-axis. The hour hand points at 12 o'clock. What OpenGL rotation command rotates the hour hand such that it points at 4 o'clock?\nSelect one:\na. glRotatef(-135 0, 0, 1);\nb. glRotatef(135, 0, 0, 1);\nc. glRotatef(-120, 0, 0, 1);\nd. glRotatef(120, 0, 0, 1);\ne. glRotatef(150, 0, 0, 1);",
        "answer": "The correct answer is: glRotatef(-120, 0, 0, 1);",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b07a",
        "question": "The image below on the left is used to texture map a rectangle as illustrated in the image below on the right. Assume the bottom-left vertex of the rectangle has the texture coordinates (2, 1) and that the texture parameter GL_REPEAT is set for both texture coordinate directions.\nWhat are the texture coordinates of the other three vertices?\nNOTE: the texture coordinate of the bottom-left vertex is (2,1) and not (0,0)!\nImage description: The picture of a sheep facing to the right is used as the base image. The image is repeated 4 times in the horizontal direction and 2 times in the vertical direction, where the top half of the second image in the vertical direction is cropped. In the filled texture map, the sheep is facing left.\nSelect one:\na. Bottom-right vertex: (-2, 1); Top-left vertex: (2, 2.5); Top-right vertex: (-2, 2.5)\nb. Bottom-right vertex: (4, 0); Top-left vertex: (0, 1.5); Top-right vertex: (4, 1.5)\nc. Bottom-right vertex: (-4, 0); Top-left vertex: (0, 1.5); Top-right vertex: (-4, 1.5)\nd. Bottom-right vertex: (-4, 1); Top-left vertex: (0, 2.5); Top-right vertex: (-4, 2.5)\ne. Bottom-right vertex: (6, 1.5); Top-left vertex: (2, 2.5); Top-right vertex: (6, 2.5)",
        "answer": "The correct answer is: Bottom-right vertex: (-2, 1); Top-left vertex: (2, 2.5); Top-right vertex: (-2, 2.5)",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b07b",
        "question": "The image below on the left is used to texture map a rectangle as illustrated in the image below on the right. Assume the bottom-left vertex of the rectangle has the texture coordinates (2, 1) and that the texture parameter GL_REPEAT is set for both texture coordinate directions.\nWhat are the texture coordinates of the other three vertices?\nNOTE: the texture coordinate of the bottom-left vertex is (2,1) and not (0,0)!\nImage description: In the filled texture map, the base image is flipped and repeated 4 times in the horizontal direction and 1.5 times in the vertical direction. The texture coordinate of the bottom-left vertex is (2,1).\nSelect one:\na. Bottom-right vertex: (-2, 1); Top-left vertex: (2, 2.5); Top-right vertex: (-2, 2.5)\nb. Bottom-right vertex: (4, 0); Top-left vertex: (0, 1.5); Top-right vertex: (4, 1.5)\nc. Bottom-right vertex: (-4, 0); Top-left vertex: (0, 1.5); Top-right vertex: (-4, 1.5)\nd. Bottom-right vertex: (-4, 1); Top-left vertex: (0, 2.5); Top-right vertex: (-4, 2.5)\ne. Bottom-right vertex: (6, 1.5); Top-left vertex: (2, 2.5); Top-right vertex: (6, 2.5)",
        "answer": "The correct answer is: Bottom-right vertex: (-2, 1); Top-left vertex: (2, 2.5); Top-right vertex: (-2, 2.5)",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b08a",
        "question": "The texture image below on the left is mapped onto a triangle producing  the picture below on the right.\nImage description: The picture of a arrow facing to the right is used as the base image. The image is repeated 3 times in the horizontal direction and shifted up diagonally to the right. The resultant texture map is a triangle. In the filled texture map, the arrow is facing right.\nAssumed the texture is repeated in both coordinate directions and the texture coordinate of the bottom left vertex is (0, 0).\nWhat are the texture coordinates at the top-left and top-right vertex of the triangle?\nSelect one:\na. The texture coordinate of the top-left vertex is (0, 1) and of the top-right vertex (3, 0).\nb. The texture coordinate of the top-left vertex is (1, 0) and of the top-right vertex (3, 0).\nc. The texture coordinate of the top-left vertex is (1, 0) and of the top-right vertex (0, 3).\nd. The texture coordinate of the top-left vertex is (0, 1) and of the top-right vertex (0, 3).\ne. The texture coordinate of the top-left vertex is (0, 1) and of the top-right vertex (3, 1).",
        "answer": "The correct answer is: The texture coordinate of the top-left vertex is (0, 1) and of the top-right vertex (3, 0).",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b08b",
        "question": "The texture image below on the left is mapped onto a triangle producing  the picture below on the right.\nImage description: In the filled texture map, the base image is repeated 3 times in the horizontal direction and shifted up diagonally. The bottom-right corner of the third base image is mapped to the top-right corner of the filled texture map.\nAssumed the texture is repeated in both coordinate directions and the texture coordinate of the bottom left vertex is (0, 0).\nWhat are the texture coordinates at the top-left and top-right vertex of the triangle?\nSelect one:\na. The texture coordinate of the top-left vertex is (0, 1) and of the top-right vertex (3, 0).\nb. The texture coordinate of the top-left vertex is (1, 0) and of the top-right vertex (3, 0).\nc. The texture coordinate of the top-left vertex is (1, 0) and of the top-right vertex (0, 3).\nd. The texture coordinate of the top-left vertex is (0, 1) and of the top-right vertex (0, 3).\ne. The texture coordinate of the top-left vertex is (0, 1) and of the top-right vertex (3, 1).",
        "answer": "The correct answer is: The texture coordinate of the top-left vertex is (0, 1) and of the top-right vertex (3, 0).",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b09",
        "question": "$$Given is an ellipsoid obtained by first scaling a unit sphere by (s_x, s_y, s_z) and then translating it by \\((t_x, t_y, t_z)\\). What is the normal direction n (not necessarily normalised) at the point \\(P=(p_x, p_y, p_z)\\) on the surface of  the ellipsoid?$$\n$$HINT: Solve this question using your solution to Q4 of the CodeRunner \"Ray Tracing\" programming quiz or use the fact that if an object is transformed by M then the normal is transformed by {\\bf M}^{-T}.$$\nSelect one:\n$$a.  \\(n=(p_x/s_x-t_x, p_y/s_y-t_y, p_z/s_z-t_z)\\)$$\n$$b.  \\(n=((p_x-t_x)/s_x, (p_y-t_y)/s_y, (p_z-t_z)/s_z)\\)$$\n$$c.  \\(n=((p_x+t_x)/s_x^2, (p_y+t_y)/s_y^2, (p_z+t_z)/s_z^2)\\)$$\n$$d.  \\(n=((p_x-t_x)/s_x^2, (p_y-t_y)/s_y^2, (p_z-t_z)/s_z^2)\\)$$\n$$e.  \\(n=((p_x+t_x)/s_x, (p_y+t_y)/s_y, (p_z+t_z)/s_z)\\)$$",
        "answer": "$$The correct answer is:  \\(n=((p_x-t_x)/s_x^2, (p_y-t_y)/s_y^2, (p_z-t_z)/s_z^2)\\)$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b10",
        "question": "Given is a sphere centered at the origin with radius r=3 and a ray\n$$p(t)=\n$$\\begin{pmatrix} 4 \\\\ -1 \\\\ 2 \\end{pmatrix}$$\n+t\n$$\\begin{pmatrix} -2 \\\\ 1 \\\\ -1 \\end{pmatrix}$$\n$$.\nWhich of the following statements is true?\nSelect one:\na. The ray intersects the sphere in two points p(t1) and p(t2) where t1<1 and t2>1.\nb. The ray intersects the sphere in exactly one point p(t) (i.e. it touches the sphere), where t>1.\nc. The ray intersects the sphere in exactly one point p(t) (i.e. it touches the sphere), where t<1.\nd. The ray does not intersect the sphere.\ne. The ray intersects the sphere in two points p(t1) and p(t2) where t1>1 and t2>1.",
        "answer": "The correct answer is: The ray intersects the sphere in two points p(t1) and p(t2) where t1<1 and t2>1.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b11",
        "question": "$$Given is a quadratic spline with the power basis $$T=\\begin{pmatrix} t^2 & t & 1\\end{pmatrix}$$ and the basis matrix:$$\n$$$$\\begin{pmatrix}$$\n$$2 & -1 & -1\\\\$$\n$$1 & -2 & 1 \\\\$$\n1 & 1 & -1\n$$\\end{pmatrix}$$$$\nWhich statement about the resulting basis functions B_1(t), B_2(t), and B_3(t) is true?\nSelect one:\na. The basis functions are all cubic.\nb. B_1(t)=2*t^2-t-1\nc. The sum of the three basis functions is always 1.\nd. B_3(t) is positive for 0<=t<=1\ne. The basis functions are the basis functions of a quadratic Bezier curve.",
        "answer": "The correct answer is: The sum of the three basis functions is always 1.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b12",
        "question": "Which coefficients of the linear mapping operation, g(x,y)=af(x,y) + b, will map the pixel value f(x,y)=75 to g(x,y)=88 and pixel value f(x,y)=155 to g(x,y)=216?\nWhich effect does this linear mapping operation defined by a and b have, when applied to an image?",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b13",
        "question": "Consider the 4x4 table representing the greyscale (8-bit) image J below. Compute the effect of a logarithmic contrast stretching on the image, which aims to increase the dynamic range of darker regions in the image.\nThe logarithmic contrast stretching operation transforms the input image J(x,y) pixelwise to an output image G(x,y) according to the equation:\n$$G(x,y) = \\frac{log(1+J(x,y))}{log(1 + Q)}$$\nHere Q is the maximal greyvalue of the greyscale range of the input image.\nThe logarithmic function is applied to each input pixel of the 8 bit input range, and generates an output in the range between 0 and 1. You finally have to transform this output range to the same (8-bit) range that the input image has. Round to the nearest integer.\nAfter computation of G, what is the pixel value of the final resulting image at the pixel location (x=1, y=3)?\n3\t8\t8   8   8\n2\t16  4   4   16\n1\t32  128 255 32\n0\t16\t64\t64  16\n    0\t1\t2\t3\nThe bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.\nSelect one:\na. 255\nb. 161\nc. 74\nd. 130\ne. 101\nf. 223\ng. 192\nh. None of the others.",
        "answer": "The correct answer is: 101",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b14",
        "question": "Consider the 4x4 table representing the grayscale image J below. What is the result when a 3x3 median filter is applied? For boundary handling, use BoundaryPaddingZero.\n3\t0\t8\t16\t64\n2\t8\t16\t32\t64\n1\t16\t32\t64\t128\n0\t64\t64\t128\t128\n    0\t1\t2\t3\nThe bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.\nValue of median filtered image at x=0, y=3?\nValue of median filtered image at x=2, y=1?\nValue of median filtered image at x=3, y=1?",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b15a",
        "question": "Given is a function drawShape() which draws a wireframe representation of the letter \"L\" in the xy-plane as shown in the image below.\nImage description: A letter L is placed on the x-y plane.\nPlease write OpenGL code to transform this shape such that you obtain the scene displayed in the image below:\nImage description: A letter L with twice the size is placed on the x-z plane.\nIMPORTANT:\nPlease only use OpenGL transformations, e.g. glScalef, glTranslatef, glRotatef\nPlease do NOT draw the shape itself - this is done automatically by the uploaded code",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b15b",
        "question": "Given is a function drawShape() which draws a wireframe representation of the letter \"L\" in the xy-plane as shown in the image below.\nImage description: A letter L is placed on the x-y plane. The vertices on the shape are p1 = (0, 0, 0), p2 = (0, 2, 0), p3 = (1.5, 0, 0).\nPlease write OpenGL code to transform this shape such that you obtain the scene displayed in the image below:\nImage description: A letter L with twice the size is placed on the x-z plane. The vertices on the shape are p1 = (0, 0, 0), p2 = (0, 0, 4), p3 = (3, 0, 0).\nIMPORTANT:\nPlease only use OpenGL transformations, e.g. glScalef, glTranslatef, glRotatef\nPlease do NOT draw the shape itself - this is done automatically by the uploaded code",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b16a",
        "question": "Given is a function drawShape() which draws a wireframe representation of the letter \"F\" in the xy-plane as shown in the image below.\nImage description: A letter F is placed on the x-y plane.\nPlease write OpenGL code to transform this shape such that you obtain the scene displayed in the image below:\nImage description: A letter F with twice the size is placed on the x-z plane and moved one unit to the right.\nIMPORTANT:\nPlease only use OpenGL transformations, e.g. glScalef, glTranslatef, glRotatef\nPlease do NOT draw the shape itself - this is done automatically by the uploaded code",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b16b",
        "question": "Given is a function drawShape() which draws a wireframe representation of the letter \"F\" in the xy-plane as shown in the image below.\nImage description: A letter F is placed on the x-y plane. The vertices on the shape are p1 = (0, 0, 0), p2 = (0, 2, 0), p3 = (1, 2, 0).\nPlease write OpenGL code to transform this shape such that you obtain the scene displayed in the image below:\nImage description: A letter F with twice the size is placed on the x-z plane and moved one unit to the the positive direction of the x-axis. The vertices on the shape are p1 = (1, 0, 0), p2 = (1, 0, 4), p3 = (3, 0, 4).\nIMPORTANT:\nPlease only use OpenGL transformations, e.g. glScalef, glTranslatef, glRotatef\nPlease do NOT draw the shape itself - this is done automatically by the uploaded code",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b17a",
        "question": "Given is an RGB colour cube with side length 2 as illustrated in the image below\"\nImage description: The image shows a RGB colour cube with side length 2. The colours shown are green, cyan, blue, pink, red, and yellow in counterclockwise order, where red is on the x-axis.\nPlease write OpenGL code to rotate this cube as illustrated in the image below.\nImage description: The image shows a RGB colour cube with side length 2 shifted one unit to the right. The colours shown are red, pink, white, cyan, green, and black in counterclockwise order, where green is on the x-axis.\nIMPORTANT:\nPlease only use OpenGL transformations, e.g. glTranslatef, glRotatef\nPlease do NOT draw the shape itself - this is done automatically by the uploaded code",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b17b",
        "question": "Given is an RGB colour cube with side length 2 as illustrated in the image below\"\nImage description: The image shows a RGB colour cube with side length 2. The point representing white is on (2, 2, 2), the point representing blue is on (0, 0, 2), and the point representing red is on (2, 0, 0).\nPlease write OpenGL code to rotate this cube as illustrated in the image below.\nImage description: The image shows a RGB colour cube with side length 2 shifted one unit to the positive direction of the x-axis. The point representing white is on (1, 0, 2), the point representing blue is on (3, 2, 2), and the point representing red is on (1, 2, 0).\nIMPORTANT:\nPlease only use OpenGL transformations, e.g. glTranslatef, glRotatef\nPlease do NOT draw the shape itself - this is done automatically by the uploaded code",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b18a",
        "question": "Given is a function drawTorus() which draws a torus with coloured \"blobs\" centered at the origin and aligned with the z-axis as shown in the image below.\nImage description: The image shows a torus centered at the origin and aligned with z-axis. The torus is coloured with green, blue, yellow, and pink in counterclockwise order, where green is on the x-axis.\nPlease write OpenGL code to render the the chain of tori displayed in the image below:\nImage description: The image shows a chain of tori. The first torus is centered at the origin, with yellow, pink, green, and blue in counterclockwise order, where yellow is on the x-axis. The second torus is centered at (1.5, 0, 0), with green, blue, yellow, and pink in counterclockwise order, where green is to the right of yellow on the x-axis. The third torus is centered at (0, 1.5, 0), with green, blue, yellow, and pink in counterclockwise order, where blue is above pink on the y-axis.\nNote that the second torus is rotated such that it lies in the xz-plane and has a centre of (1.5, 0, 0), and the third torus lies again in the zy-plane and has a centre of (0, 1.5, 0).\nIMPORTANT:\nYour code must first draw the torus centered at the origin, then the torus centered at (1.5, 0, 0), and then the torus centered at (0, 1.5, 0). Your code should have the format:\n<insert your transformations>\ndrawTorus();\n<insert your transformations>\ndrawTorus();\n<insert your transformations>\ndrawTorus();\nYou can use any OpenGL transformations, e.g. glRotatef, glTranslatef, glScalef, glPushMatrix and glPopMatrix;",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b18b",
        "question": "Given is a function drawTorus() which draws a torus with coloured \"blobs\" centered at the origin and aligned with the z-axis as shown in the image below.\nImage description: The image shows a torus centered at the origin and on the x-y plane. The torus is coloured with green, blue, yellow, and pink in counterclockwise order, where green is on the x-axis.\nPlease write OpenGL code to render the the chain of tori displayed in the image below:\nImage description: The image shows a chain of tori. The first torus is centered at the origin and on the x-y plane, with yellow, pink, green, and blue in counterclockwise order, where yellow is on the x-axis. The second torus is centered at (1.5, 0, 0) and on the x-z plane, with green, blue, yellow, and pink in counterclockwise order, where green is to the right of yellow on the x-axis. The third torus is centered at (0, 1.5, 0) and on the y-z plane, with green, blue, yellow, and pink in counterclockwise order, where blue is above pink on the y-axis.\nNote that the second torus is rotated such that it lies in the xz-plane and has a centre of (1.5, 0, 0), and the third torus lies again in the zy-plane and has a centre of (0, 1.5, 0).\nIMPORTANT:\nYour code must first draw the torus centered at the origin, then the torus centered at (1.5, 0, 0), and then the torus centered at (0, 1.5, 0). Your code should have the format:\n<insert your transformations>\ndrawTorus();\n<insert your transformations>\ndrawTorus();\n<insert your transformations>\ndrawTorus();\nYou can use any OpenGL transformations, e.g. glRotatef, glTranslatef, glScalef, glPushMatrix and glPopMatrix;",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b19a",
        "question": "The image below is used to texture map a rectangle:\nImage description: A mountain.\nThe texture mapping code to be used is:\nglBegin(GL_QUADS);\nglTexCoord2f(0,2);\nglVertex3f(0,0,0);\nglTexCoord2f(A,C);\nglVertex3f(6,0,0);\nglTexCoord2f(A,B);\nglVertex3f(6,4,0);\nglTexCoord2f(0,B);\nglVertex3f(0,4,0);\nglEnd();\nand produces the image shown below:\nImage description: A mountain facing downwards, repeated 2 times horizontally and 2 times vertically.\nPlease copy and paste the following code to define the correct values for the variables A, B and C, i.e.\nA=<Your Answer>;\nB=<Your Answer>;\nC=<Your Answer>;",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b19b",
        "question": "The image below is used to texture map a rectangle:\nImage description: A mountain facing upright.\nThe texture mapping code to be used is:\nglBegin(GL_QUADS);\nglTexCoord2f(0,2);\nglVertex3f(0,0,0);\nglTexCoord2f(A,C);\nglVertex3f(6,0,0);\nglTexCoord2f(A,B);\nglVertex3f(6,4,0);\nglTexCoord2f(0,B);\nglVertex3f(0,4,0);\nglEnd();\nand produces the image shown below:\nImage description: The base image is rotated 180 degrees, and repeated 2 times horizontally and 2 times vertically.\nPlease copy and paste the following code to define the correct values for the variables A, B and C, i.e.\nA=<Your Answer>;\nB=<Your Answer>;\nC=<Your Answer>;",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b20a",
        "question": "The image below is used to texture map a square:\nImage description: The image shows a 4x4 grid of colours. From left to right, then top to bottom, the colours are red, light green, dark blue, brown, yellow, purple, cyan, dark orange, pink, white, lime, grey, black, light blue, light orange, dark green.\nThe texture mapping code to be used is:\nglBegin(GL_QUADS);\nglTexCoord2f(0.0,0.5);\nglVertex3f(0,0,0);\nglTexCoord2f(A,B);\nglVertex3f(4,0,0);\nglTexCoord2f(C,D);\nglVertex3f(4,4,0);\nglTexCoord2f(E,F);\nglVertex3f(0,4,0);\nglEnd();\nand produces the image shown below:\nImage description: The image shows a shifted version of the base image, with the top left corner of the texture map being the the top right corner of the red tile, the bottom left corner being the top left corner of the pink tile, the bottom right corner being the bottom left corner of the dark green tile, and the top right corner being the bottom right corner of the dark orange tile.\nPlease use the following code to define the correct values for the variables A, B, C, D, E, F. NOTE: The texture coordinates must be between 0 and 1. Write the correct values into the answer space using C/C++ notation.\nA=?;\nB=?;\netc.",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b20b",
        "question": "The image below is used to texture map a square:\nImage description: The image shows a 4x4 grid of colours.\nThe texture mapping code to be used is:\nglBegin(GL_QUADS);\nglTexCoord2f(0.0,0.5);\nglVertex3f(0,0,0);\nglTexCoord2f(A,B);\nglVertex3f(4,0,0);\nglTexCoord2f(C,D);\nglVertex3f(4,4,0);\nglTexCoord2f(E,F);\nglVertex3f(0,4,0);\nglEnd();\nand produces the image shown below:\nImage description: The image shows a shifted version of the base image. Using grid coordinates from the base image, where the bottom left corner of the base image is (0, 0) and the top right corner of the base image is (4, 4), then the top left corner of the texture map is (1, 4), the bottom left corner is (0, 2), the bottom right corner is (3, 0), and the top right corner is (4, 2).\nPlease use the following code to define the correct values for the variables A, B, C, D, E, F. NOTE: The texture coordinates must be between 0 and 1. Write the correct values into the answer space using C/C++ notation.\nA=?;\nB=?;\netc.",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b21a",
        "question": "In this exercise you need to complete the function below defining an intersection between a Ray and a convex quadrilateral with circular hole. The convex quadrilateral (and its circular hole) lie on a plane with the normal n. The quadrilateral is defined by four vertices A, B, C and D, and the circular hole by its centre and radius.\nComplete the template in the answer space for the function for computing the intersection between a ray and a quadrilateral with a circular hole. You can use the algorithms explained in the lecture slide and/or use any of your solutions of the graded and ungraded CodeRunner quizzes.\nNOTE: A point is inside a convex quadrilateral, if it lies on the same side of all edges when traversing the edges in clockwise or anti-clockwise order. We can hence use the same inside-outside test as for the triangle, except that we have four instead of three edges.\ndouble QuadWithCircleHole::Intersect(Vector source, Vector d)\n{\n\t// complete calculation of ray-quadrilateral-with-circular-hole intersection in the answer box below\n\t// and return correct value for t. If there is no intersection t should be -1.0\n}\nNote: The following variables and functions are already defined for you to use:\nVector A, B, C, D - coordinates of the 4 vertices of the convex quadrilateral in winding order (either clockwise or anti-clockwise)\nVector n - normal of the plane of the quadrilateral\nVector Centre - centre of the circular hole\ndouble radius - radius of the circular hole\nVector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector\nVector: v1-v2 - subtracts v2 from v1 and returns resulting vector\nVector: v1 * t - scales the vector v1 by t and returns resulting vector\nVector v.Scale(float a, float b, float c) - scales each component of the vector v\nfloat v1.Dot(Vector v2) - returns the dot product of vector v1 and v2\nVector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2\nYou can compute the length of a vector v as \"sqrt(v.Dot(v))\"\nPlease paste the completed code fragment into the answer space. If your solution is correct you should get the following image (note: the quadrilateral is the green surface at the bottom and the circular hole appears blue (since we can see the background colour through it):\nImage description: A red sphere is placed above a green quadrilateral with a circular hole in it.",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b21b",
        "question": "In this exercise you need to complete the function below defining an intersection between a Ray and a convex quadrilateral with circular hole. The convex quadrilateral (and its circular hole) lie on a plane with the normal n. The quadrilateral is defined by four vertices A, B, C and D, and the circular hole by its centre and radius.\nComplete the template in the answer space for the function for computing the intersection between a ray and a quadrilateral with a circular hole. You can use the algorithms explained in the lecture slide and/or use any of your solutions of the graded and ungraded CodeRunner quizzes.\nNOTE: A point is inside a convex quadrilateral, if it lies on the same side of all edges when traversing the edges in clockwise or anti-clockwise order. We can hence use the same inside-outside test as for the triangle, except that we have four instead of three edges.\ndouble QuadWithCircleHole::Intersect(Vector source, Vector d)\n{\n\t// complete calculation of ray-quadrilateral-with-circular-hole intersection in the answer box below\n\t// and return correct value for t. If there is no intersection t should be -1.0\n}\nNote: The following variables and functions are already defined for you to use:\nVector A, B, C, D - coordinates of the 4 vertices of the convex quadrilateral in winding order (either clockwise or anti-clockwise)\nVector n - normal of the plane of the quadrilateral\nVector Centre - centre of the circular hole\ndouble radius - radius of the circular hole\nVector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector\nVector: v1-v2 - subtracts v2 from v1 and returns resulting vector\nVector: v1 * t - scales the vector v1 by t and returns resulting vector\nVector v.Scale(float a, float b, float c) - scales each component of the vector v\nfloat v1.Dot(Vector v2) - returns the dot product of vector v1 and v2\nVector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2\nYou can compute the length of a vector v as \"sqrt(v.Dot(v))\"\nPlease paste the completed code fragment into the answer space. If your solution is correct you should get the following image (note: the quadrilateral is the green surface at the bottom and the circular hole appears blue (since we can see the background colour through it):\nImage description: A red sphere is placed above a green quadrilateral with a circular hole in it. There exists a gap between the red sphere and the green quadrilateral, and the background colour is visible through the gap.",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b22a",
        "question": "Given is a cubic spline curve c(t)=T M G with the geometric constraint vector\nG=(p0, p1, r0, r0.5)^T\nThe curve c(t) is defined by the four conditions c(0)=p0 (start point), c(1)=p1 (end point), c'(0)=r0 (start tangent), and c'(0.5)=r0.5 (mid-point tangent).\nImplement this curve by computing its basis functions and completing the code fragment below.\nTIP: You can use the same idea we used in the lecture to derive the basis functions of the Hermite curve.\nNote that in order to get the basis functions you need to invert a 4x4 matrix.\nThis is easiest done by using an online tool such as:\nhttps://www.wolframalpha.com/calculators/matrix-inverse-calculator\nPlease write your answer into the answer space using the following format:\ndouble Basis1(double t){ return <Insert code>;} // B1(t) \ndouble Basis2(double t){ return <Insert code>;} // B2(t) \ndouble Basis3(double t){ return <Insert code>;} // B3(t)\ndouble Basis4(double t){ return <Insert code>;} // B4(t)\nCVec3df c(float t, CVec3df p0, CVec3df p1, CVec3df r0, CVec3df r05) { \n   CVec3df p=<Insert code>; \n   return p; \n}\nThe first test case uses the geometric constraints\np0.setVector(4, 0, 0);      // This is p0\np1.setVector(0, 0, 3);      // This is p1\nr0.setVector(-10, 10, 0);   // This is r0\nr05.setVector(0, 0, 10);    // This is r05\nand should result in the image below:\nImage description: A red curve in space.",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b22b",
        "question": "Given is a cubic spline curve c(t)=T M G with the geometric constraint vector\nG=(p0, p1, r0, r0.5)^T\nThe curve c(t) is defined by the four conditions c(0)=p0 (start point), c(1)=p1 (end point), c'(0)=r0 (start tangent), and c'(0.5)=r0.5 (mid-point tangent).\nImplement this curve by computing its basis functions and completing the code fragment below.\nTIP: You can use the same idea we used in the lecture to derive the basis functions of the Hermite curve.\nNote that in order to get the basis functions you need to invert a 4x4 matrix.\nThis is easiest done by using an online tool such as:\nhttps://www.wolframalpha.com/calculators/matrix-inverse-calculator\nPlease write your answer into the answer space using the following format:\ndouble Basis1(double t){ return <Insert code>;} // B1(t) \ndouble Basis2(double t){ return <Insert code>;} // B2(t) \ndouble Basis3(double t){ return <Insert code>;} // B3(t)\ndouble Basis4(double t){ return <Insert code>;} // B4(t)\nCVec3df c(float t, CVec3df p0, CVec3df p1, CVec3df r0, CVec3df r05) { \n   CVec3df p=<Insert code>; \n   return p; \n}\nThe first test case uses the geometric constraints\np0.setVector(4, 0, 0);      // This is p0\np1.setVector(0, 0, 3);      // This is p1\nr0.setVector(-10, 10, 0);   // This is r0\nr05.setVector(0, 0, 10);    // This is r05\nand should result in the image below:\nImage desciption: A cubic spline curve in space, starting from p0 = (4, 0, 0), ending at p1 = (0, 0, 3), with start tangent r0 = (-10, 10, 0) and mid-point tangent r05 = (0, 0, 10).",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b23",
        "question": "Given is a greyscale 8 bit input image in the form of a pixel array (a list of pixel rows, with each row represented again as a list). Every pixel contains an integer value between 0 and 255.\nWrite a Python3 function 'computeInterquartileRange3x3(pixel_array, image_width, image_height)' which computes and returns a filtered image containing the interquartile range of the values in the 3x3 pixel neighourhood. Similar to the standard deviation, the interquartile range measures the variation of greyvalues in a neighbourhood.\nWe define the interquartile range as the difference between the 25th percentile and the 75th percentile of the values in the 3x3 neighbourhood. While the 50th percentile is the median of all values in the neighbourhood, the 25th percentile is the median of the values smaller (<) than the median, and the 75th percentile is the median of the values larger (>) than the median. Remember, if any of these subsets has an even number of values, then we compute the mean of the two values in the middle.\nBorder handling: Border pixels should be handled with the BorderIgnore strategy, with pixels at the boundary of the output image set to 0.\nReturn the result image in our list of lists representation. Resulting pixels are floating point values, without any rounding!\nNote: You may assume that the Python3 function 'createInitializedGreyscalePixelArray(image_width, image_height, initValue)' is available, which creates an empty greyscale array (values 0) as a list of lists of integers or a greyscale array with values 0.0 as a list of lists of floats (if initValue is 0.0).\nFor example:\nTest1\nimage_width = 6\nimage_height = 5\npixel_array = [ [6, 3, 2, 6, 4, 7], \n                [5, 3, 2, 7, 0, 6], \n                [6, 2, 7, 7, 1, 7], \n                [7, 6, 6, 2, 7, 3], \n                [2, 2, 2, 5, 1, 2] ]\nprintPixelArray(computeInterquartileRange3x3(pixel_array, image_width, image_height))\nResult1\n0.0 0.0 0.0 0.0 0.0 0.0\n0.0 4.0 5.0 5.5 4.5 0.0\n0.0 4.0 5.0 5.5 5.5 0.0\n0.0 4.5 4.5 5.5 5.5 0.0\n0.0 0.0 0.0 0.0 0.0 0.0\nTest2\nimage_width = 7\nimage_height = 6\npixel_array = [ [244, 126, 101, 174, 168, 75, 62], \n                [155, 145, 15, 149, 116, 163, 238], \n                [63, 138, 132, 207, 74, 227, 163], \n                [25, 9, 85, 172, 202, 108, 193], \n                [85, 123, 49, 53, 106, 60, 197], \n                [113, 196, 35, 19, 126, 130, 48] ] \nprintPixelArray(computeInterquartileRange3x3(pixel_array, image_width, image_height))\nResult2\n0.0 0.0 0.0 0.0 0.0 0.0 0.0\n0.0 68.0 48.0 83.5 95.0 123.0 0.0\n0.0 121.5 110.5 107.5 92.5 102.5 0.0\n0.0 90.5 104.0 123.5 137.5 109.5 0.0\n0.0 88.0 120.5 107.0 94.5 112.0 0.0\n0.0 0.0 0.0 0.0 0.0 0.0 0.0",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2022b24",
        "question": "Given is a greyscale input image in the form of a pixel array (a list of pixel rows, with each row represented again as a list). Every pixel contains an integer value between 0 and nr_bins-1! For a 3 bit input image, nr_bins is 8.\nWrite a Python3 function 'computeLookupTableHistEq(pixel_array, image_width, image_height, nr_bins)' which computes the lookup table for histogram equalization of the input image according to the strategy we discussed in the lecture.\nReturn solely the lookup table as a list datastructure, with the length of the lookup table being equal to the number of bins. The datatype of the lookup table is floating point. You don't have to do any rounding of the result values.\nNote: You can assume that a method computeCumulativeHistogram(pixel_array, image_width, image_height, nr_bins) is available for your use, which you can call from within your code (see below).\ndef computeCumulativeHistogram(pixel_array, image_width, image_height, nr_bins = 256):\n    # compute histogram\n    histogram = [0.0 for q in range(nr_bins)]\n    for y in range(image_height):\n        for x in range(image_width):\n            histogram[pixel_array[y][x]] += 1.0\n    # compute cumulative histogram\n    cumulative_histogram = [0.0 for q in range(nr_bins)]\n    running_sum = 0.0\n    for q in range(nr_bins):\n        running_sum += histogram[q]\n        cumulative_histogram[q] = running_sum\n    return cumulative_histogram\nFor example:\nTest1\nimage_width = 6\nimage_height = 5\npixel_array = [ [6, 3, 2, 6, 4, 7], \n                [5, 3, 2, 7, 0, 6], \n                [6, 2, 7, 7, 1, 7], \n                [7, 6, 6, 2, 7, 3], \n                [2, 2, 2, 5, 1, 2] ]\nnr_bins = 8\nlookup_table= computeLookupTableHistEq(pixel_array, image_width, image_height, nr_bins)\nfor q in range(len(lookup_table)):\n   print(\"{}: {}\".format(q, round(lookup_table[q], 2)))\nResult1\n0: 0.0\n1: 0.48\n2: 2.41\n3: 3.14\n4: 3.38\n5: 3.86\n6: 5.31\n7: 7.0\nTest2\nimage_width = 6\nimage_height = 5\npixel_array = [ [3, 7, 2, 3, 2, 3], \n                [0, 4, 3, 1, 4, 4], \n                [3, 1, 2, 2, 2, 2], \n                [1, 3, 3, 1, 2, 2], \n                [4, 4, 3, 2, 0, 0] ]\nnr_bins = 8\nlookup_table= computeLookupTableHistEq(pixel_array, image_width, image_height, nr_bins)\nfor q in range(len(lookup_table)):\n   print(\"{}: {}\".format(q, round(lookup_table[q], 2)))\nResult2\n0: 0.0\n1: 1.04\n2: 3.37\n3: 5.44\n4: 6.74\n5: 6.74\n6: 6.74\n7: 7.0",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a01",
        "question": "Given are two vectors\n$${\\bf u} = \\begin{pmatrix} 3 \\\\ 1  \\\\ c \\end{pmatrix}$$\nand\n$${\\bf v} = \\begin{pmatrix} 2 \\\\ 4  \\\\ -2 \\end{pmatrix}$$\n.\nFor what value of c are u and v orthogonal?\nSelect one:\na. -4\nb. -2\nc. 0\nd. 3\ne. 5",
        "answer": "The correct answer is: 5",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a02",
        "question": "Given is a plane P with a normal n and an unknown vector v.\nThe projection of v onto the plane is vP and the projection of the vector v onto the normal n has a length of k.\nWhat is the vector v?\nSelect one:\n$$a. {\\bf v}=\\frac{{\\bf v_{plane}}}{|{\\bf v_{plane}}|}-k\\frac{{\\bf n}}{|{\\bf n}|}$$\n$$b. {\\bf v}=\\frac{{\\bf v_{plane}}}{|{\\bf v_{plane}}|}+k\\frac{{\\bf n}}{|{\\bf n}|}$$\nc. None of the others\n$$d. {\\bf v}={\\bf v_{plane}}-k\\frac{{\\bf n}}{|{\\bf n}|}$$\n$$e. {\\bf v}={\\bf v_{plane}}+k\\frac{{\\bf n}}{|{\\bf n}|}$$",
        "answer": "The correct answer is:\n$${\\bf v}={\\bf v_{plane}}+k\\frac{{\\bf n}}{|{\\bf n}|}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a03",
        "question": "Given are two vectors\n$${\\bf u} = \\begin{pmatrix} 0 \\\\ 1  \\\\ 3 \\end{pmatrix}$$\nand\n$${\\bf v} = \\begin{pmatrix} c \\\\ 0  \\\\ 0 \\end{pmatrix}$$\n.\nAssuming c>0, which of the statements below about the cross product of u and v is true?\nSelect one:\na. The resulting vector is zero, i.e., it is the origin.\nb. None of the others\nc. The resulting vector lies in the xy-plane, i.e., its z-coordinate is zero\nd. The resulting vector lies in the yz-plane, i.e., its x-coordinate is zero\ne. The resulting vector lies in the xz-plane, i.e., its y-coordinate is zero",
        "answer": "The correct answer is: The resulting vector lies in the yz-plane, i.e., its x-coordinate is zero",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a04",
        "question": "$$\\small\\text{Consider a plane $P$ defined by the equation $2x - 2y - z = 3$ and a point $Q = \\begin{pmatrix} 3 \\\\ -2  \\\\ 1 \\end{pmatrix}$.}$$\n$$\\small\\text{What is the absolute distance of the point $Q$ to the plane $P$?}$$\nSelect one:\na. 3\nb. 2\nc. 0 (the point is on the plane)\nd. 1\ne. 4",
        "answer": "The correct answer is: 2",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a05",
        "question": "Which of the 3D homogeneous matrices below first translates a point by the vector\n$$P = \\begin{pmatrix} 1 \\\\ 2 \\\\ 3  \\end{pmatrix}$$\nand then rotates it by 90 degree around the x-axis?\na. $$\\begin{pmatrix} 1 & 0 & 0 & 1 \\\\ 0 & 0 & 1 & 3 \\\\ 0 & -1 & 0 & -2 \\\\ 0 & 0 & 0 & 1$$\n$$\\end{pmatrix}$$\nb. $$\\begin{pmatrix} 1 & 0 & 0 & 1 \\\\ 0 & 0 & -1 & 2 \\\\ 0 & 1 & 0 & 3 \\\\ 0 & 0 & 0 & 1$$\n$$\\end{pmatrix}$$\nc. $$\\begin{pmatrix} 1 & 0 & 0 & 1 \\\\ 0 & 0 & -1 & -3 \\\\ 0 & 1 & 0 & 2 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}$$\nd. None of the others.\ne. $$\\begin{pmatrix} 1 & 0 & 0 & 1 \\\\ 0 & 0 & 1 & 2$$\n$$\\\\ 0 & -1 & 0 & 3 \\\\ 0 & 0 & 0 & 1$$\n$$\\end{pmatrix}$$",
        "answer": "The correct answer is:\n$$\\begin{pmatrix} 1 & 0 & 0 & 1 \\\\ 0 & 0 & -1 & -3 \\\\ 0 & 1 & 0 & 2 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a06",
        "question": "What is the minimum number of vertices required to draw 20 connected quadrilaterals (like a row of a chessboard) using GL_QUAD_STRIP?\nSelect one:\na. 80\nb. 60\nc. 22\nd. 42\ne. 40",
        "answer": "The correct answer is: 42",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a07",
        "question": "A light source with magenta light illuminates a cyan coloured object. What is the perceived colour of the object?\nSelect one:\na. Green\nb. Blue\nc. White\nd. Red\ne. Black",
        "answer": "The correct answer is: Blue",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a08",
        "question": "Which of the following statements is false?\nSelect one:\na. The interaction of light with a material can be described using a spectral response function.\nb. Materials can absorb, reflect, and/or transmit light.\nc. The saturation (or purity) of a colour describes the percentage of luminance residing in the dominant component of the spectrum.\nd. Different spectral density functions are perceived as different colours.\ne. The spectral density function shows the strength of the variations(energy) as a function of frequency.",
        "answer": "The correct answer is: Different spectral density functions are perceived as different colours.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a09",
        "question": "Given is a triangle with the RGB vertex colours (0.8, 0.6, 0.2) at vertex A, (0.1, 0.1, 0.1) at vertex B, and (0.2, 0.0, 0.6) at vertex C. What us the RGB colour of the point half-way between vertex A and B?\nSelect one:\na. (0.7, 0.5, 0.1)\nb. It depends on the orientation of the triangle.\nc. (0.45, 0.35, 0.15)\nd. (0.5, 0.3, 0.4)\ne. (0.9, 0.7, 0.3)",
        "answer": "The correct answer is: (0.45, 0.35, 0.15)",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a10",
        "question": "Which of the following statements about colour spaces is false?\nSelect one:\na. The colour gamut describes the range of colours that can be reproduced on an output device.\nb. If we represent two pure spectral colours (i.e., rainbow colours) in HSV coordinates, then linearly interpolating these colours gives also a pure spectral colour (rainbow colour).\nc. If we represent two pure spectral colours (i.e., rainbow colours) in RGB coordinates, then linearly interpolating these colours gives also a pure spectral colour (rainbow colour).\nd. The HSV colour space is more convenient and intuitive than the RGB colour space for colour design.\ne. The RGB colour space mirrors the way colours are represented in display devices, i.e., as combination of red, green and blue light.",
        "answer": "The correct answer is: If we represent two pure spectral colours (i.e., rainbow colours) in RGB coordinates, then linearly interpolating these colours gives also a pure spectral colour (rainbow colour).",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a11",
        "question": "The CIE XYZ colour space may be represented as a projection on the 2D plane: x + y + Z = 1.\nGiven the color (2, 4, 2), what is the corresponding 2D colour in the CIE chromaticity diagram?\nSelect one:\na. (0.25, 0.5)\nb. (0.5, 1.0)\nc. (2, 4)\nd. (1, 2)\ne. (0.2, 0.4)",
        "answer": "The correct answer is: (0.25, 0.5)",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a12",
        "question": "Which of the following statements about shadows is false?\nSelect one:\na. Shadow maps are calculated by rendering a scene from the light's perspective.\nb. The shadow of a cube is always a square or rectangle regardless of the orientation of the cube and position of the light source.\nc. Without shadows it is difficult to perceive the position of an object with respect to a ground plane.\nd. The projected shadow of a 3D object cast on a ground plane can be computed by multiplying all vertices of the object with a matrix.\ne. Shadow maps can be used to compute shadows for any surface.",
        "answer": "The correct answer is: The shadow of a cube is always a square or rectangle regardless of the orientation of the cube and position of the light source.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a13",
        "question": "Given is a uvn-coordinate system with the origin \n$$O_{uvn} = \\begin{pmatrix} 1 \\\\ 2  \\\\ -1 \\end{pmatrix}$$\nand the coordinate axis \n$${\\bf u} = \\begin{pmatrix} 0 \\\\ -1  \\\\ 0 \\end{pmatrix}\\text{ ,  } {\\bf v} = \\begin{pmatrix} 1 \\\\ 0  \\\\ 0 \\end{pmatrix}\\text{  and } {\\bf n} = \\begin{pmatrix} 0 \\\\ 0  \\\\ 1 \\end{pmatrix}$$\nGiven is a point P with the uvn-coordinates \n$${\\bf p}_{uvn} = \\begin{pmatrix} 2 \\\\ 1  \\\\ 3 \\end{pmatrix}$$\n.\nWhat are the xyz-coordinates (world coordinates) of this point?\nSelect one:\na. $$\\begin{pmatrix} 1 \\\\ 1  \\\\ 4 \\end{pmatrix}$$\nb. $$\\begin{pmatrix} 1 \\\\ -1  \\\\ 4 \\end{pmatrix}$$\nc. $$\\begin{pmatrix} 3 \\\\ 3  \\\\ 2 \\end{pmatrix}$$\nd. $$\\begin{pmatrix} 2 \\\\ 0  \\\\ 2 \\end{pmatrix}$$\ne. $$\\begin{pmatrix} 3 \\\\ -3  \\\\ 2 \\end{pmatrix}$$",
        "answer": "The correct answer is:\n$$\\begin{pmatrix} 2 \\\\ 0  \\\\ 2 \\end{pmatrix}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a14",
        "question": "Given is a scene containing an illuminated object. The scene contains a single light source with ambient intensity Ia=0.2 and diffuse intensity Id=0.5. The illuminated object has the ambient reflection coefficient \u03c1a=0.5 and \u03c1d=0.9. Given is a point p=(0,0,0)T on the surface of the object. The surface normal at p is (0,0,1)T, the light position is (2,1,2)T, and the viewpoint is  (3,0,0)T.\nUsing the (achromatic) Phong Illumination equation discussed in the lecture and assignment, what is the diffuse component of the reflected light at p?\nNOTE 1: Please assume that there is no distance dependency, i.e. kc=1.0 and kl=kq=0.0.\nNOTE 2: In order to work out your answer you may not need all of the parameters specified above.\nSelect one:\na. 0.4\nb. 0.35\nc. 1/3\nd. 0.45\ne. 0.3",
        "answer": "The correct answer is: 0.3",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a15",
        "question": "Write a function areaTriangle(), that takes as parameters three 3D vectors representing points, and returns a floating point value representing the area of the triangle. Your function should have the following signature:\ndouble areaTriangle(Vector3 p0, Vector3 p1, Vector3 p2)\nYou can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z, and that the following functions are available to you:\ndouble dot(Vector3 u, Vector3 v) //dot product\nVector3 cross(Vector3 u, Vector3 v) //cross product\nYou can assume that the Vector3 class has the following member functions available to you:\nVector3 Vector3.normalized() //returns a vector pointing in the same direction with length 1\ndouble Vector3.magnitude() //returns the length of the vector\nYou can assume that the Vector3 class supports the following operators returning objects of type Vector3:\nVector3 + Vector3\nVector3 - Vector3\nFor example:\nTest1\nVector3 p0 = Vector3(0.0, 0.0, 0.0);\nVector3 p1 = Vector3(3.0, 0.0, 0.0);\nVector3 p2 = Vector3(0.0, 2.0, 0.0);\nprintf(\"area = %.2lf\", areaTriangle(p0,p1,p2));\nResult1\narea = 3.00\nTest2\nVector3 p0 = Vector3(0.0, 0.0, 0.0);\nVector3 p1 = Vector3(3.0, 0.0, 0.0);\nVector3 p2 = Vector3(1.5, 5.0, 0.0);\nprintf(\"area = %.2lf\", areaTriangle(p0,p1,p2));\nResult2\narea = 7.50\nTest3\nVector3 p0 = Vector3(1.0, 0.0, 2.0);\nVector3 p1 = Vector3(2.0, 1.0, 3.5);\nVector3 p2 = Vector3(3.0, 2.0, 5.0);\nprintf(\"area = %.2lf\", areaTriangle(p0,p1,p2));\nResult3\narea = 0.00",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a16",
        "question": "Write a function MixHSV(), that takes as a parameter two HSV colours with each component in the range [0...1], and returns the HSV colour which is the average of the two input colours. Your function should have the following signature:\nHSVColour MixHSV(HSVColour c1, HSVColour c2)\nYou can assume that HSVColour is a class that represents a colour in the 3D HSV space and exposes fields named H, S, and V.\nFor example:\nTest1\nHSVColour mixedColour = MixHSV(HSVColour(0.6, 1.0, 1.0), HSVColour(0.8, 1.0, 1.0));\nprintf(\"Mixed HSV colour = (%.2lf, %.2lf, %.2lf)\", mixedColour.H, mixedColour.S, mixedColour.V); \nResult1\nMixed HSV colour = (0.70, 1.00, 1.00)\nTest2\nHSVColour mixedColour = MixHSV(HSVColour(0.0, 0.0, 0.0), HSVColour(1.0, 1.0, 1.0));\nprintf(\"Mixed HSV colour = (%.2lf, %.2lf, %.2lf)\", mixedColour.H, mixedColour.S, mixedColour.V); \nResult2\nMixed HSV colour = (0.50, 0.50, 0.50)",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a17a",
        "question": "Given are the vertices\nconst int numVertices=9;\nconst float vertices[numVertices][2] = { {100,50},{300,50},{150,150},{250,150},{50,200},{150,200},{250,200},{350,200},{200,300} };\nWhich calling sequence of these vertices results in the shape below if we use the OpenGL commands glBegin(GL_TRIANGLE_FAN) and glEnd()?\nImage description: The image shows a star shape with the bottom two vertices connected by a line. The vertices are labelled according to the vertices array above.\nWrite OpenGL code for drawing the shape. You can assume that the following function is defined:\nvoid v(int i) {glVertex2fv(vertices[i]);}\nYour code should have the following form:\nglBegin(GL_TRIANGLE_FAN);\nv(<start_index>); // draw first vertex\n// draw as many additional vertices as necessary using the above format\nglEnd();\nIMPORTANT:\n1) Use as first vertex the vertex with the smallest possible index resulting in the correct shape. The vertices must be defined in clockwise order.\nIf you get the correct image but an error in the test case then this might indicate that you used anticlockwise order, or that your first vertex index is not correct, or that you have drawn more vertices than necessary.",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a17b",
        "question": "Given are the vertices\nconst int numVertices=9;\nconst float vertices[numVertices][2] = { {100,50},{300,50},{150,150},{250,150},{50,200},{150,200},{250,200},{350,200},{200,300} };\nWhich calling sequence of these vertices results in the shape below if we use the OpenGL commands glBegin(GL_TRIANGLE_FAN) and glEnd()?\nImage description: The image shows a star shape with the bottom two vertices connected by a line. The vertices are labelled according to the vertices array above. Lines connecting the 2nd vertex to every other vertex are all inside the shape.\nWrite OpenGL code for drawing the shape. You can assume that the following function is defined:\nvoid v(int i) {glVertex2fv(vertices[i]);}\nYour code should have the following form:\nglBegin(GL_TRIANGLE_FAN);\nv(<start_index>); // draw first vertex\n// draw as many additional vertices as necessary using the above format\nglEnd();\nIMPORTANT:\n1) Use as first vertex the vertex with the smallest possible index resulting in the correct shape. The vertices must be defined in clockwise order.\nIf you get the correct image but an error in the test case then this might indicate that you used anticlockwise order, or that your first vertex index is not correct, or that you have drawn more vertices than necessary.",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a18a",
        "question": "Given are the vertices\nconst int numVertices=8;\nconst float vertices[numVertices][2] = {{50,50},{100,50},{200,50},{250,50},{50,300},{100,300},{200,300},{250,300} };\nWhich calling sequence of these vertices results in the shape below if we use the OpenGL commands glBegin(GL_TRIANGLE_STRIP) and glEnd()?\nImage description: The image shows an N-shaped triangle strip. The vertices are labelled according to the vertices array above.\nWrite OpenGL code for drawing the shape. You can assume that the following function is defined:\nvoid v(int i) {glVertex2fv(vertices[i]);}\nYour code should have the following form:\nglBegin(GL_TRIANGLE_STRIP);\nv(<start_index>); // draw first vertex\n// draw as many additional vertices as necessary using the above format\nglEnd();\nIMPORTANT:\n1) Use as first vertex the vertex with the smallest possible index resulting in the correct shape.  Do not repeat any vertices. Note that some triangles are allowed to slightly overlap.\nIf you get the correct image but an error in the test case then this might indicate that your first vertex index is not correct, or that you have drawn more vertices than necessary.",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a18b",
        "question": "Given are the vertices\nconst int numVertices=8;\nconst float vertices[numVertices][2] = {{50,50},{100,50},{200,50},{250,50},{50,300},{100,300},{200,300},{250,300} };\nWhich calling sequence of these vertices results in the shape below if we use the OpenGL commands glBegin(GL_TRIANGLE_STRIP) and glEnd()?\nImage description: The image shows an N-shaped triangle strip. The vertices are labelled according to the vertices array above. The vertices 0, 1, 4, 5 form a rectangle, the vertices 4, 5, 2, 3 form a parallelogram, and the vertices 2, 3, 6, 7 form a rectangle.\nWrite OpenGL code for drawing the shape. You can assume that the following function is defined:\nvoid v(int i) {glVertex2fv(vertices[i]);}\nYour code should have the following form:\nglBegin(GL_TRIANGLE_STRIP);\nv(<start_index>); // draw first vertex\n// draw as many additional vertices as necessary using the above format\nglEnd();\nIMPORTANT:\n1) Use as first vertex the vertex with the smallest possible index resulting in the correct shape.  Do not repeat any vertices. Note that some triangles are allowed to slightly overlap.\nIf you get the correct image but an error in the test case then this might indicate that your first vertex index is not correct, or that you have drawn more vertices than necessary.",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a19",
        "question": "Write a function RGB2SV(), that takes as a parameter an RGB colour with each component in the range [0...1], and returns a vector where the x-coordinate is the saturation of the RGB colour and the y-coordinate is the value (intensity) of the RGB colour.\nThe function should have the following format:\nVector2 RGB2SV(RGBColour c)\nYou can assume that RGBColour is a class that represents a colour in the 3D RGB space and exposes fields named R, G, and B.\nYou can assume that Vector2 is a class that represents a 2D vector, and exposes fields named x and y.\nHINT:\nGiven an RGB colour (R, G, B) the saturation S and value V are computed as follows:\nV=max(R, G, B)\ndelta=max(R, G, B) - min(R, G, B)\nS=delta/V if V>0 and otherwise S=0\nNOTE: You can compute the maximum and minimum of two floating point values using the functions max(x,y) and min(x,y)\nFor example:\nTest1\nRGBColour c = RGBColour(0.0, 0.0, 0.0);\nVector2 saturationAndValue = RGB2SV(c);\nprintf(\"Saturation = %.2lf, Value = %.2lf\", saturationAndValue.x, saturationAndValue.y);\nResult1\nSaturation = 0.00, Value = 0.00\nTest2\nRGBColour c = RGBColour(1.0, 1.0, 1.0);\nVector2 saturationAndValue = RGB2SV(c);\nprintf(\"Saturation = %.2lf, Value = %.2lf\", saturationAndValue.x, saturationAndValue.y);\nResult2\nSaturation = 0.00, Value = 1.00\nTest3\nRGBColour c = RGBColour(1.0, 0.3, 0.3);\nVector2 saturationAndValue = RGB2SV(c);\nprintf(\"Saturation = %.2lf, Value = %.2lf\", saturationAndValue.x, saturationAndValue.y);\nResult3\nSaturation = 0.70, Value = 1.00\nTest4\nRGBColour c = RGBColour(0.5, 0.3, 0.3);\nVector2 saturationAndValue = RGB2SV(c);\nprintf(\"Saturation = %.2lf, Value = %.2lf\", saturationAndValue.x, saturationAndValue.y);\nResult4\nSaturation = 0.40, Value = 0.50",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a20",
        "question": "Write a function areaTriangleFan(), that takes as parameters the number of points of the triangle fan, an array with the points defining the triangle fan, and returns a floating point value representing the area of the triangle fan. Your function should have the following signature:\ndouble areaTriangleFan(int numVertices, Vector3 *vertices)\nYou can assume that the triangle fan is defined the same as the corresponding OpenGL primitive, i.e., the first vertex forms triangles with each pair of consecutive vertices. You can also assume that the input is a valid triangle fan and that it has at least 3 vertices.\nHINT:\nThink about how OpenGL divides a triangle fan into triangles.\nYou can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z, and that the following functions are available to you:\ndouble dot(Vector3 u, Vector3 v) //dot product\nVector3 cross(Vector3 u, Vector3 v) //cross product\nYou can assume that the Vector3 class has the following member functions available to you:\nVector3 Vector3.normalized() //returns a vector pointing in the same direction with length 1\ndouble Vector3.magnitude() //returns the length of the vector\nYou can assume that the Vector3 class supports the following operators returning an object of type Vector3:\nVector3 + Vector3\nVector3 - Vector3\nFor example:\nTest1\nint numVertices = 3;\nVector3 vertices[numVertices]={Vector3(0.0, 0.0, 0.0),Vector3(3.0, 0.0, 0.0),Vector3(0.0, 2.0, 0.0)};\nprintf(\"area = %.2lf\", areaTriangleFan(numVertices, vertices));\nResult1\narea = 3.00\nTest2\nint numVertices = 4;\nVector3 vertices[numVertices]={Vector3(2.0, 2.0, 0.0),Vector3(0.0, 0.0, 0.0),Vector3(4.0, 2.0, 0.0),Vector3(0.0, 5.0, 0.0)};\nprintf(\"area = %.2lf\", areaTriangleFan(numVertices, vertices));\nResult2\narea = 5.00",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a21a",
        "question": "Phong Shading interpolates the surface normal of a polygon and computes the perceived colour of each pixel using the Phong Illumination model. In OpenGL this is usually implemented using so-called fragment shaders.\nIn order to apply Phong shading to a triangle we need to interpolate the normals at the vertices of the triangle. In this exercise you will implement a function barycentricInterpolation, which interpolates the normals of a triangle for a given point p on the triangle. The signature of the function is:\nCVec3df barycentricInterpolation(CVec3df p, CVec3df p0, CVec3df p1, CVec3df p2, CVec3df n0, CVec3df n1, CVec3df n2)\nThe point p is a point on the triangle. The vertices of the triangle are p0, p1, and p2, and the corresponding normals are n0, n1, and n2. The function returns the interpolated normal at the point p. The interpolation must be performed using barycentric interpolation as discussed in the lecture.\nAfter completing this function you should get the following output:\nImage description: The image shows a grey triangle with some white spots on a yellow background.\nNOTE 1:\nYou can use the function\ndouble areaTriangle(CVec3df p0, CVec3df p1, CVec3df p2)\nwhich returns the area of the triangle defined by three points p0, p1 and p2.\nNOTE 2:\nThe class CVec3df implements a 3D vector as a 3D array. The class defines operations for adding two vectors and scaling vectors, e.g.:\nCVec3df a,b,c;\nc=a+b;\nc=5.0*a;\ndouble xCoor=a[0];    // x-coordinate\ndouble yCoor=a[1];    // y-coordinate\ndouble zCoor=a[2];    // z-coordinate",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a21b",
        "question": "Phong Shading interpolates the surface normal of a polygon and computes the perceived colour of each pixel using the Phong Illumination model. In OpenGL this is usually implemented using so-called fragment shaders.\nIn order to apply Phong shading to a triangle we need to interpolate the normals at the vertices of the triangle. In this exercise you will implement a function barycentricInterpolation, which interpolates the normals of a triangle for a given point p on the triangle. The signature of the function is:\nCVec3df barycentricInterpolation(CVec3df p, CVec3df p0, CVec3df p1, CVec3df p2, CVec3df n0, CVec3df n1, CVec3df n2)\nThe point p is a point on the triangle. The vertices of the triangle are p0, p1, and p2, and the corresponding normals are n0, n1, and n2. The function returns the interpolated normal at the point p. The interpolation must be performed using barycentric interpolation as discussed in the lecture.\nAfter completing this function you should get the following output:\nImage description: The image shows a moderately bright triangle with some brighter spots on a plain, yellow background.\nNOTE 1:\nYou can use the function\ndouble areaTriangle(CVec3df p0, CVec3df p1, CVec3df p2)\nwhich returns the area of the triangle defined by three points p0, p1 and p2.\nNOTE 2:\nThe class CVec3df implements a 3D vector as a 3D array. The class defines operations for adding two vectors and scaling vectors, e.g.:\nCVec3df a,b,c;\nc=a+b;\nc=5.0*a;\ndouble xCoor=a[0];    // x-coordinate\ndouble yCoor=a[1];    // y-coordinate\ndouble zCoor=a[2];    // z-coordinate",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a22a",
        "question": "Given is a triangle with the vertices:\nconst int numVertices=3;\nconst float vertices[numVertices][2] = {{-50,0},{50,0},{0,120}};\nThe triangles has a width of 100 and a height of 120 and is oriented along the y-axis.\nUse this triangle to draw a sun / flower shape as shown in the images below. The given program draws a red circle with centre (250, 250) and radius 100. Please draw n triangles around this red circle in anti-clockwise direction starting with the triangle at the top. To place the triangles around the red circle they are transformed as follows:\n1) The triangle given above is translated by 100 in y-direction\n2) The i-th triangle is rotated by i/n*360 degree around the origin. For example, if n=4 then the first triangle is rotated by 0 degree, the second by 90 degree, the third by 180 degree, and the fourth by 270 degree.\n3) Translate the rotated triangle by 250 in x- and y-direction\nIMPORTANT:\n1) The number n of triangles is  given by the variable numTriangles. Please do not change it.\n2) Please draw the n triangles in anti-clockwise order starting with the triangle at the top (0 degree rotation). Each triangle is drawn using GL_TRIANGLES and the vertex order 0, 1, 2\n3) You are not allowed to use OpenGL transformations, i.e., you need to compute the transformed vertices before you draw them. You can use the functions cos(x) and sin(x).  Note that these functions use an argument in radian. In order to use an angle in degree you can write: cos(2*PI*angleInDegree/360.0f)\nNote that the constant PI is already predefined.\n4) Note that if two arguments are integers C/C++ uses integer division, e.g. 7/3=2. In order to get floating point division one of the arguments must be a floating point number, e.g., 7.0f/3 or ((float) 7)/3\n5) Please draw the transformed vertices using the function\nmyVertex2D(float x, float y)\nwhich calls the corresponding glVertex command and outputs information for the automarker.\nThe image below shows the expected output for n=4, n=8, and n=20.\nImage description: The image shows three red circles, each with four, eight, and twenty yellow triangles around it. The triangles are oriented in a flower pattern.",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023a22b",
        "question": "Given is a triangle with the vertices:\nconst int numVertices=3;\nconst float vertices[numVertices][2] = {{-50,0},{50,0},{0,120}};\nThe triangles has a width of 100 and a height of 120 and is oriented along the y-axis.\nUse this triangle to draw a sun / flower shape as shown in the images below. The given program draws a red circle with centre (250, 250) and radius 100. Please draw n triangles around this red circle in anti-clockwise direction starting with the triangle at the top. To place the triangles around the red circle they are transformed as follows:\n1) The triangle given above is translated by 100 in y-direction\n2) The i-th triangle is rotated by i/n*360 degree around the origin. For example, if n=4 then the first triangle is rotated by 0 degree, the second by 90 degree, the third by 180 degree, and the fourth by 270 degree.\n3) Translate the rotated triangle by 250 in x- and y-direction\nIMPORTANT:\n1) The number n of triangles is  given by the variable numTriangles. Please do not change it.\n2) Please draw the n triangles in anti-clockwise order starting with the triangle at the top (0 degree rotation). Each triangle is drawn using GL_TRIANGLES and the vertex order 0, 1, 2\n3) You are not allowed to use OpenGL transformations, i.e., you need to compute the transformed vertices before you draw them. You can use the functions cos(x) and sin(x).  Note that these functions use an argument in radian. In order to use an angle in degree you can write: cos(2*PI*angleInDegree/360.0f)\nNote that the constant PI is already predefined.\n4) Note that if two arguments are integers C/C++ uses integer division, e.g. 7/3=2. In order to get floating point division one of the arguments must be a floating point number, e.g., 7.0f/3 or ((float) 7)/3\n5) Please draw the transformed vertices using the function\nmyVertex2D(float x, float y)\nwhich calls the corresponding glVertex command and outputs information for the automarker.\nThe image below shows the expected output for n=4, n=8, and n=20.\nImage description: The left part of the image shows a red circle, around this circle there are 4 triangles. The first triangle is at the top and is rotated by 0 degrees. The second triangle is rotated by 90 degrees, the third by 180 degrees, and the fourth by 270 degrees. The triangles are oriented such that they form a flower shape. The center part of the image shows a red circle, around this circle there are 8 triangles. The first triangle is at the top and is rotated by 0 degrees. The second triangle is rotated by 45 degrees, the third by 90 degrees, the fourth by 135 degreess, the fifth by 180 degrees, the sixth by 225 degrees, the seventh by 270 degrees, and the eighth by 315 degrees. The triangles are oriented such that they form a flower shape. The right part shows the same as the center part but with 20 triangles.",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b01",
        "question": "Consider a surface that reflects the colour yellow when three lights are shining on it: one red, one green, one blue.\nWhat will be the reflected colour if the red light is removed?\na. Yellow\nb. Green\nc. Black\nd. Red\ne. Cyan",
        "answer": "The correct answer is:\nGreen",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b02a",
        "question": "Given is a 3D medical imaging data set of a head which specifies for each point the radiodensity of the material, i.e., to what extend the material blocks x-rays. For example, bone has a higher value (is less transmissible) than muscle, skin, and fluid. What surface representation is most suitable for rendering the bone layer of the head as illustrated in the image below?\nImage description: A 3D model of a skull.\nSelect one:\na. Parametric surfaces\nb. CSG (Constructive Solid Geometry)\nc. Subdivision surfaces\nd. Implicit surfaces\ne. First using a CGS object and then smoothing it using a subdivision surface.",
        "answer": "The correct answer is: Implicit surfaces",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b02b",
        "question": "Given is a 3D medical imaging data set of a head which specifies for each point the radiodensity of the material, i.e., to what extend the material blocks x-rays. For example, bone has a higher value (is less transmissible) than muscle, skin, and fluid. What surface representation is most suitable for rendering the bone layer of the head as illustrated in the image below?\nImage description: A 3D model of a skull in white, there are a lot of intricate details in the model.\nSelect one:\na. Parametric surfaces\nb. CSG (Constructive Solid Geometry)\nc. Subdivision surfaces\nd. Implicit surfaces\ne. First using a CGS object and then smoothing it using a subdivision surface.",
        "answer": "The correct answer is: Implicit surfaces",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b03",
        "question": "Which of the following statements about rendering in OpenGL is false (if any)?\nSelect one:\na. We can render a cube consisting of 6 square polygons without a depth buffer if we render back faces first and then front faces.\nb. When displaying an animated scene we need to use double buffering to avoid rendering artifacts.\nc. None of the other statements is false, i.e., they are all true.\nd. OpenGL uses the winding order of polygons to determine front and back faces.\ne. When rendering closed 3D surfaces, such as a sphere or cube, we must enable back-face culling since otherwise the resulting image will look wrong.",
        "answer": "The correct answer is: When rendering closed 3D surfaces, such as a sphere or cube, we must enable back-face culling since otherwise the resulting image will look wrong.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b04",
        "question": "Given is a equilateral triangle. What colours do we need to specify for the vertices in order to make the centre point dark grey (RGB value (1/3, 1/3, 1/3))?\nSelect one:\na. The vertices must be cyan, red and yellow.\nb. The vertices must be magenta, green and blue.\nc. The vertices must be cyan, magenta, and yellow.\nd. The vertices must be red, yellow and blue.\ne. The vertices must be red, green and blue.",
        "answer": "The correct answer is: The vertices must be red, green and blue.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b05",
        "question": "Which of the following statements about parametric curves and surfaces is true?\nSelect one:\na. The normal of a parametric surface p(s,t) is obtained by interpolating p(0,0), p(0,1), p(1,0), and p(1,1).\nb. When defining a surface-of-revolution the profile curve can be a spline curve, e.g., a Catmul-Rom spline.\nc. Squares and discs can not be represented as parametric surfaces.\nd. The Hermit curve is a quadratic spline.\ne. Bezier curves are always cubic, e.g., quadratic Bezier curves do not exist.",
        "answer": "The correct answer is: When defining a surface-of-revolution the profile curve can be a spline curve, e.g., a Catmul-Rom spline.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b06",
        "question": "Given is a light source at the position\nL=(1, 3, 0)^T\nand an object with the point\nP=(1, 2, 1)\n.\nIf we draw the projected shadow of the object on the plane y=1, what is the position P' of the point P projected on the plane y=1?\nHint: Make yourself an illustration of the situation.\nSelect one:\na. P'=(2, 1, 3)^T\nb. P'=(1, 1, 2)^T\nc. P'=(2, 1, 0)^T\nd. P'=(0, 1, 1)^T\ne. P'=(1, 1, 3)^T",
        "answer": "The correct answer is:\nP'=(1, 1, 2)^T",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b07a",
        "question": "Given are the following vertices:\nconst int numVertices=7;\nconst float vertices[numVertices][2] = { {50,50},{300,50},{50,150},{50,200},{200,200},{50,300},{300,300} };\nConsider the image shown below.\nImage description: The image shows a square with a triangle cropped out. The vertices of the square are 0, 1, 6, 5. The vertices of the triangle are 2, 4, 3.\nWhich calling sequence of these vertices (using glVertex2fv) results in the shape in the image above, if we use the OpenGL commands glBegin(GL_TRIANGLE_FAN) and glEnd()?\nSelect one:\na. 4, 1, 0, 2, 3, 5, 6\nb. 6, 1, 0, 2, 4, 3, 5\nc. 0, 1, 2, 3, 4, 5, 6\nd. 4, 3, 5, 6, 1, 0, 2\ne. 1, 0, 2, 4, 3, 5, 6",
        "answer": "The correct answer is: 4, 3, 5, 6, 1, 0, 2",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b07b",
        "question": "Given are the following vertices:\nconst int numVertices=7;\nconst float vertices[numVertices][2] = { {50,50},{300,50},{50,150},{50,200},{200,200},{50,300},{300,300} };\nConsider the image shown below.\nImage description: The image shows a square with a triangle cropped out. The vertices of the square are 0, 1, 6, 5 counterclockwise. The vertices of the triangle are 2, 4, 3 counterclockwise. Lines from the 4th vertex to every other vertex are included in the shape.\nWhich calling sequence of these vertices (using glVertex2fv) results in the shape in the image above, if we use the OpenGL commands glBegin(GL_TRIANGLE_FAN) and glEnd()?\nSelect one:\na. 4, 1, 0, 2, 3, 5, 6\nb. 6, 1, 0, 2, 4, 3, 5\nc. 0, 1, 2, 3, 4, 5, 6\nd. 4, 3, 5, 6, 1, 0, 2\ne. 1, 0, 2, 4, 3, 5, 6",
        "answer": "The correct answer is: 4, 3, 5, 6, 1, 0, 2",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b08",
        "question": "Given is a plane 3x+2y-z=3 and a ray\n$$p(t)= \\begin{pmatrix} 1 \\\\ 0  \\\\ 1 \\end{pmatrix} + t * \\begin{pmatrix} -1 \\\\ c  \\\\ 0 \\end{pmatrix}.$$\nFor what value of c is the ray parallel to the plane?\nSelect one:\na. c=0\nb. c=0.5\nc. c=1.5\nd. c=-0.5\ne. c=1",
        "answer": "The correct answer is: c=1.5",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b09a",
        "question": "Given is a function drawHouse() which draws a wire frame house in the xy-plane as shown in the image below:\nImage description: A shape of a house is drawn in the xy-plane. The house is made up of a square with a triangle on top.\nWe now transform the house in two different ways before drawing it:\nDrawing 1:\nglScalef(2.0, 1.0, 1.0);\ndrawHouse();\nDrawing 2:\nglScalef(2.0, 1.0, -1.0);\ndrawHouse();\nWhich of the following statements is correct?\nSelect one:\na. The two drawings look the same, but the MODEL_VIEW matrices used to transform the house before drawing are different.\nb. The two drawings look different, and the MODEL_VIEW matrices used to transform the house before drawing are different.\nc. The two drawings look the same, and the MODEL_VIEW matrices used to transform the house before drawing are the same.\nd. The transformation is not possible (generates an error).\ne. The two drawings look different, but the MODEL_VIEW matrices used to transform the house before drawing are the same.",
        "answer": "The correct answer is: The two drawings look the same, but the MODEL_VIEW matrices used to transform the house before drawing are different.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b09b",
        "question": "Given is a function drawHouse() which draws a wire frame house in the xy-plane as shown in the image below:\nImage description: A shape of a house is drawn in the xy-plane. The house is made up of a square with a triangle on top. The square is made up of four points, (0, 0), (2, 0), (2, 2), and (0, 2). The triangle is made up of three points, (0, 2), (2, 2), and (1, 3).\nWe now transform the house in two different ways before drawing it:\nDrawing 1:\nglScalef(2.0, 1.0, 1.0);\ndrawHouse();\nDrawing 2:\nglScalef(2.0, 1.0, -1.0);\ndrawHouse();\nWhich of the following statements is correct?\nSelect one:\na. The two drawings look the same, but the MODEL_VIEW matrices used to transform the house before drawing are different.\nb. The two drawings look different, and the MODEL_VIEW matrices used to transform the house before drawing are different.\nc. The two drawings look the same, and the MODEL_VIEW matrices used to transform the house before drawing are the same.\nd. The transformation is not possible (generates an error).\ne. The two drawings look different, but the MODEL_VIEW matrices used to transform the house before drawing are the same.",
        "answer": "The correct answer is: The two drawings look the same, but the MODEL_VIEW matrices used to transform the house before drawing are different.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b10",
        "question": "Which of the 3D homogeneous matrices below first translates a point by the vector\n$$P = \\begin{pmatrix} 2 \\\\ 3 \\\\ 1  \\end{pmatrix}$$\nand then rotates it by 90 degree anti-clockwise around the y-axis?\na. None of the others.\nb. $$\\begin{pmatrix} 1 & 0 & 0 & 2 \\\\ 0 & 1 & 0 & 3$$\n$$\\\\ 0 & 0 & 1 & 1 \\\\ 0 & 0 & 0 & 1$$\n$$\\end{pmatrix}$$\nc. $$\\begin{pmatrix} 0 & 0 & -1 & -1 \\\\ 0 & 1 & 0 & 3$$\n$$\\\\ 1 & 0 & 0 & 2 \\\\ 0 & 0 & 0 & 1$$\n$$\\end{pmatrix}$$\nd. $$\\begin{pmatrix} -1 & 0 & 0 & -2 \\\\ 0 & 1 & 0 & 3 \\\\ 0 & 0 & -1 & -1 \\\\ 0 & 0 & 0 & 1$$\n$$\\end{pmatrix}$$\ne. $$\\begin{pmatrix} 0 & 0 & 1 & 1 \\\\ 0 & 1 & 0 & 3 \\\\ -1 & 0 & 0 & -2 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}$$",
        "answer": "The correct answer is:\n$$\\begin{pmatrix} 0 & 0 & 1 & 1 \\\\ 0 & 1 & 0 & 3 \\\\ -1 & 0 & 0 & -2 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b11",
        "question": "Given is a triangle with the vertices\n$$A = \\begin{pmatrix} 4 \\\\ 0 \\\\ 0  \\end{pmatrix}, \\mbox{   } B = \\begin{pmatrix} -1 \\\\ 0 \\\\ 0  \\end{pmatrix}, \\mbox{   }C = \\begin{pmatrix} 0 \\\\ 2 \\\\ 0  \\end{pmatrix}$$\nThe RGB colours at these three points are\n$$C_A=(0.0, 0.0, 1.0), \\mbox{   }C_B=(0.6, 0.4, 0.2), \\mbox{   }C_C=(0.5, 1.0, 0.0)$$\n.\nIf the triangle is rendered using OpenGL, what is the colour at the point\n$$P = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0  \\end{pmatrix}?$$\nTip: Make yourself an illustration. Note that the triangle lies on the xy-plane. You should be able to determine the weighting factors for the colour interpolation using your illustration, without doing any complex calculations.\nSelect one:\na. C_P=(0.49, 0.66, 0.18)\nb. C_P=(0.45, 0.7, 0.15)\nc. C_P=(0.55, 0.69, 0.2)\nd. C_P=(0.5, 0.6, 0.15)\ne. C_P=(0.52, 0.65, 0.17)",
        "answer": "The correct answer is:\nC_P=(0.49, 0.66, 0.18)",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b12a",
        "question": "Given is the following texture image:\nImage description: The image shows a 4x4 grid of colours. From left to right, then top to bottom, the colours are red, light green, dark blue, brown, yellow, purple, cyan, dark orange, pink, white, lime, grey, black, light blue, light orange, dark green.\nWhat texture coordinates do we need to specify if we want to use this texture image to create the textured triangle shown below?\nImage description: The image shows a shifted version of the base image, with the bottom left corner being the top left corner of the pink tile, the bottom right corner being the bottom right corner of the light orange tile, and the top right corner being the top right corner of the dark blue tile.\nSelect one:\na. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.5)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)\nb. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.0)\nTexture coordinates for the bottom-right vertex of the triangle: (1.0, 0.0)\nTexture coordinates for the top vertex of the triangle: (1.0, 1.0)\nc. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.0)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)\nd. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.75)\nTexture coordinates for the bottom-right vertex of the triangle: (0.5, 0.5)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)\ne. Texture coordinates for the bottom-left vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 1.0)\nTexture coordinates for the top vertex of the triangle: (0.0, 0.5)",
        "answer": "The correct answer is: Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.5)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b12b",
        "question": "Given is the following texture image:\nImage description: The image shows a 4x4 grid of colours.\nWhat texture coordinates do we need to specify if we want to use this texture image to create the textured triangle shown below?\nImage description: The image shows a shifted version of the base image. Using grid coordinates from the base image, where the bottom left corner of the base image is (0, 0) and the top right corner of the base image is (4, 4), then the bottom left corner is (0, 2), the bottom right corner is (3, 0), and the top right corner is (3, 4).\nSelect one:\na. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.5)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)\nb. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.0)\nTexture coordinates for the bottom-right vertex of the triangle: (1.0, 0.0)\nTexture coordinates for the top vertex of the triangle: (1.0, 1.0)\nc. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.0)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)\nd. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.75)\nTexture coordinates for the bottom-right vertex of the triangle: (0.5, 0.5)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)\ne. Texture coordinates for the bottom-left vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 1.0)\nTexture coordinates for the top vertex of the triangle: (0.0, 0.5)",
        "answer": "The correct answer is: Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.5)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b13a",
        "question": "Image description: The image shows the base texture, a shape to be textured, and the resulting textured shape. The base texture is the picture of a mountain, the shape to be texture is made up from three shapes: a rectangle with vertices P1, P2, P5, P3 counterclockwise, where P1 is the bottom left corner of the whole shape, the width of the rectangle is 2, and the height of the rectangle is 0.5; a rectangle with vertices P6, P8, P10, P9 counterwise, where P10 is the top right corner of the whole shape, the width of the rectangle is 2, and the height of the rectangle is 0.5; a square with vertices P4, P5, P7, P6 counterwise, where the center of the shape aligns with the center of the whole shape, the width of the square is 1. The resulting textured shape is the same as the shape to be textured, but with the base texture mapped onto it, repeated 3 times horizontally and 2 times vertically.\nSelect one:\na. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (4, 0)\nTexture coordinate for P3: (0, 1)\nTexture coordinate for P4: (2, 1)\nTexture coordinate for P5: (4, 1)\nTexture coordinate for P6: (2, 3)\nTexture coordinate for P7: (4, 3)\nTexture coordinate for P8: (6, 3)\nTexture coordinate for P9: (2, 4)\nTexture coordinate for P10: (6, 4)\nb. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (2, 0)\nTexture coordinate for P3: (0, 0.5)\nTexture coordinate for P4: (1, 0.5)\nTexture coordinate for P5: (2, 0.5)\nTexture coordinate for P6: (1, 1.5)\nTexture coordinate for P7: (2, 1.5)\nTexture coordinate for P8: (3, 1.5)\nTexture coordinate for P9: (1, 2)\nTexture coordinate for P10: (3, 2)\nc. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (2, 0)\nTexture coordinate for P3: (0, 1)\nTexture coordinate for P4: (2, 1)\nTexture coordinate for P5: (4, 1)\nTexture coordinate for P6: (2, 2)\nTexture coordinate for P7: (4, 2)\nTexture coordinate for P8: (6, 2)\nTexture coordinate for P9: (2, 3)\nTexture coordinate for P10: (6, 3)\nd. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (4, 0)\nTexture coordinate for P3: (0, 0.5)\nTexture coordinate for P4: (2, 0.5)\nTexture coordinate for P5: (4, 0.5)\nTexture coordinate for P6: (2, 1.5)\nTexture coordinate for P7: (4, 1.5)\nTexture coordinate for P8: (6, 1.5)\nTexture coordinate for P9: (2, 2)\nTexture coordinate for P10: (6, 2)\ne. None of the others.",
        "answer": "The correct answer is: Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (2, 0)\nTexture coordinate for P3: (0, 0.5)\nTexture coordinate for P4: (1, 0.5)\nTexture coordinate for P5: (2, 0.5)\nTexture coordinate for P6: (1, 1.5)\nTexture coordinate for P7: (2, 1.5)\nTexture coordinate for P8: (3, 1.5)\nTexture coordinate for P9: (1, 2)\nTexture coordinate for P10: (3, 2)",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b13b",
        "question": "Image description: The image shows the base texture, a shape to be textured, and the resulting textured shape. The base texture is the picture of a mountain, the shape to be texture is made up from three shapes: a rectangle with vertices P1, P2, P5, P3 counterclockwise, where P1 is the bottom left corner of the whole shape, the width of the rectangle is 2, and the height of the rectangle is 0.5; a rectangle with vertices P6, P8, P10, P9 counterwise, where P10 is the top right corner of the whole shape, the width of the rectangle is 2, and the height of the rectangle is 0.5; a square with vertices P4, P5, P7, P6 counterwise, where the center of the shape aligns with the center of the whole shape, the width of the square is 1. The resulting textured shape is the same as the shape to be textured, but with the base texture mapped onto it, repeated 3 times horizontally and 2 times vertically. The bottom left corner of the base texture is mapped to the bottom left corner of the shape to be textured, and the top right corner of the base texture is mapped to the top right corner of the shape to be textured. The base texture has not been shapeshifted, only cropped.\nSelect one:\na. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (4, 0)\nTexture coordinate for P3: (0, 1)\nTexture coordinate for P4: (2, 1)\nTexture coordinate for P5: (4, 1)\nTexture coordinate for P6: (2, 3)\nTexture coordinate for P7: (4, 3)\nTexture coordinate for P8: (6, 3)\nTexture coordinate for P9: (2, 4)\nTexture coordinate for P10: (6, 4)\nb. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (2, 0)\nTexture coordinate for P3: (0, 0.5)\nTexture coordinate for P4: (1, 0.5)\nTexture coordinate for P5: (2, 0.5)\nTexture coordinate for P6: (1, 1.5)\nTexture coordinate for P7: (2, 1.5)\nTexture coordinate for P8: (3, 1.5)\nTexture coordinate for P9: (1, 2)\nTexture coordinate for P10: (3, 2)\nc. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (2, 0)\nTexture coordinate for P3: (0, 1)\nTexture coordinate for P4: (2, 1)\nTexture coordinate for P5: (4, 1)\nTexture coordinate for P6: (2, 2)\nTexture coordinate for P7: (4, 2)\nTexture coordinate for P8: (6, 2)\nTexture coordinate for P9: (2, 3)\nTexture coordinate for P10: (6, 3)\nd. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (4, 0)\nTexture coordinate for P3: (0, 0.5)\nTexture coordinate for P4: (2, 0.5)\nTexture coordinate for P5: (4, 0.5)\nTexture coordinate for P6: (2, 1.5)\nTexture coordinate for P7: (4, 1.5)\nTexture coordinate for P8: (6, 1.5)\nTexture coordinate for P9: (2, 2)\nTexture coordinate for P10: (6, 2)\ne. None of the others.",
        "answer": "The correct answer is: Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (2, 0)\nTexture coordinate for P3: (0, 0.5)\nTexture coordinate for P4: (1, 0.5)\nTexture coordinate for P5: (2, 0.5)\nTexture coordinate for P6: (1, 1.5)\nTexture coordinate for P7: (2, 1.5)\nTexture coordinate for P8: (3, 1.5)\nTexture coordinate for P9: (1, 2)\nTexture coordinate for P10: (3, 2)",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b14",
        "question": "An object is defined with respect to the xyz (world) coordinate system. What OpenGL command can be used to to align that object with a new uvn-coordinate system sharing the same origin and with the unit vectors: \n$$u = \\begin{pmatrix} -1 \\\\ 0 \\\\ 0  \\end{pmatrix}, \\mbox{    }  v = \\begin{pmatrix} 0 \\\\ -1 \\\\ 0  \\end{pmatrix}, \\mbox{    } n = \\begin{pmatrix} 0 \\\\ 0 \\\\ -1  \\end{pmatrix} \\mbox{  }?$$\na. glRotatef(180, -1, -1, -1)\nb. glRotatef(180, 0, 0, 1)\nc. glScalef(-1, -1, -1)\nd. glTranslatef(-1, -1, -1)\ne. glRotatef(180, 1, 1, 1)",
        "answer": "The correct answer is: glScalef(-1, -1, -1)",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b15",
        "question": "Given is a quadratic spline with the power basis\n$$T=\\begin{pmatrix} t^2 & t & 1\\end{pmatrix}$$\nand the basis matrix:\n$$\\begin{pmatrix} 1 & -2 & 1 \\\\ -2 & 2 & 0 \\\\ 1 & 0 & 0 \\end{pmatrix}$$\nWhich statement about the resulting basis functions B_1(t), B_2(t), and B_3(t) is true?\nSelect one:\na. B_1(t)=-2*t^2+1\nb. The sum of the three basis functions is always 0.\nc. The basis functions are all cubic.\nd. The basis functions are the basis functions of a quadratic Bezier curve.\ne. B_3(1)=0",
        "answer": "The correct answer is: The basis functions are the basis functions of a quadratic Bezier curve.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b16a",
        "question": "Given is a profile curve c(t)=(x(t), 0, z(t)), 0 \u2264 t \u2264 1, which lies in the xz-plane. The resulting surface-of-revolution is shown in the image below. What is the parametric equation of the profile curve indicated in blue in the image below?\nImage description: A surface of revolution is shown with a blue line on the surface. The blue line connects the points (0, 0, 3) and (3, 0, 2), then (3, 0, 2) and (4, 0, 0).\nSelect one:\n$$a. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 6*t \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+2 \\\\ 0 \\\\ 4*(1-t) \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$b. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 3*t \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} t+3 \\\\ 0 \\\\ 4*(1-t) \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$c. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 6*t \\\\ 0 \\\\ 3-t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+2 \\\\ 0 \\\\ 2-t \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$d. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 3*t \\\\ 0 \\\\ 3-t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} t+3 \\\\ 0 \\\\ 2-t \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$e. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 3*t \\\\ 0 \\\\ 3-0.5*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+1 \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$",
        "answer": "The correct answer is:\n$$c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 6*t \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+2 \\\\ 0 \\\\ 4*(1-t) \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b16b",
        "question": "Given is a profile curve c(t)=(x(t), 0, z(t)), 0 \u2264 t \u2264 1, which lies in the xz-plane. The resulting surface-of-revolution is shown in the image below. What is the parametric equation of the profile curve indicated in blue in the image below?\nImage description: A surface of revolution is shown with its profile curve on the xz-plane. The blue line connects the points (0, 0, 3) and (3, 0, 2), then (3, 0, 2) and (4, 0, 0).\nSelect one:\n$$a. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 6*t \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+2 \\\\ 0 \\\\ 4*(1-t) \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$b. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 3*t \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} t+3 \\\\ 0 \\\\ 4*(1-t) \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$c. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 6*t \\\\ 0 \\\\ 3-t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+2 \\\\ 0 \\\\ 2-t \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$d. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 3*t \\\\ 0 \\\\ 3-t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} t+3 \\\\ 0 \\\\ 2-t \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$e. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 3*t \\\\ 0 \\\\ 3-0.5*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+1 \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$",
        "answer": "The correct answer is:\n$$c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 6*t \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+2 \\\\ 0 \\\\ 4*(1-t) \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b17a",
        "question": "What is the parametric equation of the donut-shaped surface p(t)=(x(s,t), y(s,t), z(s,t)), 0 \u2264 s,t \u2264 1 shown in the image below?\nHint 1: The surface is a surface-of-revolution as discussed in the lecture. The profile curve is an ellipsoid shown in the image below in blue.\nImage description: A donut-shaped surface is shown with a blue line on the surface. The blue line is an ellipse covering three squares in the coordinate system, from (1, 0, 0) to (4, 0, 1).\nSelect one:\na. p(t)=\n$$\\begin{pmatrix} (1.5*cos(2 \\pi t) + 2.5) cos (2 \\pi s) \\\\ (1.5*cos(2 \\pi t) + 2.5) sin (2 \\pi s) \\\\ sin (2 \\pi t) \\end{pmatrix}$$\nb. p(t)=\n$$\\begin{pmatrix} 1.5*cos(2 \\pi t) cos (2 \\pi s) +2.5  \\\\ 1.5*cos(2 \\pi$$\n$$t) sin (2 \\pi s)  \\\\ sin (2 \\pi t) \\end{pmatrix}$$\nc. p(t)=\n$$\\begin{pmatrix} 1.5*cos(2 \\pi t) cos (2 \\pi s) + 2.5  \\\\ 1.5*cos(2 \\pi$$\n$$t) sin (2 \\pi s) +2.5 \\\\ sin (2 \\pi t) \\end{pmatrix}$$\nd. p(t)=\n$$\\begin{pmatrix} 3*cos(2 \\pi t) cos (2 \\pi s) \\\\ cos(2 \\pi$$\n$$t) sin (2 \\pi s) \\\\ sin (2 \\pi s) \\end{pmatrix}$$\ne. p(t)=\n$$\\begin{pmatrix} 3*cos(2 \\pi t) cos (2 \\pi s) + 2.5 \\\\ cos(2 \\pi$$\n$$t) sin (2 \\pi s) \\\\ sin (2 \\pi s) \\end{pmatrix}$$",
        "answer": "The correct answer is:\np(t)=\n$$\\begin{pmatrix} (1.5*cos(2 \\pi t) + 2.5) cos (2 \\pi s) \\\\ (1.5*cos(2 \\pi t) + 2.5) sin (2 \\pi s) \\\\ sin (2 \\pi t) \\end{pmatrix}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b17b",
        "question": "What is the parametric equation of the donut-shaped surface p(t)=(x(s,t), y(s,t), z(s,t)), 0 \u2264 s,t \u2264 1 shown in the image below?\nHint 1: The surface is a surface-of-revolution as discussed in the lecture. The profile curve is an ellipsoid shown in the image below in blue.\nImage description: A donut-shaped surface is shown with its profile curve on the xz-plane. The blue line is an ellipse with the center (2.5, 0, 0.5), width 3, and height 1.\nSelect one:\na. p(t)=\n$$\\begin{pmatrix} (1.5*cos(2 \\pi t) + 2.5) cos (2 \\pi s) \\\\ (1.5*cos(2 \\pi t) + 2.5) sin (2 \\pi s) \\\\ sin (2 \\pi t) \\end{pmatrix}$$\nb. p(t)=\n$$\\begin{pmatrix} 1.5*cos(2 \\pi t) cos (2 \\pi s) +2.5  \\\\ 1.5*cos(2 \\pi$$\n$$t) sin (2 \\pi s)  \\\\ sin (2 \\pi t) \\end{pmatrix}$$\nc. p(t)=\n$$\\begin{pmatrix} 1.5*cos(2 \\pi t) cos (2 \\pi s) + 2.5  \\\\ 1.5*cos(2 \\pi$$\n$$t) sin (2 \\pi s) +2.5 \\\\ sin (2 \\pi t) \\end{pmatrix}$$\nd. p(t)=\n$$\\begin{pmatrix} 3*cos(2 \\pi t) cos (2 \\pi s) \\\\ cos(2 \\pi$$\n$$t) sin (2 \\pi s) \\\\ sin (2 \\pi s) \\end{pmatrix}$$\ne. p(t)=\n$$\\begin{pmatrix} 3*cos(2 \\pi t) cos (2 \\pi s) + 2.5 \\\\ cos(2 \\pi$$\n$$t) sin (2 \\pi s) \\\\ sin (2 \\pi s) \\end{pmatrix}$$",
        "answer": "The correct answer is:\np(t)=\n$$\\begin{pmatrix} (1.5*cos(2 \\pi t) + 2.5) cos (2 \\pi s) \\\\ (1.5*cos(2 \\pi t) + 2.5) sin (2 \\pi s) \\\\ sin (2 \\pi t) \\end{pmatrix}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b18",
        "question": "Which of the matrices below is the correct MODEL_VIEW matrix after executing the following OpenGL commands:\nglMatrixMode(GL_MODELVIEW );\nglLoadIdentity();\nglRotatef(-90, 0, 0, 1);\nglTranslatef(2, 0, 1);\nglScalef(1, 3, 2);\na. $$\\begin{pmatrix} 0 & 1 & 0 & 2 \\\\ 3 & 0 & 0 & 0$$\n$$\\\\ 0 & 0 & 2 & 1 \\\\ 0 & 0 & 0 & 1$$\n$$\\end{pmatrix}$$\nb. $$\\begin{pmatrix} 0 & -1 & 0 & 2 \\\\ 3 & 0 & 0 & 0$$\n$$\\\\ 0 & 0 & 2 & 1 \\\\ 0 & 0 & 0 & 1$$\n$$\\end{pmatrix}$$\nc. $$\\begin{pmatrix} 1 & 0 & 0 & 2 \\\\ 0 & 3 & 0 & 0 \\\\ 0 & 0 & 2 & 1 \\\\ 0 & 0 & 0 & 1$$\n$$\\end{pmatrix}$$\nd. $$\\begin{pmatrix} 0 & 1 & 0 & 2 \\\\ -3 & 0 & 0 & 0$$\n$$\\\\ 0 & 0 & 2 & 1 \\\\ 0 & 0 & 0 & 1$$\n$$\\end{pmatrix}$$\ne. $$\\begin{pmatrix} 0 & 3 & 0 & 0 \\\\ -1 & 0 & 0 & -2 \\\\ 0 & 0 & 2 & 1 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}$$",
        "answer": "The correct answer is:\n$$\\begin{pmatrix} 0 & 3 & 0 & 0 \\\\ -1 & 0 & 0 & -2 \\\\ 0 & 0 & 2 & 1 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b19",
        "question": "Given is a uvn-coordinate system with the origin \n$$O_{uvn} = \\begin{pmatrix} 2 \\\\ -1  \\\\ -2 \\end{pmatrix}$$\nand the coordinate axis \n$${\\bf u} = \\begin{pmatrix} -1 \\\\ 0  \\\\ 0 \\end{pmatrix}\\text{ ,  } {\\bf v} = \\begin{pmatrix} 0 \\\\ 0  \\\\ 1 \\end{pmatrix}\\text{  and } {\\bf n} = \\begin{pmatrix} 0 \\\\ -1  \\\\ 0 \\end{pmatrix}$$\nGiven is a point P with the uvn-coordinates \n$${\\bf p}_{uvn} = \\begin{pmatrix} 2 \\\\ 1  \\\\ 3 \\end{pmatrix}$$\n.\nWhat are the xyz-coordinates (world coordinates) of this point?\nSelect one:\na. $$\\begin{pmatrix} -3 \\\\ 1  \\\\ -3 \\end{pmatrix}$$\nb. $$\\begin{pmatrix} 0  \\\\ -4  \\\\ -1 \\end{pmatrix}$$\nc. $$\\begin{pmatrix} -1 \\\\ -3  \\\\ -2 \\end{pmatrix}$$\nd. $$\\begin{pmatrix} -1 \\\\ -2  \\\\ -1 \\end{pmatrix}$$\ne. $$\\begin{pmatrix} 1 \\\\ -3  \\\\ -5 \\end{pmatrix}$$",
        "answer": "The correct answer is:\n$$\\begin{pmatrix} 0  \\\\ -4  \\\\ -1 \\end{pmatrix}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b20a",
        "question": "A plane n.p=d defines a half-space, where the half space are all points where n.p<=d.\nFor example, for the plane x=0 the half space are all points with an x-coordinate <=0.\nUsing this definition we can now define a \"cut-sphere\" as the intersection of a sphere S and a half-space defined by the plane P. I.e., the \"cut-sphere\" contains all points which are inside the sphere and inside the half-space defined by P. The image below shows an example.\nImage description: The image shows a sphere shown in red with a chunk cut off, in front of a blue and green background. Some shadows of the object are cast on the ground.\nWhich of the statements below about the ray intersection with a \"cut-sphere\" (defined by a sphere S and a plane P) is false?\nNOTE: You can assume that the \"cut-sphere\" is in front of the eye point.\nSelect one:\na. If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P and the sphere S AND the intersection parameter with the plane P is between the two intersection parameters with the sphere S, then the intersection point with the \"cut-sphere\" is equal to the first intersection point with the sphere S.\nb. If the dot product of the ray direction and the normal of P is positive AND the ray intersects the plane P before it intersects the sphere S, then the \"cut-sphere\" object does not exist (i.e., the intersection of the sphere and half-space is empty).\nc. If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P before it intersects the sphere S, then the \"cut-sphere\" object is equal to the sphere S (i.e., the intersection of the sphere and half-space is the sphere and nothing gets cut off.).\nd. The surface normal of a cut-sphere is either the normal of the sphere S or the normal of the plane P dependent on where the ray intersects the \"cut-sphere\" first.\ne. If the dot product of the ray direction and the normal of P is positive AND the ray intersects the plane P after it intersects the sphere S, then the intersection point with the \"cut-sphere\" is given by the intersection point with the sphere S.",
        "answer": "The correct answer is: If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P and the sphere S AND the intersection parameter with the plane P is between the two intersection parameters with the sphere S, then the intersection point with the \"cut-sphere\" is equal to the first intersection point with the sphere S.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b20b",
        "question": "A plane n.p=d defines a half-space, where the half space are all points where n.p<=d.\nFor example, for the plane x=0 the half space are all points with an x-coordinate <=0.\nUsing this definition we can now define a \"cut-sphere\" as the intersection of a sphere S and a half-space defined by the plane P. I.e., the \"cut-sphere\" contains all points which are inside the sphere and inside the half-space defined by P. The image below shows an example.\nImage description: The image shows a spherical cap, or a sphere with a portion cut off. The cut portion of the sphere is not shown, and the background behind that portion is shown, since light would past through the cut portion of the sphere.\nWhich of the statements below about the ray intersection with a \"cut-sphere\" (defined by a sphere S and a plane P) is false?\nNOTE: You can assume that the \"cut-sphere\" is in front of the eye point.\nSelect one:\na. If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P and the sphere S AND the intersection parameter with the plane P is between the two intersection parameters with the sphere S, then the intersection point with the \"cut-sphere\" is equal to the first intersection point with the sphere S.\nb. If the dot product of the ray direction and the normal of P is positive AND the ray intersects the plane P before it intersects the sphere S, then the \"cut-sphere\" object does not exist (i.e., the intersection of the sphere and half-space is empty).\nc. If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P before it intersects the sphere S, then the \"cut-sphere\" object is equal to the sphere S (i.e., the intersection of the sphere and half-space is the sphere and nothing gets cut off.).\nd. The surface normal of a cut-sphere is either the normal of the sphere S or the normal of the plane P dependent on where the ray intersects the \"cut-sphere\" first.\ne. If the dot product of the ray direction and the normal of P is positive AND the ray intersects the plane P after it intersects the sphere S, then the intersection point with the \"cut-sphere\" is given by the intersection point with the sphere S.",
        "answer": "The correct answer is: If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P and the sphere S AND the intersection parameter with the plane P is between the two intersection parameters with the sphere S, then the intersection point with the \"cut-sphere\" is equal to the first intersection point with the sphere S.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b21",
        "question": "Consider the 5x5 grayscale image, J, defined by the grid lattice below. Given also, is the a 3x3 Gaussian Kernel, K.\nWhat is the resulting value at pixel location (2,2) of the image obtained by applying Gaussian Kernel K, to image J?\nImage J:\n4\t8\t8\t8\t8\t8\n3\t16\t16\t16\t16\t16\n2\t48\t48\t48\t48\t48\n1\t32\t32\t32\t32\t32\n0\t8\t8\t8\t8\t8\n        0\t1\t2\t3\t4\nGaussian Kernel K:\n2\t1/16\t1/8\t1/16\n1\t1/8\t1/4\t1/8\n0\t1/16\t1/8\t1/16\n        0\t1\t2\nNote: Do not process all pixels that are within a 1 pixel border around the image.\nSelect one:\na. None of the others\nb. 40\nc. 36\nd. 32\ne. 28",
        "answer": "The correct answer is: 36",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b22",
        "question": "Consider the 4x4 binary image, J, defined by the grid lattice below. Given also, is the square-like 3x3 structuring element,S, which contains all \"1\"-value pixels and has the origin at the center (1,1). The horizontal is x axis and the vertical is y axis. Each pixel location is denoted as (x,y) of position index.\nUse \"Padding 0\" (Extending border values outside with zeros).\nWhat is the resulting value at pixel location (3, 2) of the image obtained after performing a binary dilation of image J with structuring element S?\nImage J:\n3\t1\t0\t1\t0\n2\t0\t1\t0\t0\n1\t1\t0\t1\t0\n0\t1\t0\t0\t1\n        0\t1\t2\t3\nStructuring Element S\n2\t1\t1\t1\n1\t1\t1\t1\n0\t1\t1\t1\n        0\t1\t2\nSelect one:\na. 1\nb. None of the others\nc. 0\nd. 2\ne. Undefined",
        "answer": "The correct answer is: 1",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b23",
        "question": "Consider the 4x4 table representing the greyscale (8-bit) image J below. What is the image value at the pixel location (x=0, y=2) after performing the histogram equalization? The image value has to be rounded to the nearest integer.\n3\t16\t64\t32\t8\n2\t16\t16\t16\t16\n1\t64\t16\t16\t8\n0\t16\t8\t32\t64\n        0\t1\t2\t3\nThe bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.\nSelect one:\na. None of the others\nb. 157\nc. 128\nd. 16\ne. 136",
        "answer": "The correct answer is: 157",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b24",
        "question": "Consider the 4x4 table representing the greyscale image J below. What is the pixel value for the cumulative histogram count of 11?\n3\t8\t4\t16\t16\n2\t32\t32\t32\t8\n1\t0\t0\t128\t8\n0\t8\t255\t16\t8\n        0\t1\t2\t3\nThe bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.\nSelect one:\na. 0\nb. 3\nc. 4\nd. None of the others\ne. 16",
        "answer": "The correct answer is: 16",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b25",
        "question": "Consider the 5x5 binary image, J, defined by the grid lattice below. Given also, is the cross-like 3x3 structuring element,S, which contains \"1\"-value pixels except at the corners and has the origin at the center (1,1).\nWhat is the value at pixel location (2,2) of the morphological gradient of image J with structuring element S?\nImage J:\n4\t0\t0\t0\t0\t0\n3\t0\t0\t1\t0\t0\n2\t0\t1\t1\t1\t0\n1\t0\t0\t1\t0\t0\n0\t0\t0\t0\t0\t0\n        0\t1\t2\t3\t4\t\nStructuring Element S:\n2\t0\t1\t0\n1\t1\t1\t1\n0\t0\t1\t0\n        0\t1\t2\nNote: Do not process all pixels that are within a 1 pixel border around the image.\nSelect one:\na. 0\nb. Undefined\nc. 2\nd. 1\ne. None of the others",
        "answer": "The correct answer is: 0",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b26",
        "question": "Consider the greyscale image J defined below What will be the threshold (rounded to the nearest integer) computed after running three iterations of the adaptive threshold technique as described in class?\n3\t128\t16\t64\t16\n2\t128\t32\t32\t16\n1\t128\t128\t8\t128\n0\t8\t8\t16\t64\n        0\t1\t2\t3\nThe bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.\nSelect one:\na. 63\nb. 73\nc. 56\nd. 58\ne. 68",
        "answer": "The correct answer is: 63",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b27",
        "question": "Consider the 4x4 table representing the grayscale image J below. What is the result when a 3x3 median filter is applied? For boundary handling, use BoundaryPaddingZero.\n3\t0\t8\t16\t64\n2\t8\t16\t32\t64\n1\t16\t32\t64\t128\n0\t64\t64\t128\t128\n        0\t1\t2\t3\nThe bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.\nWhat is the value of median filtered image at x=0, y=3?\nWhat is the value of median filtered image at x=2, y=1?\nWhat is the value of median filtered image at x=3, y=1?",
        "answer": "The correct answer is: 0, 64, 64",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b28",
        "question": "Which coefficients of the linear mapping operation, g(x,y)=af(x,y) + b, will map the pixel value f(x,y)=75 to g(x,y)=88 and pixel value f(x,y)=155 to g(x,y)=216?\nWhich effect does this linear mapping operation defined by a and b have, when applied to an image?",
        "answer": "The correct answer is: a is 1.6 and b is -32, contrast is increased and brightness is decreased",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b29",
        "question": "Consider the 4x4 table representing the greyscale (8-bit) image J below. Compute the effect of a logarithmic contrast stretching on the image, which aims to increase the dynamic range of darker regions in the image.\nThe logarithmic contrast stretching operation transforms the input image J(x,y) pixelwise to an output image G(x,y) according to the equation:\n$$G(x,y) = \\frac{log(1+J(x,y))}{log(1 + Q)}$$\nHere Q is the maximal greyvalue of the greyscale range of the input image.\nThe logarithmic function is applied to each input pixel of the 8 bit input range, and generates an output in the range between 0 and 1. You finally have to transform this output range to the same (8-bit) range that the input image has. Round to the nearest integer.\nAfter computation of G, what is the pixel value of the final resulting image at the pixel location (x=1, y=0)?\n3\t8\t8       8       8\n2\t16      4       4       16\n1\t32      128\t255     32\n0\t16\t64\t64      16\n        0\t1\t2\t3\nThe bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.\nSelect one:\na. 101\nb. None of the others.\nc. 161\nd. 223\ne. 255\nf. 192\ng. 130\nh. 74",
        "answer": "The correct answer is: 192",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b30a",
        "question": "Given is an RGB colour cube with side length 2 as illustrated in the image below\"\nImage description: The image shows a RGB colour cube with side length 2. The colours shown are green, cyan, blue, pink, red, and yellow in counterclockwise order, where red is on the x-axis.\nPlease write OpenGL code to transform the cube as shown in the image below. The cube should be scaled by 2 in z-direction, the face with the black, green, blue and cyan vertex should form an angle of 70 degree with the yz-plane, and the edge from black to blue should be parallel to the z-axis with a distance of 2 and should lie on the yz-plane.\nImage description: The image shows the RGB colour cube, but transformed as described above.\nIMPORTANT:\nPlease only use OpenGL transformations, e.g. glTranslatef, glRotatef\nPlease do NOT draw the cube itself - this is done automatically by the uploaded code",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b30b",
        "question": "Given is an RGB colour cube with side length 2 as illustrated in the image below\"\nImage description: The image shows a RGB colour cube with side length 2. The point representing white is on (2, 2, 2), the point representing blue is on (0, 0, 2), and the point representing red is on (2, 0, 0).\nPlease write OpenGL code to transform the cube as shown in the image below. The cube should be scaled by 2 in z-direction, the face with the black, green, blue and cyan vertex should form an angle of 70 degree with the yz-plane, and the edge from black to blue should be parallel to the z-axis with a distance of 2 and should lie on the yz-plane.\nImage description: The image shows the RGB colour cube, but transformed as described above.\nIMPORTANT:\nPlease only use OpenGL transformations, e.g. glTranslatef, glRotatef\nPlease do NOT draw the cube itself - this is done automatically by the uploaded code",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b31a",
        "question": "Given is a function drawTorus() which draws a torus with colored \"blobs\" centred at the origin and aligned with the z-axis as shown in the image below.\nImage description: The image shows a torus centered at the origin and aligned with z-axis. The torus is coloured with green, blue, yellow, and pink in counterclockwise order, where green is on the x-axis.\nPlease write OpenGL code to render the two tori displayed in the image below:\nImage description: The image shows two tori. The first torus is centered at the (1, 1, 0), with yellow, pink, green, and blue in counterclockwise order, where yellow is on the y-axis. The second torus is centered at (0, 1, 1), with green, blue, yellow, and pink in counterclockwise order, where yellow is on the y-axis.\nNote that the first torus lies on the xy-plane with centre (1, 1, 0), and the second  torus lies on the yz-plane with centre (0, 1, 1).\nIMPORTANT:\nYour code must draw the tori in the order described above. Your code should have the format:\n<insert your transformations>\ndrawTorus();\n<insert your transformations>\ndrawTorus();\nNote: transformations refers to OpenGL transformations, e.g. glRotatef, glTranslatef, glScalef, glPushMatrix and glPopMatrix",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b31b",
        "question": "Given is a function drawTorus() which draws a torus with colored \"blobs\" centred at the origin and aligned with the z-axis as shown in the image below.\nImage description: The image shows a torus centered at the origin and on the x-y plane. The torus is coloured with green, blue, yellow, and pink in counterclockwise order, where green is on the x-axis.\nPlease write OpenGL code to render the two tori displayed in the image below:\nImage description: The image shows two tori. The first torus is centered at the (1, 1, 0) and on the x-y plane, with yellow, pink, green, and blue in counterclockwise order, where yellow is on the y-axis. The second torus is centered at (0, 1, 1) and on the y-z plane, with green, blue, yellow, and pink in counterclockwise order, where yellow is on the y-axis.\nNote that the first torus lies on the xy-plane with centre (1, 1, 0), and the second  torus lies on the yz-plane with centre (0, 1, 1).\nIMPORTANT:\nYour code must draw the tori in the order described above. Your code should have the format:\n<insert your transformations>\ndrawTorus();\n<insert your transformations>\ndrawTorus();\nNote: transformations refers to OpenGL transformations, e.g. glRotatef, glTranslatef, glScalef, glPushMatrix and glPopMatrix",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b32a",
        "question": "Write a function animateBouncyBall(), which takes as parameters the position p of a ball and its velocity v and a plane in dot-normal form given by n (unit normal) and d. The function updates the ball's position and velocity for one animation step. Your function should have the following signature:\nvoid animateBouncyBall(Vector3& p, Vector3& v, Vector3& n, double& d)\nNote: The \"&\" symbol represents a reference variable, i.e., any change to this variable will be visible outside the function. You can use it like a normal variable of type Vector3.\nYou can assume that the ball's position p is initially on the outside of the plane (the side the normal points to). Your function should update p such that its new value is p+v and the velocity v stays unchanged. However, if the new point p+v is on the other side of the plane, then you must reflect the vector v on the plane and the new velocity is v_reflected and the new point is p+v_reflected.\nNote: You can ignore that the point p is not exactly on the plane when reflected.\nThe image below illustrates how the position and velocity of the ball change if the function animateBouncyBall() is called multiple times.\nImage description: The image shows a line in a coordinate system, and a ball travelling towards the line, after it makes contact with the plane it is reflected to a different direction.\nYou can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z, and that the following functions are available to you:\ndouble dot(Vector3 u, Vector3 v) //dot product\nVector3 cross(Vector3 u, Vector3 v) //cross product\nYou can assume that the Vector3 class has the following member functions available to you:\nVector3 Vector3.normalized() //returns a vector pointing in the same direction with length 1\ndouble Vector3.magnitude() //returns the length of the vector\nYou can assume that the Vector3 class supports the following operators returning an object of type Vector3:\nVector3 + Vector3\nVector3 - Vector3\nVector3 * double // Note: the order is important, the scalar has to come after the vector when multiplying\nFor example:\nTest1\nVector3 n=Vector3(1, 0, 0); // plane unit normal\ndouble d=0;                 // plane distance from origin\nVector3 p = Vector3(0.5, 0.0, 0.0);\nVector3 v = Vector3(-0.2, 0.0, 0.0);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nResult1\nposition=(0.50,0.00,0.00) velocity=(-0.20,0.00,0.00)\nposition=(0.30,0.00,0.00) velocity=(-0.20,0.00,0.00)\nposition=(0.10,0.00,0.00) velocity=(-0.20,0.00,0.00)\nposition=(0.30,0.00,0.00) velocity=(0.20,0.00,0.00)\nposition=(0.50,0.00,0.00) velocity=(0.20,0.00,0.00)",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b32b",
        "question": "Write a function animateBouncyBall(), which takes as parameters the position p of a ball and its velocity v and a plane in dot-normal form given by n (unit normal) and d. The function updates the ball's position and velocity for one animation step. Your function should have the following signature:\nvoid animateBouncyBall(Vector3& p, Vector3& v, Vector3& n, double& d)\nNote: The \"&\" symbol represents a reference variable, i.e., any change to this variable will be visible outside the function. You can use it like a normal variable of type Vector3.\nYou can assume that the ball's position p is initially on the outside of the plane (the side the normal points to). Your function should update p such that its new value is p+v and the velocity v stays unchanged. However, if the new point p+v is on the other side of the plane, then you must reflect the vector v on the plane and the new velocity is v_reflected and the new point is p+v_reflected.\nNote: You can ignore that the point p is not exactly on the plane when reflected.\nThe image below illustrates how the position and velocity of the ball change if the function animateBouncyBall() is called multiple times.\nImage description: The image shows a line in a coordinate system, and a ball travelling towards the line, and the direction is denoted as v, after it makes contact with the plane it is reflected to a different direction, denoted as v_reflected. The normal of the reflection is denoted as n. The angle of incidence is equal to the angle of reflection.\nYou can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z, and that the following functions are available to you:\ndouble dot(Vector3 u, Vector3 v) //dot product\nVector3 cross(Vector3 u, Vector3 v) //cross product\nYou can assume that the Vector3 class has the following member functions available to you:\nVector3 Vector3.normalized() //returns a vector pointing in the same direction with length 1\ndouble Vector3.magnitude() //returns the length of the vector\nYou can assume that the Vector3 class supports the following operators returning an object of type Vector3:\nVector3 + Vector3\nVector3 - Vector3\nVector3 * double // Note: the order is important, the scalar has to come after the vector when multiplying\nFor example:\nTest1\nVector3 n=Vector3(1, 0, 0); // plane unit normal\ndouble d=0;                 // plane distance from origin\nVector3 p = Vector3(0.5, 0.0, 0.0);\nVector3 v = Vector3(-0.2, 0.0, 0.0);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nResult1\nposition=(0.50,0.00,0.00) velocity=(-0.20,0.00,0.00)\nposition=(0.30,0.00,0.00) velocity=(-0.20,0.00,0.00)\nposition=(0.10,0.00,0.00) velocity=(-0.20,0.00,0.00)\nposition=(0.30,0.00,0.00) velocity=(0.20,0.00,0.00)\nposition=(0.50,0.00,0.00) velocity=(0.20,0.00,0.00)",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b33a",
        "question": "In this question we want to create the front and right side of the texture mapped muesli box shown in the image below:\nImage description: The image shows a muesli box in a 3D coordinate system.\nThe 3D model uses a quadstrip for the front and right side and a quadrilateral for the top side, which are textured using the texture image below. Note that the sections of the texture image used for the front and right side of the box are rectangular (illustrated in green in the image below) and the section of the texture image used for the top side of the box is a trapezoid (illustrated in blue in the image below).\nImage description: The image shows a flat texture image of a muesli box, the texture coordinates of the front are (0.12, 0.12), (0.49, 0.12), (0.49, 0.88), and (0.12, 0.88); those of the right are (0.49, 0.12), (0.62, 0.12), (0.62, 0.88), and (0.49, 0.88); and those of the top are (0.12, 0.88), (0.49, 0.88), (0.47, 0.99), and (0.14, 0.99).\nPlease only use the texture coordinates indicated in the image above in order to define the missing values for s1, s2, s3, s4, s5 and t1, t2, t3 in the code shown in the answer box. Please do not change anything else.\nTemplate code:\ns1 = 0;  // please replace with the correct texture coordinate \ns2 = 0;  // please replace with the correct texture coordinate  \ns3 = 0;  // please replace with the correct texture coordinate \ns4 = 0;  // please replace with the correct texture coordinate \ns5 = 0;  // please replace with the correct texture coordinate \nt1 = 0;  // please replace with the correct texture coordinate  \nt2 = 0;  // please replace with the correct texture coordinate \nt3 = 0;  // please replace with the correct texture coordinate \n// front and right face face\nglBegin(GL_QUAD_STRIP);\nglTexCoord2f(s1, t1);\nglVertex3f(0, 0, 0.7);\nglTexCoord2f(s1, t2);\nglVertex3f(0, 4, 0.7);\nglTexCoord2f(s2, t1);\nglVertex3f(2, 0, 0.7);\nglTexCoord2f(s2, t2);\nglVertex3f(2, 4, 0.7);\nglTexCoord2f(s3, t1);\nglVertex3f(2, 0, 0);\nglTexCoord2f(s3, t2);\nglVertex3f(2, 4, 0);\nglEnd();\n// top face\nglBegin(GL_QUADS);\nglTexCoord2f(s1, t2);\nglVertex3f(0, 4, 0.7);\nglTexCoord2f(s2, t2);\nglVertex3f(2, 4, 0.7);\nglTexCoord2f(s5, t3);\nglVertex3f(2, 4, 0);\nglTexCoord2f(s4, t3);\nglVertex3f(0, 4, 0);\nglEnd();",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b33b",
        "question": "In this question we want to create the front and right side of the texture mapped muesli box shown in the image below:\nImage description: The image shows a cuboid, where the surface is textured like a muesli box, in a 3D coordinate system, with the front, top, and side shown.\nThe 3D model uses a quadstrip for the front and right side and a quadrilateral for the top side, which are textured using the texture image below. Note that the sections of the texture image used for the front and right side of the box are rectangular (illustrated in green in the image below) and the section of the texture image used for the top side of the box is a trapezoid (illustrated in blue in the image below).\nImage description: The image shows a flat texture image of an unravelled muesli box, the texture coordinates of the front are (0.12, 0.12), (0.49, 0.12), (0.49, 0.88), and (0.12, 0.88); those of the right are (0.49, 0.12), (0.62, 0.12), (0.62, 0.88), and (0.49, 0.88); and those of the top are (0.12, 0.88), (0.49, 0.88), (0.47, 0.99), and (0.14, 0.99).\nPlease only use the texture coordinates indicated in the image above in order to define the missing values for s1, s2, s3, s4, s5 and t1, t2, t3 in the code shown in the answer box. Please do not change anything else.\nTemplate code:\ns1 = 0;  // please replace with the correct texture coordinate \ns2 = 0;  // please replace with the correct texture coordinate  \ns3 = 0;  // please replace with the correct texture coordinate \ns4 = 0;  // please replace with the correct texture coordinate \ns5 = 0;  // please replace with the correct texture coordinate \nt1 = 0;  // please replace with the correct texture coordinate  \nt2 = 0;  // please replace with the correct texture coordinate \nt3 = 0;  // please replace with the correct texture coordinate \n// front and right face face\nglBegin(GL_QUAD_STRIP);\nglTexCoord2f(s1, t1);\nglVertex3f(0, 0, 0.7);\nglTexCoord2f(s1, t2);\nglVertex3f(0, 4, 0.7);\nglTexCoord2f(s2, t1);\nglVertex3f(2, 0, 0.7);\nglTexCoord2f(s2, t2);\nglVertex3f(2, 4, 0.7);\nglTexCoord2f(s3, t1);\nglVertex3f(2, 0, 0);\nglTexCoord2f(s3, t2);\nglVertex3f(2, 4, 0);\nglEnd();\n// top face\nglBegin(GL_QUADS);\nglTexCoord2f(s1, t2);\nglVertex3f(0, 4, 0.7);\nglTexCoord2f(s2, t2);\nglVertex3f(2, 4, 0.7);\nglTexCoord2f(s5, t3);\nglVertex3f(2, 4, 0);\nglTexCoord2f(s4, t3);\nglVertex3f(0, 4, 0);\nglEnd();",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b34a",
        "question": "Given is a cubic spline curve c(t)=T M G with the geometric constraint vector\nG=(p0, p1, p2, p3)^T\nThe basis matrix of the spline curve is\n$$\\bf{M}=\\begin{pmatrix} -4.5 & 13.5 & -13.5 & 4.5 \\\\ 9 & -22.5 & 18 & -4.5$$\n$$\\\\ -5.5 & 9 & -4.5 & 1 \\\\ 1 & 0 & 0 & 0 \\end{pmatrix}$$\nThe spline curve is used as profile curve for a surface-of-revolution.\nImplement this curve by defining its basis functions and completing the code fragment below.\nPlease write your answer into the answer space using the following format:\ndouble Basis1(double t){ return <Insert code>;} \ndouble Basis2(double t){ return <Insert code>;}\ndouble Basis3(double t){ return <Insert code>;} \ndouble Basis4(double t){ return <Insert code>;} \nCVec3df curve(float t)\n{\n  // return the curve point c(t) of type CVec3df   \n}\nThe first test case uses the geometric constraints:\nconst CVec3df p0(1, 0, 0);\nconst CVec3df p1(1.6666, 0, 0.2);\nconst CVec3df p2(2.3333, 0, 1.5);\nconst CVec3df p3(3, 0, 1);\nand should result into the image below:\nImage description: A surface of revolution is shown with a blue curve on the surface.\nYou can assume that the CVec3df class supports the following operators returning an object of type CVec3df:\nCVec3df + CVec3df\nCVec3df * double // Note: the order is important, the scalar has to come after the vector when multiplying",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b34b",
        "question": "Given is a cubic spline curve c(t)=T M G with the geometric constraint vector\nG=(p0, p1, p2, p3)^T\nThe basis matrix of the spline curve is\n$$\\bf{M}=\\begin{pmatrix} -4.5 & 13.5 & -13.5 & 4.5 \\\\ 9 & -22.5 & 18 & -4.5$$\n$$\\\\ -5.5 & 9 & -4.5 & 1 \\\\ 1 & 0 & 0 & 0 \\end{pmatrix}$$\nThe spline curve is used as profile curve for a surface-of-revolution.\nImplement this curve by defining its basis functions and completing the code fragment below.\nPlease write your answer into the answer space using the following format:\ndouble Basis1(double t){ return <Insert code>;} \ndouble Basis2(double t){ return <Insert code>;}\ndouble Basis3(double t){ return <Insert code>;} \ndouble Basis4(double t){ return <Insert code>;} \nCVec3df curve(float t)\n{\n  // return the curve point c(t) of type CVec3df   \n}\nThe first test case uses the geometric constraints:\nconst CVec3df p0(1, 0, 0);\nconst CVec3df p1(1.6666, 0, 0.2);\nconst CVec3df p2(2.3333, 0, 1.5);\nconst CVec3df p3(3, 0, 1);\nand should result into the image below:\nImage description: A surface of revolution is shown with a profile curve on the surface. The profile curve is described as the spline curve above.\nYou can assume that the CVec3df class supports the following operators returning an object of type CVec3df:\nCVec3df + CVec3df\nCVec3df * double // Note: the order is important, the scalar has to come after the vector when multiplying",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b35",
        "question": "Given is a function drawCube() which draws a unit cube centered at the origin with coloured dots on its top (see image below). The top front corner has a yellow dot, the top-back corner has a cyan dot and the top-left and top-right corners have grey and magenta dots, respectively.\nPlease write OpenGL code to render a double barrel ball gun as illustrated in the image below. The ball gun consists of a stand (bottom part), a horizontal bar on top of it, and two barrels on the left and right of the horizontal bar. All objects have a square cross section with a width of width. The stand and the barrels have a length of length. The horizontal bar as a length of distance. The barrels form an angle of \u03b8 (theta) with the xz-plane. The rotation axis is the centre line of the horizontal bar. The stand is centred on the y-axis. The whole ball gun is rotated by an angle \u03c6 (phi) around its centre axis.\nIMPORTANT:\nIn order for the automarker to work correctly you:\n(1) must use the function drawCube() to draw each robot arm\n(2) must draw the components in the order explained in the image above on the right: first the stand, then the horizontal bar, then the barrel on the positive z-axis and then the barrel on the negative x-axis.\n(3) must use the variables width, length, distance, phi, and theta, which have different values in the test cases.\n(4) must make sure that the dots at the top of each cube are in the correct positions. If you rotate the cuboids around their axes the object looks the same, but the transformation matrices are different and the automarker will mark it as wrong.\nTip: Start by drawing the stand and the horizontal bar. Rotating the stand will rotate the whole ball gun. In addition to glRotatef, glTranslatef, and glScalef, you might also want to use glPushMatrix() and glPopMatrix().",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b36a",
        "question": "In this exercise you need to complete the function below defining a Ray-CutSphere Intersection:\ndouble CutSphere::Intersect(Vector source, Vector d)\nNOTE: The pre-loaded answer box contains already code for the ray sphere intersection and sorts the intersection points such that t1 is the first intersection point with the original sphere.\nAdd additional code such that the function returns instead the intersection points with the \"cut-sphere\".\nThe cutting plane n.p=a is defined by the variables n (type Vector) and a (type double).\nHINT: Compute the ray-plane intersection and develop an algorithm to decide whether the ray intersects the round (un-cut part) of the sphere, the cutting plane, or doesn't intersect the cut sphere at all (e.g. the ray might pass through the cut-off part of the sphere)\nIMPORTANT: If the ray first intersects the cutting plane of the cut sphere (the flat part of it) then you need to set cuttingPlaneIntersected = true; . This is used in the normal calculation and without the automarker will mark your solution as false.\nNote: The following variables and functions are already defined for you to use:\nThe plane n.p=a is defined by the variables n (type Vector) and a (type double).\nVector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector\nVector: v1-v2 - subtracts v2 from v1 and returns resulting vector\nVector: v1 * t - scales the vector v1 by t and returns resulting vector\nVector v.Scale(float a, float b, float c) - scales each component of the vector v\nfloat v1.Dot(Vector v2) - returns the dot product of vector v1 and v2\nVector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2\nAfter completing the code in the pre-loaded answer box you should get the images below:\nImage description: The image shows a sphere shown in red with a chunk cut off, in front of a blue and green background. Some shadows of the object are cast on the ground.\nImage description: The image shows the cut off chunk placed on the ground, in front of a blue and green background. Some shadows of the object are cast on the ground.\nTemplate code:\ndouble CutSphere::Intersect(Vector source, Vector d)\n{\n\t// A, B, and C are the parameters of quadratic equation for finding the \n\t// ray intersection parameter t (see slide 16 of the \"Ray Tracing\" lecture notes)\n\tfloat A = d.Dot(d);\n\tfloat B = 2 * source.Dot(d);\n\tfloat C = source.Dot(source) - 1;\n\tfloat t; // the parameter t for the closest intersection point or ray with the sphere. If no intersection t=-1.0\n\t// BEGIN SOLUTION RAY-SPHERE INTERSECTION\n\tif (B * B - 4 * A * C <= 0) return t=-1;  // no hit\n\tfloat t1;\n\tif (B > 0)   // for numerical precision\n\t\tt1 = (-B - sqrt(B * B - 4 * A * C)) / (2 * A);\n\telse\n\t\tt1 = (-B + sqrt(B * B - 4 * A * C)) / (2 * A);\n\tfloat t2 = C / (A * t1); // easier way to get t2\n\t// END SOLUTION RAY-SPHERE INTERSECTION\n\t// if t1>t2 swap, so t1 is always first intersection point\n\tfloat temp;\n\tif (t1 > t2) {\n\t\ttemp = t1;\n\t\tt1 = t2;\n\t\tt2 = temp;\n\t}\n\tt = t1;\n\tcuttingPlaneIntersected = false; // variable of type bool - true if ray first intersects the flat part of the cut sphere\n\t// ===================================================================\n\t// == The above method code computes the intersection parameters of ==\n\t// == the ray with the sphere. Add additional code such that the    ==\n\t// == function returns instead the intersections points with the    ==\n\t// == \"cut-sphere\".                                                 ==\n\t// == Tip: Compute the ray-plane interscetion and develop an        ==\n\t// ==      algorithm to decide whether the ray intersected the      ==\n\t// ==      round (un-cut part) of the sphere, the cutting plane,    ==\n\t// ==      or doesn't intersect the cut spere at all (e.g. the ray  ==\n\t// ==      might pass through the cut-off part of the sphere        ==\n    // == IMPORTANT: If the ray first intersects the cutting plane of   ==\n\t// ==            the cut sphere (the flat part of it) then you need ==\n\t// ==            to set cuttingPlaneIntersected = true;             ==\n\t// ==            This is used in the normal calculation and without ==\n\t// ==            the automarker will mark your solution as false    ==\n\t// ===================================================================\n    // Please complete the missing code\n\treturn t;\n}",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b36b",
        "question": "In this exercise you need to complete the function below defining a Ray-CutSphere Intersection:\ndouble CutSphere::Intersect(Vector source, Vector d)\nNOTE: The pre-loaded answer box contains already code for the ray sphere intersection and sorts the intersection points such that t1 is the first intersection point with the original sphere.\nAdd additional code such that the function returns instead the intersection points with the \"cut-sphere\".\nThe cutting plane n.p=a is defined by the variables n (type Vector) and a (type double).\nHINT: Compute the ray-plane intersection and develop an algorithm to decide whether the ray intersects the round (un-cut part) of the sphere, the cutting plane, or doesn't intersect the cut sphere at all (e.g. the ray might pass through the cut-off part of the sphere)\nIMPORTANT: If the ray first intersects the cutting plane of the cut sphere (the flat part of it) then you need to set cuttingPlaneIntersected = true; . This is used in the normal calculation and without the automarker will mark your solution as false.\nNote: The following variables and functions are already defined for you to use:\nThe plane n.p=a is defined by the variables n (type Vector) and a (type double).\nVector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector\nVector: v1-v2 - subtracts v2 from v1 and returns resulting vector\nVector: v1 * t - scales the vector v1 by t and returns resulting vector\nVector v.Scale(float a, float b, float c) - scales each component of the vector v\nfloat v1.Dot(Vector v2) - returns the dot product of vector v1 and v2\nVector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2\nAfter completing the code in the pre-loaded answer box you should get the images below:\nImage description: The image shows a sphere shown in red with a chunk cut off, in front of a blue and green background. Some shadows of the object are cast on the ground.\nImage description: The image shows the cut off chunk placed on the ground, in front of a blue and green background. Some shadows of the object are cast on the ground.\nTemplate code:\ndouble CutSphere::Intersect(Vector source, Vector d)\n{\n\t// A, B, and C are the parameters of quadratic equation for finding the \n\t// ray intersection parameter t (see slide 16 of the \"Ray Tracing\" lecture notes)\n\tfloat A = d.Dot(d);\n\tfloat B = 2 * source.Dot(d);\n\tfloat C = source.Dot(source) - 1;\n\tfloat t; // the parameter t for the closest intersection point or ray with the sphere. If no intersection t=-1.0\n\t// BEGIN SOLUTION RAY-SPHERE INTERSECTION\n\tif (B * B - 4 * A * C <= 0) return t=-1;  // no hit\n\tfloat t1;\n\tif (B > 0)   // for numerical precision\n\t\tt1 = (-B - sqrt(B * B - 4 * A * C)) / (2 * A);\n\telse\n\t\tt1 = (-B + sqrt(B * B - 4 * A * C)) / (2 * A);\n\tfloat t2 = C / (A * t1); // easier way to get t2\n\t// END SOLUTION RAY-SPHERE INTERSECTION\n\t// if t1>t2 swap, so t1 is always first intersection point\n\tfloat temp;\n\tif (t1 > t2) {\n\t\ttemp = t1;\n\t\tt1 = t2;\n\t\tt2 = temp;\n\t}\n\tt = t1;\n\tcuttingPlaneIntersected = false; // variable of type bool - true if ray first intersects the flat part of the cut sphere\n\t// ===================================================================\n\t// == The above method code computes the intersection parameters of ==\n\t// == the ray with the sphere. Add additional code such that the    ==\n\t// == function returns instead the intersections points with the    ==\n\t// == \"cut-sphere\".                                                 ==\n\t// == Tip: Compute the ray-plane interscetion and develop an        ==\n\t// ==      algorithm to decide whether the ray intersected the      ==\n\t// ==      round (un-cut part) of the sphere, the cutting plane,    ==\n\t// ==      or doesn't intersect the cut spere at all (e.g. the ray  ==\n\t// ==      might pass through the cut-off part of the sphere        ==\n    // == IMPORTANT: If the ray first intersects the cutting plane of   ==\n\t// ==            the cut sphere (the flat part of it) then you need ==\n\t// ==            to set cuttingPlaneIntersected = true;             ==\n\t// ==            This is used in the normal calculation and without ==\n\t// ==            the automarker will mark your solution as false    ==\n\t// ===================================================================\n    // Please complete the missing code\n\treturn t;\n}",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b37a",
        "question": "In this exercise you need to complete the normal calculation for the Ray-CutSphere Intersection from the previous question. Note that you can complete this question even if you were unable to implement the intersection function correctly.\nPlease implement the function\nVector CutSphere::Normal(Vector p)\nNOTE: The function should return the correct normal of the \"cut: unit sphere at the ray intersection point p. Note that the cut-sphere is a unit sphere with centre at the origin. The normal of the cutting plane is n (type Vector).\nNOTE 2: You can assume that the boolean variable cuttingPlaneIntersected is defined and that it is true if p lies on the flat part of the \"cut\" unit sphere and false otherwise.\nNote: The following variables and functions are already defined for you to use:\nThe plane n.p=a is defined by the variables n (type Vector) and a (type double).\nVector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector\nVector: v1-v2 - subtracts v2 from v1 and returns resulting vector\nVector: v1 * t - scales the vector v1 by t and returns resulting vector\nVector v.Scale(float a, float b, float c) - scales each component of the vector v\nfloat v1.Dot(Vector v2) - returns the dot product of vector v1 and v2\nVector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2\nVector v.Normalize() - returns the normalised version of the vector v\nAfter completing the code in the pre-loaded answer box you should get the image below:\nImage description: The image shows a sphere shown in red with a chunk cut off, in front of a blue and green background. Some shadows of the object are cast on the ground.",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b37b",
        "question": "In this exercise you need to complete the normal calculation for the Ray-CutSphere Intersection from the previous question. Note that you can complete this question even if you were unable to implement the intersection function correctly.\nPlease implement the function\nVector CutSphere::Normal(Vector p)\nNOTE: The function should return the correct normal of the \"cut: unit sphere at the ray intersection point p. Note that the cut-sphere is a unit sphere with centre at the origin. The normal of the cutting plane is n (type Vector).\nNOTE 2: You can assume that the boolean variable cuttingPlaneIntersected is defined and that it is true if p lies on the flat part of the \"cut\" unit sphere and false otherwise.\nNote: The following variables and functions are already defined for you to use:\nThe plane n.p=a is defined by the variables n (type Vector) and a (type double).\nVector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector\nVector: v1-v2 - subtracts v2 from v1 and returns resulting vector\nVector: v1 * t - scales the vector v1 by t and returns resulting vector\nVector v.Scale(float a, float b, float c) - scales each component of the vector v\nfloat v1.Dot(Vector v2) - returns the dot product of vector v1 and v2\nVector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2\nVector v.Normalize() - returns the normalised version of the vector v\nAfter completing the code in the pre-loaded answer box you should get the image below:\nImage description: The image shows a spherical cap, or a sphere with a portion cut off. The cut portion of the sphere is not shown, and the background behind that portion is shown, since light would past through the cut portion of the sphere.",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    }
]