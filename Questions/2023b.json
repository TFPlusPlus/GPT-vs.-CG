[
    {
        "id": "2023b01",
        "question": "Consider a surface that reflects the colour yellow when three lights are shining on it: one red, one green, one blue.\nWhat will be the reflected colour if the red light is removed?\na. Yellow\nb. Green\nc. Black\nd. Red\ne. Cyan",
        "answer": "The correct answer is:\nGreen",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b02a",
        "question": "Given is a 3D medical imaging data set of a head which specifies for each point the radiodensity of the material, i.e., to what extend the material blocks x-rays. For example, bone has a higher value (is less transmissible) than muscle, skin, and fluid. What surface representation is most suitable for rendering the bone layer of the head as illustrated in the image below?\nImage description: A 3D model of a skull.\nSelect one:\na. Parametric surfaces\nb. CSG (Constructive Solid Geometry)\nc. Subdivision surfaces\nd. Implicit surfaces\ne. First using a CGS object and then smoothing it using a subdivision surface.",
        "answer": "The correct answer is: Implicit surfaces",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b02b",
        "question": "Given is a 3D medical imaging data set of a head which specifies for each point the radiodensity of the material, i.e., to what extend the material blocks x-rays. For example, bone has a higher value (is less transmissible) than muscle, skin, and fluid. What surface representation is most suitable for rendering the bone layer of the head as illustrated in the image below?\nImage description: A 3D model of a skull in white, there are a lot of intricate details in the model.\nSelect one:\na. Parametric surfaces\nb. CSG (Constructive Solid Geometry)\nc. Subdivision surfaces\nd. Implicit surfaces\ne. First using a CGS object and then smoothing it using a subdivision surface.",
        "answer": "The correct answer is: Implicit surfaces",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b03",
        "question": "Which of the following statements about rendering in OpenGL is false (if any)?\nSelect one:\na. We can render a cube consisting of 6 square polygons without a depth buffer if we render back faces first and then front faces.\nb. When displaying an animated scene we need to use double buffering to avoid rendering artifacts.\nc. None of the other statements is false, i.e., they are all true.\nd. OpenGL uses the winding order of polygons to determine front and back faces.\ne. When rendering closed 3D surfaces, such as a sphere or cube, we must enable back-face culling since otherwise the resulting image will look wrong.",
        "answer": "The correct answer is: When rendering closed 3D surfaces, such as a sphere or cube, we must enable back-face culling since otherwise the resulting image will look wrong.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b04",
        "question": "Given is a equilateral triangle. What colours do we need to specify for the vertices in order to make the centre point dark grey (RGB value (1/3, 1/3, 1/3))?\nSelect one:\na. The vertices must be cyan, red and yellow.\nb. The vertices must be magenta, green and blue.\nc. The vertices must be cyan, magenta, and yellow.\nd. The vertices must be red, yellow and blue.\ne. The vertices must be red, green and blue.",
        "answer": "The correct answer is: The vertices must be red, green and blue.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b05",
        "question": "Which of the following statements about parametric curves and surfaces is true?\nSelect one:\na. The normal of a parametric surface p(s,t) is obtained by interpolating p(0,0), p(0,1), p(1,0), and p(1,1).\nb. When defining a surface-of-revolution the profile curve can be a spline curve, e.g., a Catmul-Rom spline.\nc. Squares and discs can not be represented as parametric surfaces.\nd. The Hermit curve is a quadratic spline.\ne. Bezier curves are always cubic, e.g., quadratic Bezier curves do not exist.",
        "answer": "The correct answer is: When defining a surface-of-revolution the profile curve can be a spline curve, e.g., a Catmul-Rom spline.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b06",
        "question": "Given is a light source at the position\nL=(1, 3, 0)^T\nand an object with the point\nP=(1, 2, 1)\n.\nIf we draw the projected shadow of the object on the plane y=1, what is the position P' of the point P projected on the plane y=1?\nHint: Make yourself an illustration of the situation.\nSelect one:\na. P'=(2, 1, 3)^T\nb. P'=(1, 1, 2)^T\nc. P'=(2, 1, 0)^T\nd. P'=(0, 1, 1)^T\ne. P'=(1, 1, 3)^T",
        "answer": "The correct answer is:\nP'=(1, 1, 2)^T",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b07a",
        "question": "Given are the following vertices:\nconst int numVertices=7;\nconst float vertices[numVertices][2] = { {50,50},{300,50},{50,150},{50,200},{200,200},{50,300},{300,300} };\nConsider the image shown below.\nImage description: The image shows a square with a triangle cropped out. The vertices of the square are 0, 1, 6, 5. The vertices of the triangle are 2, 4, 3.\nWhich calling sequence of these vertices (using glVertex2fv) results in the shape in the image above, if we use the OpenGL commands glBegin(GL_TRIANGLE_FAN) and glEnd()?\nSelect one:\na. 4, 1, 0, 2, 3, 5, 6\nb. 6, 1, 0, 2, 4, 3, 5\nc. 0, 1, 2, 3, 4, 5, 6\nd. 4, 3, 5, 6, 1, 0, 2\ne. 1, 0, 2, 4, 3, 5, 6",
        "answer": "The correct answer is: 4, 3, 5, 6, 1, 0, 2",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b07b",
        "question": "Given are the following vertices:\nconst int numVertices=7;\nconst float vertices[numVertices][2] = { {50,50},{300,50},{50,150},{50,200},{200,200},{50,300},{300,300} };\nConsider the image shown below.\nImage description: The image shows a square with a triangle cropped out. The vertices of the square are 0, 1, 6, 5 counterclockwise. The vertices of the triangle are 2, 4, 3 counterclockwise. Lines from the 4th vertex to every other vertex are included in the shape.\nWhich calling sequence of these vertices (using glVertex2fv) results in the shape in the image above, if we use the OpenGL commands glBegin(GL_TRIANGLE_FAN) and glEnd()?\nSelect one:\na. 4, 1, 0, 2, 3, 5, 6\nb. 6, 1, 0, 2, 4, 3, 5\nc. 0, 1, 2, 3, 4, 5, 6\nd. 4, 3, 5, 6, 1, 0, 2\ne. 1, 0, 2, 4, 3, 5, 6",
        "answer": "The correct answer is: 4, 3, 5, 6, 1, 0, 2",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b08",
        "question": "Given is a plane 3x+2y-z=3 and a ray\n$$p(t)= \\begin{pmatrix} 1 \\\\ 0  \\\\ 1 \\end{pmatrix} + t * \\begin{pmatrix} -1 \\\\ c  \\\\ 0 \\end{pmatrix}.$$\nFor what value of c is the ray parallel to the plane?\nSelect one:\na. c=0\nb. c=0.5\nc. c=1.5\nd. c=-0.5\ne. c=1",
        "answer": "The correct answer is: c=1.5",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b09a",
        "question": "Given is a function drawHouse() which draws a wire frame house in the xy-plane as shown in the image below:\nImage description: A shape of a house is drawn in the xy-plane. The house is made up of a square with a triangle on top.\nWe now transform the house in two different ways before drawing it:\nDrawing 1:\nglScalef(2.0, 1.0, 1.0);\ndrawHouse();\nDrawing 2:\nglScalef(2.0, 1.0, -1.0);\ndrawHouse();\nWhich of the following statements is correct?\nSelect one:\na. The two drawings look the same, but the MODEL_VIEW matrices used to transform the house before drawing are different.\nb. The two drawings look different, and the MODEL_VIEW matrices used to transform the house before drawing are different.\nc. The two drawings look the same, and the MODEL_VIEW matrices used to transform the house before drawing are the same.\nd. The transformation is not possible (generates an error).\ne. The two drawings look different, but the MODEL_VIEW matrices used to transform the house before drawing are the same.",
        "answer": "The correct answer is: The two drawings look the same, but the MODEL_VIEW matrices used to transform the house before drawing are different.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b09b",
        "question": "Given is a function drawHouse() which draws a wire frame house in the xy-plane as shown in the image below:\nImage description: A shape of a house is drawn in the xy-plane. The house is made up of a square with a triangle on top. The square is made up of four points, (0, 0), (2, 0), (2, 2), and (0, 2). The triangle is made up of three points, (0, 2), (2, 2), and (1, 3).\nWe now transform the house in two different ways before drawing it:\nDrawing 1:\nglScalef(2.0, 1.0, 1.0);\ndrawHouse();\nDrawing 2:\nglScalef(2.0, 1.0, -1.0);\ndrawHouse();\nWhich of the following statements is correct?\nSelect one:\na. The two drawings look the same, but the MODEL_VIEW matrices used to transform the house before drawing are different.\nb. The two drawings look different, and the MODEL_VIEW matrices used to transform the house before drawing are different.\nc. The two drawings look the same, and the MODEL_VIEW matrices used to transform the house before drawing are the same.\nd. The transformation is not possible (generates an error).\ne. The two drawings look different, but the MODEL_VIEW matrices used to transform the house before drawing are the same.",
        "answer": "The correct answer is: The two drawings look the same, but the MODEL_VIEW matrices used to transform the house before drawing are different.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b10",
        "question": "Which of the 3D homogeneous matrices below first translates a point by the vector\n$$P = \\begin{pmatrix} 2 \\\\ 3 \\\\ 1  \\end{pmatrix}$$\nand then rotates it by 90 degree anti-clockwise around the y-axis?\nAnswer\na. None of the others.\nb. $$\\begin{pmatrix} 1 & 0 & 0 & 2 \\\\ 0 & 1 & 0 & 3$$\n$$\\\\ 0 & 0 & 1 & 1 \\\\ 0 & 0 & 0 & 1$$\n$$\\end{pmatrix}$$\nc. $$\\begin{pmatrix} 0 & 0 & -1 & -1 \\\\ 0 & 1 & 0 & 3$$\n$$\\\\ 1 & 0 & 0 & 2 \\\\ 0 & 0 & 0 & 1$$\n$$\\end{pmatrix}$$\nd. $$\\begin{pmatrix} -1 & 0 & 0 & -2 \\\\ 0 & 1 & 0 & 3 \\\\ 0 & 0 & -1 & -1 \\\\ 0 & 0 & 0 & 1$$\n$$\\end{pmatrix}$$\ne. $$\\begin{pmatrix} 0 & 0 & 1 & 1 \\\\ 0 & 1 & 0 & 3 \\\\ -1 & 0 & 0 & -2 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}$$",
        "answer": "The correct answer is:\n$$\\begin{pmatrix} 0 & 0 & 1 & 1 \\\\ 0 & 1 & 0 & 3 \\\\ -1 & 0 & 0 & -2 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b11",
        "question": "Given is a triangle with the vertices\n$$A = \\begin{pmatrix} 4 \\\\ 0 \\\\ 0  \\end{pmatrix}, \\mbox{   } B = \\begin{pmatrix} -1 \\\\ 0 \\\\ 0  \\end{pmatrix}, \\mbox{   }C = \\begin{pmatrix} 0 \\\\ 2 \\\\ 0  \\end{pmatrix}$$\nThe RGB colours at these three points are\n$$C_A=(0.0, 0.0, 1.0), \\mbox{   }C_B=(0.6, 0.4, 0.2), \\mbox{   }C_C=(0.5, 1.0, 0.0)$$\n.\nIf the triangle is rendered using OpenGL, what is the colour at the point\n$$P = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0  \\end{pmatrix}?$$\nTip: Make yourself an illustration. Note that the triangle lies on the xy-plane. You should be able to determine the weighting factors for the colour interpolation using your illustration, without doing any complex calculations.\nSelect one:\na. C_P=(0.49, 0.66, 0.18)\nb. C_P=(0.45, 0.7, 0.15)\nc. C_P=(0.55, 0.69, 0.2)\nd. C_P=(0.5, 0.6, 0.15)\ne. C_P=(0.52, 0.65, 0.17)",
        "answer": "The correct answer is:\nC_P=(0.49, 0.66, 0.18)",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b12a",
        "question": "Given is the following texture image:\nImage description: The image shows a 4x4 grid of colours. From left to right, then top to bottom, the colours are red, light green, dark blue, brown, yellow, purple, cyan, dark orange, pink, white, lime, grey, black, light blue, light orange, dark green.\nWhat texture coordinates do we need to specify if we want to use this texture image to create the textured triangle shown below?\nImage description: The image shows a shifted version of the base image, with the bottom left corner being the top left corner of the pink tile, the bottom right corner being the bottom right corner of the light orange tile, and the top right corner being the top right corner of the dark blue tile.\nSelect one:\na. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.5)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)\nb. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.0)\nTexture coordinates for the bottom-right vertex of the triangle: (1.0, 0.0)\nTexture coordinates for the top vertex of the triangle: (1.0, 1.0)\nc. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.0)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)\nd. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.75)\nTexture coordinates for the bottom-right vertex of the triangle: (0.5, 0.5)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)\ne. Texture coordinates for the bottom-left vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 1.0)\nTexture coordinates for the top vertex of the triangle: (0.0, 0.5)",
        "answer": "The correct answer is: Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.5)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b12b",
        "question": "Given is the following texture image:\nImage description: The image shows a 4x4 grid of colours.\nWhat texture coordinates do we need to specify if we want to use this texture image to create the textured triangle shown below?\nImage description: The image shows a shifted version of the base image. Using grid coordinates from the base image, where the bottom left corner of the base image is (0, 0) and the top right corner of the base image is (4, 4), then the bottom left corner is (0, 2), the bottom right corner is (3, 0), and the top right corner is (3, 4).\nSelect one:\na. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.5)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)\nb. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.0)\nTexture coordinates for the bottom-right vertex of the triangle: (1.0, 0.0)\nTexture coordinates for the top vertex of the triangle: (1.0, 1.0)\nc. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.0)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)\nd. Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.75)\nTexture coordinates for the bottom-right vertex of the triangle: (0.5, 0.5)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)\ne. Texture coordinates for the bottom-left vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 1.0)\nTexture coordinates for the top vertex of the triangle: (0.0, 0.5)",
        "answer": "The correct answer is: Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.5)\nTexture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)\nTexture coordinates for the top vertex of the triangle: (0.75, 1.0)",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b13a",
        "question": "Image description: The image shows the base texture, a shape to be textured, and the resulting textured shape. The base texture is the picture of a mountain, the shape to be texture is made up from three shapes: a rectangle with vertices P1, P2, P5, P3 counterclockwise, where P1 is the bottom left corner of the whole shape, the width of the rectangle is 2, and the height of the rectangle is 0.5; a rectangle with vertices P6, P8, P10, P9 counterwise, where P10 is the top right corner of the whole shape, the width of the rectangle is 2, and the height of the rectangle is 0.5; a square with vertices P4, P5, P7, P6 counterwise, where the center of the shape aligns with the center of the whole shape, the width of the square is 1. The resulting textured shape is the same as the shape to be textured, but with the base texture mapped onto it, repeated 3 times horizontally and 2 times vertically.\nSelect one:\na. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (4, 0)\nTexture coordinate for P3: (0, 1)\nTexture coordinate for P4: (2, 1)\nTexture coordinate for P5: (4, 1)\nTexture coordinate for P6: (2, 3)\nTexture coordinate for P7: (4, 3)\nTexture coordinate for P8: (6, 3)\nTexture coordinate for P9: (2, 4)\nTexture coordinate for P10: (6, 4)\nb. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (2, 0)\nTexture coordinate for P3: (0, 0.5)\nTexture coordinate for P4: (1, 0.5)\nTexture coordinate for P5: (2, 0.5)\nTexture coordinate for P6: (1, 1.5)\nTexture coordinate for P7: (2, 1.5)\nTexture coordinate for P8: (3, 1.5)\nTexture coordinate for P9: (1, 2)\nTexture coordinate for P10: (3, 2)\nc. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (2, 0)\nTexture coordinate for P3: (0, 1)\nTexture coordinate for P4: (2, 1)\nTexture coordinate for P5: (4, 1)\nTexture coordinate for P6: (2, 2)\nTexture coordinate for P7: (4, 2)\nTexture coordinate for P8: (6, 2)\nTexture coordinate for P9: (2, 3)\nTexture coordinate for P10: (6, 3)\nd. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (4, 0)\nTexture coordinate for P3: (0, 0.5)\nTexture coordinate for P4: (2, 0.5)\nTexture coordinate for P5: (4, 0.5)\nTexture coordinate for P6: (2, 1.5)\nTexture coordinate for P7: (4, 1.5)\nTexture coordinate for P8: (6, 1.5)\nTexture coordinate for P9: (2, 2)\nTexture coordinate for P10: (6, 2)\ne. None of the others.",
        "answer": "The correct answer is: Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (2, 0)\nTexture coordinate for P3: (0, 0.5)\nTexture coordinate for P4: (1, 0.5)\nTexture coordinate for P5: (2, 0.5)\nTexture coordinate for P6: (1, 1.5)\nTexture coordinate for P7: (2, 1.5)\nTexture coordinate for P8: (3, 1.5)\nTexture coordinate for P9: (1, 2)\nTexture coordinate for P10: (3, 2)",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b13b",
        "question": "Image description: The image shows the base texture, a shape to be textured, and the resulting textured shape. The base texture is the picture of a mountain, the shape to be texture is made up from three shapes: a rectangle with vertices P1, P2, P5, P3 counterclockwise, where P1 is the bottom left corner of the whole shape, the width of the rectangle is 2, and the height of the rectangle is 0.5; a rectangle with vertices P6, P8, P10, P9 counterwise, where P10 is the top right corner of the whole shape, the width of the rectangle is 2, and the height of the rectangle is 0.5; a square with vertices P4, P5, P7, P6 counterwise, where the center of the shape aligns with the center of the whole shape, the width of the square is 1. The resulting textured shape is the same as the shape to be textured, but with the base texture mapped onto it, repeated 3 times horizontally and 2 times vertically. The bottom left corner of the base texture is mapped to the bottom left corner of the shape to be textured, and the top right corner of the base texture is mapped to the top right corner of the shape to be textured. The base texture has not been shapeshifted, only cropped.\nSelect one:\na. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (4, 0)\nTexture coordinate for P3: (0, 1)\nTexture coordinate for P4: (2, 1)\nTexture coordinate for P5: (4, 1)\nTexture coordinate for P6: (2, 3)\nTexture coordinate for P7: (4, 3)\nTexture coordinate for P8: (6, 3)\nTexture coordinate for P9: (2, 4)\nTexture coordinate for P10: (6, 4)\nb. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (2, 0)\nTexture coordinate for P3: (0, 0.5)\nTexture coordinate for P4: (1, 0.5)\nTexture coordinate for P5: (2, 0.5)\nTexture coordinate for P6: (1, 1.5)\nTexture coordinate for P7: (2, 1.5)\nTexture coordinate for P8: (3, 1.5)\nTexture coordinate for P9: (1, 2)\nTexture coordinate for P10: (3, 2)\nc. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (2, 0)\nTexture coordinate for P3: (0, 1)\nTexture coordinate for P4: (2, 1)\nTexture coordinate for P5: (4, 1)\nTexture coordinate for P6: (2, 2)\nTexture coordinate for P7: (4, 2)\nTexture coordinate for P8: (6, 2)\nTexture coordinate for P9: (2, 3)\nTexture coordinate for P10: (6, 3)\nd. Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (4, 0)\nTexture coordinate for P3: (0, 0.5)\nTexture coordinate for P4: (2, 0.5)\nTexture coordinate for P5: (4, 0.5)\nTexture coordinate for P6: (2, 1.5)\nTexture coordinate for P7: (4, 1.5)\nTexture coordinate for P8: (6, 1.5)\nTexture coordinate for P9: (2, 2)\nTexture coordinate for P10: (6, 2)\ne. None of the others.",
        "answer": "The correct answer is: Texture coordinate for P1: (0, 0)\nTexture coordinate for P2: (2, 0)\nTexture coordinate for P3: (0, 0.5)\nTexture coordinate for P4: (1, 0.5)\nTexture coordinate for P5: (2, 0.5)\nTexture coordinate for P6: (1, 1.5)\nTexture coordinate for P7: (2, 1.5)\nTexture coordinate for P8: (3, 1.5)\nTexture coordinate for P9: (1, 2)\nTexture coordinate for P10: (3, 2)",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b14",
        "question": "An object is defined with respect to the xyz (world) coordinate system. What OpenGL command can be used to to align that object with a new uvn-coordinate system sharing the same origin and with the unit vectors: \n$$u = \\begin{pmatrix} -1 \\\\ 0 \\\\ 0  \\end{pmatrix}, \\mbox{    }  v = \\begin{pmatrix} 0 \\\\ -1 \\\\ 0  \\end{pmatrix}, \\mbox{    } n = \\begin{pmatrix} 0 \\\\ 0 \\\\ -1  \\end{pmatrix} \\mbox{  }?$$\na. glRotatef(180, -1, -1, -1)\nb. glRotatef(180, 0, 0, 1)\nc. glScalef(-1, -1, -1)\nd. glTranslatef(-1, -1, -1)\ne. glRotatef(180, 1, 1, 1)",
        "answer": "The correct answer is: glScalef(-1, -1, -1)",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b15",
        "question": "Given is a quadratic spline with the power basis\n$$T=\\begin{pmatrix} t^2 & t & 1\\end{pmatrix}$$\nand the basis matrix:\n$$\\begin{pmatrix} 1 & -2 & 1 \\\\ -2 & 2 & 0 \\\\ 1 & 0 & 0 \\end{pmatrix}$$\nWhich statement about the resulting basis functions B_1(t), B_2(t), and B_3(t) is true?\nSelect one:\na. B_1(t)=-2*t^2+1\nb. The sum of the three basis functions is always 0.\nc. The basis functions are all cubic.\nd. The basis functions are the basis functions of a quadratic Bezier curve.\ne. B_3(1)=0",
        "answer": "The correct answer is: The basis functions are the basis functions of a quadratic Bezier curve.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b16a",
        "question": "Given is a profile curve c(t)=(x(t), 0, z(t)), 0 \u2264 t \u2264 1, which lies in the xz-plane. The resulting surface-of-revolution is shown in the image below. What is the parametric equation of the profile curve indicated in blue in the image below?\nImage description: A surface of revolution is shown with a blue line on the surface. The blue line connects the points (0, 0, 3) and (3, 0, 2), then (3, 0, 2) and (4, 0, 0).\nSelect one:\n$$a. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 6*t \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+2 \\\\ 0 \\\\ 4*(1-t) \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$b. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 3*t \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} t+3 \\\\ 0 \\\\ 4*(1-t) \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$c. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 6*t \\\\ 0 \\\\ 3-t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+2 \\\\ 0 \\\\ 2-t \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$d. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 3*t \\\\ 0 \\\\ 3-t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} t+3 \\\\ 0 \\\\ 2-t \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$e. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 3*t \\\\ 0 \\\\ 3-0.5*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+1 \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$",
        "answer": "The correct answer is:\n$$c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 6*t \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+2 \\\\ 0 \\\\ 4*(1-t) \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b16b",
        "question": "Given is a profile curve c(t)=(x(t), 0, z(t)), 0 \u2264 t \u2264 1, which lies in the xz-plane. The resulting surface-of-revolution is shown in the image below. What is the parametric equation of the profile curve indicated in blue in the image below?\nImage description: A surface of revolution is shown with its profile curve on the xz-plane. The blue line connects the points (0, 0, 3) and (3, 0, 2), then (3, 0, 2) and (4, 0, 0).\nSelect one:\n$$a. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 6*t \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+2 \\\\ 0 \\\\ 4*(1-t) \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$b. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 3*t \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} t+3 \\\\ 0 \\\\ 4*(1-t) \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$c. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 6*t \\\\ 0 \\\\ 3-t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+2 \\\\ 0 \\\\ 2-t \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$d. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 3*t \\\\ 0 \\\\ 3-t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} t+3 \\\\ 0 \\\\ 2-t \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$\n$$e. c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 3*t \\\\ 0 \\\\ 3-0.5*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+1 \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$",
        "answer": "The correct answer is:\n$$c(t)=\\begin{cases}$$\n$$\\begin{pmatrix} 6*t \\\\ 0 \\\\ 3-2*t \\end{pmatrix} & \\text{if } 0 \\le t \\le 0.5\\\\$$\n$$\\begin{pmatrix} 2*t+2 \\\\ 0 \\\\ 4*(1-t) \\end{pmatrix} & \\text{if } 0.5 \\le t \\le 1$$\n$$\\end{cases}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b17a",
        "question": "What is the parametric equation of the donut-shaped surface p(t)=(x(s,t), y(s,t), z(s,t)), 0 \u2264 s,t \u2264 1 shown in the image below?\nHint 1: The surface is a surface-of-revolution as discussed in the lecture. The profile curve is an ellipsoid shown in the image below in blue.\nImage description: A donut-shaped surface is shown with a blue line on the surface. The blue line is an ellipse covering three squares in the coordinate system, from (1, 0, 0) to (4, 0, 1).\nSelect one:\na. p(t)=\n$$\\begin{pmatrix} (1.5*cos(2 \\pi t) + 2.5) cos (2 \\pi s) \\\\ (1.5*cos(2 \\pi t) + 2.5) sin (2 \\pi s) \\\\ sin (2 \\pi t) \\end{pmatrix}$$\nb. p(t)=\n$$\\begin{pmatrix} 1.5*cos(2 \\pi t) cos (2 \\pi s) +2.5  \\\\ 1.5*cos(2 \\pi$$\n$$t) sin (2 \\pi s)  \\\\ sin (2 \\pi t) \\end{pmatrix}$$\nc. p(t)=\n$$\\begin{pmatrix} 1.5*cos(2 \\pi t) cos (2 \\pi s) + 2.5  \\\\ 1.5*cos(2 \\pi$$\n$$t) sin (2 \\pi s) +2.5 \\\\ sin (2 \\pi t) \\end{pmatrix}$$\nd. p(t)=\n$$\\begin{pmatrix} 3*cos(2 \\pi t) cos (2 \\pi s) \\\\ cos(2 \\pi$$\n$$t) sin (2 \\pi s) \\\\ sin (2 \\pi s) \\end{pmatrix}$$\ne. p(t)=\n$$\\begin{pmatrix} 3*cos(2 \\pi t) cos (2 \\pi s) + 2.5 \\\\ cos(2 \\pi$$\n$$t) sin (2 \\pi s) \\\\ sin (2 \\pi s) \\end{pmatrix}$$",
        "answer": "The correct answer is:\np(t)=\n$$\\begin{pmatrix} (1.5*cos(2 \\pi t) + 2.5) cos (2 \\pi s) \\\\ (1.5*cos(2 \\pi t) + 2.5) sin (2 \\pi s) \\\\ sin (2 \\pi t) \\end{pmatrix}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b17b",
        "question": "What is the parametric equation of the donut-shaped surface p(t)=(x(s,t), y(s,t), z(s,t)), 0 \u2264 s,t \u2264 1 shown in the image below?\nHint 1: The surface is a surface-of-revolution as discussed in the lecture. The profile curve is an ellipsoid shown in the image below in blue.\nImage description: A donut-shaped surface is shown with its profile curve on the xz-plane. The blue line is an ellipse with the center (2.5, 0, 0.5), width 3, and height 1.\nSelect one:\na. p(t)=\n$$\\begin{pmatrix} (1.5*cos(2 \\pi t) + 2.5) cos (2 \\pi s) \\\\ (1.5*cos(2 \\pi t) + 2.5) sin (2 \\pi s) \\\\ sin (2 \\pi t) \\end{pmatrix}$$\nb. p(t)=\n$$\\begin{pmatrix} 1.5*cos(2 \\pi t) cos (2 \\pi s) +2.5  \\\\ 1.5*cos(2 \\pi$$\n$$t) sin (2 \\pi s)  \\\\ sin (2 \\pi t) \\end{pmatrix}$$\nc. p(t)=\n$$\\begin{pmatrix} 1.5*cos(2 \\pi t) cos (2 \\pi s) + 2.5  \\\\ 1.5*cos(2 \\pi$$\n$$t) sin (2 \\pi s) +2.5 \\\\ sin (2 \\pi t) \\end{pmatrix}$$\nd. p(t)=\n$$\\begin{pmatrix} 3*cos(2 \\pi t) cos (2 \\pi s) \\\\ cos(2 \\pi$$\n$$t) sin (2 \\pi s) \\\\ sin (2 \\pi s) \\end{pmatrix}$$\ne. p(t)=\n$$\\begin{pmatrix} 3*cos(2 \\pi t) cos (2 \\pi s) + 2.5 \\\\ cos(2 \\pi$$\n$$t) sin (2 \\pi s) \\\\ sin (2 \\pi s) \\end{pmatrix}$$",
        "answer": "The correct answer is:\np(t)=\n$$\\begin{pmatrix} (1.5*cos(2 \\pi t) + 2.5) cos (2 \\pi s) \\\\ (1.5*cos(2 \\pi t) + 2.5) sin (2 \\pi s) \\\\ sin (2 \\pi t) \\end{pmatrix}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b18",
        "question": "Which of the matrices below is the correct MODEL_VIEW matrix after executing the following OpenGL commands:\nglMatrixMode(GL_MODELVIEW );\nglLoadIdentity();\nglRotatef(-90, 0, 0, 1);\nglTranslatef(2, 0, 1);\nglScalef(1, 3, 2);\nQuestion 18Answer\na. $$\\begin{pmatrix} 0 & 1 & 0 & 2 \\\\ 3 & 0 & 0 & 0$$\n$$\\\\ 0 & 0 & 2 & 1 \\\\ 0 & 0 & 0 & 1$$\n$$\\end{pmatrix}$$\nb. $$\\begin{pmatrix} 0 & -1 & 0 & 2 \\\\ 3 & 0 & 0 & 0$$\n$$\\\\ 0 & 0 & 2 & 1 \\\\ 0 & 0 & 0 & 1$$\n$$\\end{pmatrix}$$\nc. $$\\begin{pmatrix} 1 & 0 & 0 & 2 \\\\ 0 & 3 & 0 & 0 \\\\ 0 & 0 & 2 & 1 \\\\ 0 & 0 & 0 & 1$$\n$$\\end{pmatrix}$$\nd. $$\\begin{pmatrix} 0 & 1 & 0 & 2 \\\\ -3 & 0 & 0 & 0$$\n$$\\\\ 0 & 0 & 2 & 1 \\\\ 0 & 0 & 0 & 1$$\n$$\\end{pmatrix}$$\ne. $$\\begin{pmatrix} 0 & 3 & 0 & 0 \\\\ -1 & 0 & 0 & -2 \\\\ 0 & 0 & 2 & 1 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}$$",
        "answer": "The correct answer is:\n$$\\begin{pmatrix} 0 & 3 & 0 & 0 \\\\ -1 & 0 & 0 & -2 \\\\ 0 & 0 & 2 & 1 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b19",
        "question": "Given is a uvn-coordinate system with the origin \n$$O_{uvn} = \\begin{pmatrix} 2 \\\\ -1  \\\\ -2 \\end{pmatrix}$$\nand the coordinate axis \n$${\\bf u} = \\begin{pmatrix} -1 \\\\ 0  \\\\ 0 \\end{pmatrix}\\text{ ,  } {\\bf v} = \\begin{pmatrix} 0 \\\\ 0  \\\\ 1 \\end{pmatrix}\\text{  and } {\\bf n} = \\begin{pmatrix} 0 \\\\ -1  \\\\ 0 \\end{pmatrix}$$\nGiven is a point P with the uvn-coordinates \n$${\\bf p}_{uvn} = \\begin{pmatrix} 2 \\\\ 1  \\\\ 3 \\end{pmatrix}$$\n.\nWhat are the xyz-coordinates (world coordinates) of this point?\nSelect one:\na. $$\\begin{pmatrix} -3 \\\\ 1  \\\\ -3 \\end{pmatrix}$$\nb. $$\\begin{pmatrix} 0  \\\\ -4  \\\\ -1 \\end{pmatrix}$$\nc. $$\\begin{pmatrix} -1 \\\\ -3  \\\\ -2 \\end{pmatrix}$$\nd. $$\\begin{pmatrix} -1 \\\\ -2  \\\\ -1 \\end{pmatrix}$$\ne. $$\\begin{pmatrix} 1 \\\\ -3  \\\\ -5 \\end{pmatrix}$$",
        "answer": "The correct answer is:\n$$\\begin{pmatrix} 0  \\\\ -4  \\\\ -1 \\end{pmatrix}$$",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b20a",
        "question": "A plane n.p=d defines a half-space, where the half space are all points where n.p<=d.\nFor example, for the plane x=0 the half space are all points with an x-coordinate <=0.\nUsing this definition we can now define a \"cut-sphere\" as the intersection of a sphere S and a half-space defined by the plane P. I.e., the \"cut-sphere\" contains all points which are inside the sphere and inside the half-space defined by P. The image below shows an example.\nImage description: The image shows a sphere shown in red with a chunk cut off, in front of a blue and green background. Some shadows of the object are cast on the ground.\nWhich of the statements below about the ray intersection with a \"cut-sphere\" (defined by a sphere S and a plane P) is false?\nNOTE: You can assume that the \"cut-sphere\" is in front of the eye point.\nSelect one:\na. If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P and the sphere S AND the intersection parameter with the plane P is between the two intersection parameters with the sphere S, then the intersection point with the \"cut-sphere\" is equal to the first intersection point with the sphere S.\nb. If the dot product of the ray direction and the normal of P is positive AND the ray intersects the plane P before it intersects the sphere S, then the \"cut-sphere\" object does not exist (i.e., the intersection of the sphere and half-space is empty).\nc. If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P before it intersects the sphere S, then the \"cut-sphere\" object is equal to the sphere S (i.e., the intersection of the sphere and half-space is the sphere and nothing gets cut off.).\nd. The surface normal of a cut-sphere is either the normal of the sphere S or the normal of the plane P dependent on where the ray intersects the \"cut-sphere\" first.\ne. If the dot product of the ray direction and the normal of P is positive AND the ray intersects the plane P after it intersects the sphere S, then the intersection point with the \"cut-sphere\" is given by the intersection point with the sphere S.",
        "answer": "The correct answer is: If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P and the sphere S AND the intersection parameter with the plane P is between the two intersection parameters with the sphere S, then the intersection point with the \"cut-sphere\" is equal to the first intersection point with the sphere S.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b20b",
        "question": "A plane n.p=d defines a half-space, where the half space are all points where n.p<=d.\nFor example, for the plane x=0 the half space are all points with an x-coordinate <=0.\nUsing this definition we can now define a \"cut-sphere\" as the intersection of a sphere S and a half-space defined by the plane P. I.e., the \"cut-sphere\" contains all points which are inside the sphere and inside the half-space defined by P. The image below shows an example.\nImage description: The image shows a spherical cap, or a sphere with a portion cut off. The cut portion of the sphere is not shown, and the background behind that portion is shown, since light would past through the cut portion of the sphere.\nWhich of the statements below about the ray intersection with a \"cut-sphere\" (defined by a sphere S and a plane P) is false?\nNOTE: You can assume that the \"cut-sphere\" is in front of the eye point.\nSelect one:\na. If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P and the sphere S AND the intersection parameter with the plane P is between the two intersection parameters with the sphere S, then the intersection point with the \"cut-sphere\" is equal to the first intersection point with the sphere S.\nb. If the dot product of the ray direction and the normal of P is positive AND the ray intersects the plane P before it intersects the sphere S, then the \"cut-sphere\" object does not exist (i.e., the intersection of the sphere and half-space is empty).\nc. If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P before it intersects the sphere S, then the \"cut-sphere\" object is equal to the sphere S (i.e., the intersection of the sphere and half-space is the sphere and nothing gets cut off.).\nd. The surface normal of a cut-sphere is either the normal of the sphere S or the normal of the plane P dependent on where the ray intersects the \"cut-sphere\" first.\ne. If the dot product of the ray direction and the normal of P is positive AND the ray intersects the plane P after it intersects the sphere S, then the intersection point with the \"cut-sphere\" is given by the intersection point with the sphere S.",
        "answer": "The correct answer is: If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P and the sphere S AND the intersection parameter with the plane P is between the two intersection parameters with the sphere S, then the intersection point with the \"cut-sphere\" is equal to the first intersection point with the sphere S.",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b21",
        "question": "Consider the 5x5 grayscale image, J, defined by the grid lattice below. Given also, is the a 3x3 Gaussian Kernel, K.\nWhat is the resulting value at pixel location (2,2) of the image obtained by applying Gaussian Kernel K, to image J?\nImage J:\n4\t8\t8\t8\t8\t8\n3\t16\t16\t16\t16\t16\n2\t48\t48\t48\t48\t48\n1\t32\t32\t32\t32\t32\n0\t8\t8\t8\t8\t8\n        0\t1\t2\t3\t4\nGaussian Kernel K:\n2\t1/16\t1/8\t1/16\n1\t1/8\t1/4\t1/8\n0\t1/16\t1/8\t1/16\n        0\t1\t2\nNote: Do not process all pixels that are within a 1 pixel border around the image.\nSelect one:\na. None of the others\nb. 40\nc. 36\nd. 32\ne. 28",
        "answer": "The correct answer is: 36",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b22",
        "question": "Consider the 4x4 binary image, J, defined by the grid lattice below. Given also, is the square-like 3x3 structuring element,S, which contains all \"1\"-value pixels and has the origin at the center (1,1). The horizontal is x axis and the vertical is y axis. Each pixel location is denoted as (x,y) of position index.\nUse \"Padding 0\" (Extending border values outside with zeros).\nWhat is the resulting value at pixel location (3, 2) of the image obtained after performing a binary dilation of image J with structuring element S?\nImage J:\n3\t1\t0\t1\t0\n2\t0\t1\t0\t0\n1\t1\t0\t1\t0\n0\t1\t0\t0\t1\n        0\t1\t2\t3\nStructuring Element S\n2\t1\t1\t1\n1\t1\t1\t1\n0\t1\t1\t1\n        0\t1\t2\nSelect one:\na. 1\nb. None of the others\nc. 0\nd. 2\ne. Undefined",
        "answer": "The correct answer is: 1",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b23",
        "question": "Consider the 4x4 table representing the greyscale (8-bit) image J below. What is the image value at the pixel location (x=0, y=2) after performing the histogram equalization? The image value has to be rounded to the nearest integer.\n3\t16\t64\t32\t8\n2\t16\t16\t16\t16\n1\t64\t16\t16\t8\n0\t16\t8\t32\t64\n        0\t1\t2\t3\nThe bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.\nSelect one:\na. None of the others\nb. 157\nc. 128\nd. 16\ne. 136",
        "answer": "The correct answer is: 157",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b24",
        "question": "Consider the 4x4 table representing the greyscale image J below. What is the pixel value for the cumulative histogram count of 11?\n3\t8\t4\t16\t16\n2\t32\t32\t32\t8\n1\t0\t0\t128\t8\n0\t8\t255\t16\t8\n        0\t1\t2\t3\nThe bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.\nSelect one:\na. 0\nb. 3\nc. 4\nd. None of the others\ne. 16",
        "answer": "The correct answer is: 16",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b25",
        "question": "Consider the 5x5 binary image, J, defined by the grid lattice below. Given also, is the cross-like 3x3 structuring element,S, which contains \"1\"-value pixels except at the corners and has the origin at the center (1,1).\nWhat is the value at pixel location (2,2) of the morphological gradient of image J with structuring element S?\nImage J:\n4\t0\t0\t0\t0\t0\n3\t0\t0\t1\t0\t0\n2\t0\t1\t1\t1\t0\n1\t0\t0\t1\t0\t0\n0\t0\t0\t0\t0\t0\n        0\t1\t2\t3\t4\t\nStructuring Element S:\n2\t0\t1\t0\n1\t1\t1\t1\n0\t0\t1\t0\n        0\t1\t2\nNote: Do not process all pixels that are within a 1 pixel border around the image.\nSelect one:\na. 0\nb. Undefined\nc. 2\nd. 1\ne. None of the others",
        "answer": "The correct answer is: 0",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b26",
        "question": "Consider the greyscale image J defined below What will be the threshold (rounded to the nearest integer) computed after running three iterations of the adaptive threshold technique as described in class?\n3\t128\t16\t64\t16\n2\t128\t32\t32\t16\n1\t128\t128\t8\t128\n0\t8\t8\t16\t64\n        0\t1\t2\t3\nThe bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.\nSelect one:\na. 63\nb. 73\nc. 56\nd. 58\ne. 68",
        "answer": "The correct answer is: 63",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b27",
        "question": "Consider the 4x4 table representing the grayscale image J below. What is the result when a 3x3 median filter is applied? For boundary handling, use BoundaryPaddingZero.\n3\t0\t8\t16\t64\n2\t8\t16\t32\t64\n1\t16\t32\t64\t128\n0\t64\t64\t128\t128\n        0\t1\t2\t3\nThe bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.\nWhat is the value of median filtered image at x=0, y=3?\nWhat is the value of median filtered image at x=2, y=1?\nWhat is the value of median filtered image at x=3, y=1?",
        "answer": "The correct answer is: 0, 64, 64",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b28",
        "question": "Which coefficients of the linear mapping operation, g(x,y)=af(x,y) + b, will map the pixel value f(x,y)=75 to g(x,y)=88 and pixel value f(x,y)=155 to g(x,y)=216?\nWhich effect does this linear mapping operation defined by a and b have, when applied to an image?",
        "answer": "The correct answer is: a is 1.6 and b is -32, contrast is increased and brightness is decreased",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b29",
        "question": "Consider the 4x4 table representing the greyscale (8-bit) image J below. Compute the effect of a logarithmic contrast stretching on the image, which aims to increase the dynamic range of darker regions in the image.\nThe logarithmic contrast stretching operation transforms the input image J(x,y) pixelwise to an output image G(x,y) according to the equation:\n$$G(x,y) = \\frac{log(1+J(x,y))}{log(1 + Q)}$$\nHere Q is the maximal greyvalue of the greyscale range of the input image.\nThe logarithmic function is applied to each input pixel of the 8 bit input range, and generates an output in the range between 0 and 1. You finally have to transform this output range to the same (8-bit) range that the input image has. Round to the nearest integer.\nAfter computation of G, what is the pixel value of the final resulting image at the pixel location (x=1, y=0)?\n3\t8\t8       8       8\n2\t16      4       4       16\n1\t32      128\t255     32\n0\t16\t64\t64      16\n        0\t1\t2\t3\nThe bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.\nSelect one:\na. 101\nb. None of the others.\nc. 161\nd. 223\ne. 255\nf. 192\ng. 130\nh. 74",
        "answer": "The correct answer is: 192",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b30a",
        "question": "Given is an RGB colour cube with side length 2 as illustrated in the image below\"\nImage description: The image shows a RGB colour cube with side length 2. The colours shown are green, cyan, blue, pink, red, and yellow in counterclockwise order, where red is on the x-axis.\nPlease write OpenGL code to transform the cube as shown in the image below. The cube should be scaled by 2 in z-direction, the face with the black, green, blue and cyan vertex should form an angle of 70 degree with the yz-plane, and the edge from black to blue should be parallel to the z-axis with a distance of 2 and should lie on the yz-plane.\nImage description: The image shows the RGB colour cube, but transformed as described above.\nIMPORTANT:\nPlease only use OpenGL transformations, e.g. glTranslatef, glRotatef\nPlease do NOT draw the cube itself - this is done automatically by the uploaded code",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b30b",
        "question": "Given is an RGB colour cube with side length 2 as illustrated in the image below\"\nImage description: The image shows a RGB colour cube with side length 2. The point representing white is on (2, 2, 2), the point representing blue is on (0, 0, 2), and the point representing red is on (2, 0, 0).\nPlease write OpenGL code to transform the cube as shown in the image below. The cube should be scaled by 2 in z-direction, the face with the black, green, blue and cyan vertex should form an angle of 70 degree with the yz-plane, and the edge from black to blue should be parallel to the z-axis with a distance of 2 and should lie on the yz-plane.\nImage description: The image shows the RGB colour cube, but transformed as described above.\nIMPORTANT:\nPlease only use OpenGL transformations, e.g. glTranslatef, glRotatef\nPlease do NOT draw the cube itself - this is done automatically by the uploaded code",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b31a",
        "question": "Given is a function drawTorus() which draws a torus with colored \"blobs\" centred at the origin and aligned with the z-axis as shown in the image below.\nImage description: The image shows a torus centered at the origin and aligned with z-axis. The torus is coloured with green, blue, yellow, and pink in counterclockwise order, where green is on the x-axis.\nPlease write OpenGL code to render the two tori displayed in the image below:\nImage description: The image shows two tori. The first torus is centered at the (1, 1, 0), with yellow, pink, green, and blue in counterclockwise order, where yellow is on the y-axis. The second torus is centered at (0, 1, 1), with green, blue, yellow, and pink in counterclockwise order, where yellow is on the y-axis.\nNote that the first torus lies on the xy-plane with centre (1, 1, 0), and the second  torus lies on the yz-plane with centre (0, 1, 1).\nIMPORTANT:\nYour code must draw the tori in the order described above. Your code should have the format:\n<insert your transformations>\ndrawTorus();\n<insert your transformations>\ndrawTorus();\nNote: transformations refers to OpenGL transformations, e.g. glRotatef, glTranslatef, glScalef, glPushMatrix and glPopMatrix",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b31b",
        "question": "Given is a function drawTorus() which draws a torus with colored \"blobs\" centred at the origin and aligned with the z-axis as shown in the image below.\nImage description: The image shows a torus centered at the origin and on the x-y plane. The torus is coloured with green, blue, yellow, and pink in counterclockwise order, where green is on the x-axis.\nPlease write OpenGL code to render the two tori displayed in the image below:\nImage description: The image shows two tori. The first torus is centered at the (1, 1, 0) and on the x-y plane, with yellow, pink, green, and blue in counterclockwise order, where yellow is on the y-axis. The second torus is centered at (0, 1, 1) and on the y-z plane, with green, blue, yellow, and pink in counterclockwise order, where yellow is on the y-axis.\nNote that the first torus lies on the xy-plane with centre (1, 1, 0), and the second  torus lies on the yz-plane with centre (0, 1, 1).\nIMPORTANT:\nYour code must draw the tori in the order described above. Your code should have the format:\n<insert your transformations>\ndrawTorus();\n<insert your transformations>\ndrawTorus();\nNote: transformations refers to OpenGL transformations, e.g. glRotatef, glTranslatef, glScalef, glPushMatrix and glPopMatrix",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b32a",
        "question": "Write a function animateBouncyBall(), which takes as parameters the position p of a ball and its velocity v and a plane in dot-normal form given by n (unit normal) and d. The function updates the ball's position and velocity for one animation step. Your function should have the following signature:\nvoid animateBouncyBall(Vector3& p, Vector3& v, Vector3& n, double& d)\nNote: The \"&\" symbol represents a reference variable, i.e., any change to this variable will be visible outside the function. You can use it like a normal variable of type Vector3.\nYou can assume that the ball's position p is initially on the outside of the plane (the side the normal points to). Your function should update p such that its new value is p+v and the velocity v stays unchanged. However, if the new point p+v is on the other side of the plane, then you must reflect the vector v on the plane and the new velocity is v_reflected and the new point is p+v_reflected.\nNote: You can ignore that the point p is not exactly on the plane when reflected.\nThe image below illustrates how the position and velocity of the ball change if the function animateBouncyBall() is called multiple times.\nImage description: The image shows a line in a coordinate system, and a ball travelling towards the line, after it makes contact with the plane it is reflected to a different direction.\nYou can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z, and that the following functions are available to you:\ndouble dot(Vector3 u, Vector3 v) //dot product\nVector3 cross(Vector3 u, Vector3 v) //cross product\nYou can assume that the Vector3 class has the following member functions available to you:\nVector3 Vector3.normalized() //returns a vector pointing in the same direction with length 1\ndouble Vector3.magnitude() //returns the length of the vector\nYou can assume that the Vector3 class supports the following operators returning an object of type Vector3:\nVector3 + Vector3\nVector3 - Vector3\nVector3 * double // Note: the order is important, the scalar has to come after the vector when multiplying\nFor example:\nTest1\nVector3 n=Vector3(1, 0, 0); // plane unit normal\ndouble d=0;                 // plane distance from origin\nVector3 p = Vector3(0.5, 0.0, 0.0);\nVector3 v = Vector3(-0.2, 0.0, 0.0);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nResult1\nposition=(0.50,0.00,0.00) velocity=(-0.20,0.00,0.00)\nposition=(0.30,0.00,0.00) velocity=(-0.20,0.00,0.00)\nposition=(0.10,0.00,0.00) velocity=(-0.20,0.00,0.00)\nposition=(0.30,0.00,0.00) velocity=(0.20,0.00,0.00)\nposition=(0.50,0.00,0.00) velocity=(0.20,0.00,0.00)",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b32b",
        "question": "Write a function animateBouncyBall(), which takes as parameters the position p of a ball and its velocity v and a plane in dot-normal form given by n (unit normal) and d. The function updates the ball's position and velocity for one animation step. Your function should have the following signature:\nvoid animateBouncyBall(Vector3& p, Vector3& v, Vector3& n, double& d)\nNote: The \"&\" symbol represents a reference variable, i.e., any change to this variable will be visible outside the function. You can use it like a normal variable of type Vector3.\nYou can assume that the ball's position p is initially on the outside of the plane (the side the normal points to). Your function should update p such that its new value is p+v and the velocity v stays unchanged. However, if the new point p+v is on the other side of the plane, then you must reflect the vector v on the plane and the new velocity is v_reflected and the new point is p+v_reflected.\nNote: You can ignore that the point p is not exactly on the plane when reflected.\nThe image below illustrates how the position and velocity of the ball change if the function animateBouncyBall() is called multiple times.\nImage description: The image shows a line in a coordinate system, and a ball travelling towards the line, and the direction is denoted as v, after it makes contact with the plane it is reflected to a different direction, denoted as v_reflected. The normal of the reflection is denoted as n. The angle of incidence is equal to the angle of reflection.\nYou can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z, and that the following functions are available to you:\ndouble dot(Vector3 u, Vector3 v) //dot product\nVector3 cross(Vector3 u, Vector3 v) //cross product\nYou can assume that the Vector3 class has the following member functions available to you:\nVector3 Vector3.normalized() //returns a vector pointing in the same direction with length 1\ndouble Vector3.magnitude() //returns the length of the vector\nYou can assume that the Vector3 class supports the following operators returning an object of type Vector3:\nVector3 + Vector3\nVector3 - Vector3\nVector3 * double // Note: the order is important, the scalar has to come after the vector when multiplying\nFor example:\nTest1\nVector3 n=Vector3(1, 0, 0); // plane unit normal\ndouble d=0;                 // plane distance from origin\nVector3 p = Vector3(0.5, 0.0, 0.0);\nVector3 v = Vector3(-0.2, 0.0, 0.0);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nanimateBouncyBall(p, v, n, d);\nprintf(\"position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\\n\", p.x, p.y, p.z, v.x, v.y, v.z);\nResult1\nposition=(0.50,0.00,0.00) velocity=(-0.20,0.00,0.00)\nposition=(0.30,0.00,0.00) velocity=(-0.20,0.00,0.00)\nposition=(0.10,0.00,0.00) velocity=(-0.20,0.00,0.00)\nposition=(0.30,0.00,0.00) velocity=(0.20,0.00,0.00)\nposition=(0.50,0.00,0.00) velocity=(0.20,0.00,0.00)",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b33a",
        "question": "In this question we want to create the front and right side of the texture mapped muesli box shown in the image below:\nImage description: The image shows a muesli box in a 3D coordinate system.\nThe 3D model uses a quadstrip for the front and right side and a quadrilateral for the top side, which are textured using the texture image below. Note that the sections of the texture image used for the front and right side of the box are rectangular (illustrated in green in the image below) and the section of the texture image used for the top side of the box is a trapezoid (illustrated in blue in the image below).\nImage description: The image shows a flat texture image of a muesli box, the texture coordinates of the front are (0.12, 0.12), (0.49, 0.12), (0.49, 0.88), and (0.12, 0.88); those of the right are (0.49, 0.12), (0.62, 0.12), (0.62, 0.88), and (0.49, 0.88); and those of the top are (0.12, 0.88), (0.49, 0.88), (0.47, 0.99), and (0.14, 0.99).\nPlease only use the texture coordinates indicated in the image above in order to define the missing values for s1, s2, s3, s4, s5 and t1, t2, t3 in the code shown in the answer box. Please do not change anything else.\nTemplate code:\ns1 = 0;  // please replace with the correct texture coordinate \ns2 = 0;  // please replace with the correct texture coordinate  \ns3 = 0;  // please replace with the correct texture coordinate \ns4 = 0;  // please replace with the correct texture coordinate \ns5 = 0;  // please replace with the correct texture coordinate \nt1 = 0;  // please replace with the correct texture coordinate  \nt2 = 0;  // please replace with the correct texture coordinate \nt3 = 0;  // please replace with the correct texture coordinate \n// front and right face face\nglBegin(GL_QUAD_STRIP);\nglTexCoord2f(s1, t1);\nglVertex3f(0, 0, 0.7);\nglTexCoord2f(s1, t2);\nglVertex3f(0, 4, 0.7);\nglTexCoord2f(s2, t1);\nglVertex3f(2, 0, 0.7);\nglTexCoord2f(s2, t2);\nglVertex3f(2, 4, 0.7);\nglTexCoord2f(s3, t1);\nglVertex3f(2, 0, 0);\nglTexCoord2f(s3, t2);\nglVertex3f(2, 4, 0);\nglEnd();\n// top face\nglBegin(GL_QUADS);\nglTexCoord2f(s1, t2);\nglVertex3f(0, 4, 0.7);\nglTexCoord2f(s2, t2);\nglVertex3f(2, 4, 0.7);\nglTexCoord2f(s5, t3);\nglVertex3f(2, 4, 0);\nglTexCoord2f(s4, t3);\nglVertex3f(0, 4, 0);\nglEnd();",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b33b",
        "question": "In this question we want to create the front and right side of the texture mapped muesli box shown in the image below:\nImage description: The image shows a cuboid, where the surface is textured like a muesli box, in a 3D coordinate system, with the front, top, and side shown.\nThe 3D model uses a quadstrip for the front and right side and a quadrilateral for the top side, which are textured using the texture image below. Note that the sections of the texture image used for the front and right side of the box are rectangular (illustrated in green in the image below) and the section of the texture image used for the top side of the box is a trapezoid (illustrated in blue in the image below).\nImage description: The image shows a flat texture image of an unravelled muesli box, the texture coordinates of the front are (0.12, 0.12), (0.49, 0.12), (0.49, 0.88), and (0.12, 0.88); those of the right are (0.49, 0.12), (0.62, 0.12), (0.62, 0.88), and (0.49, 0.88); and those of the top are (0.12, 0.88), (0.49, 0.88), (0.47, 0.99), and (0.14, 0.99).\nPlease only use the texture coordinates indicated in the image above in order to define the missing values for s1, s2, s3, s4, s5 and t1, t2, t3 in the code shown in the answer box. Please do not change anything else.\nTemplate code:\ns1 = 0;  // please replace with the correct texture coordinate \ns2 = 0;  // please replace with the correct texture coordinate  \ns3 = 0;  // please replace with the correct texture coordinate \ns4 = 0;  // please replace with the correct texture coordinate \ns5 = 0;  // please replace with the correct texture coordinate \nt1 = 0;  // please replace with the correct texture coordinate  \nt2 = 0;  // please replace with the correct texture coordinate \nt3 = 0;  // please replace with the correct texture coordinate \n// front and right face face\nglBegin(GL_QUAD_STRIP);\nglTexCoord2f(s1, t1);\nglVertex3f(0, 0, 0.7);\nglTexCoord2f(s1, t2);\nglVertex3f(0, 4, 0.7);\nglTexCoord2f(s2, t1);\nglVertex3f(2, 0, 0.7);\nglTexCoord2f(s2, t2);\nglVertex3f(2, 4, 0.7);\nglTexCoord2f(s3, t1);\nglVertex3f(2, 0, 0);\nglTexCoord2f(s3, t2);\nglVertex3f(2, 4, 0);\nglEnd();\n// top face\nglBegin(GL_QUADS);\nglTexCoord2f(s1, t2);\nglVertex3f(0, 4, 0.7);\nglTexCoord2f(s2, t2);\nglVertex3f(2, 4, 0.7);\nglTexCoord2f(s5, t3);\nglVertex3f(2, 4, 0);\nglTexCoord2f(s4, t3);\nglVertex3f(0, 4, 0);\nglEnd();",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b34a",
        "question": "Given is a cubic spline curve c(t)=T M G with the geometric constraint vector\nG=(p0, p1, p2, p3)^T\nThe basis matrix of the spline curve is\n$$\\bf{M}=\\begin{pmatrix} -4.5 & 13.5 & -13.5 & 4.5 \\\\ 9 & -22.5 & 18 & -4.5$$\n$$\\\\ -5.5 & 9 & -4.5 & 1 \\\\ 1 & 0 & 0 & 0 \\end{pmatrix}$$\nThe spline curve is used as profile curve for a surface-of-revolution.\nImplement this curve by defining its basis functions and completing the code fragment below.\nPlease write your answer into the answer space using the following format:\ndouble Basis1(double t){ return <Insert code>;} \ndouble Basis2(double t){ return <Insert code>;}\ndouble Basis3(double t){ return <Insert code>;} \ndouble Basis4(double t){ return <Insert code>;} \nCVec3df curve(float t)\n{\n  // return the curve point c(t) of type CVec3df   \n}\nThe first test case uses the geometric constraints:\nconst CVec3df p0(1, 0, 0);\nconst CVec3df p1(1.6666, 0, 0.2);\nconst CVec3df p2(2.3333, 0, 1.5);\nconst CVec3df p3(3, 0, 1);\nand should result into the image below:\nImage description: A surface of revolution is shown with a blue curve on the surface.\nYou can assume that the CVec3df class supports the following operators returning an object of type CVec3df:\nCVec3df + CVec3df\nCVec3df * double // Note: the order is important, the scalar has to come after the vector when multiplying",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b34b",
        "question": "Given is a cubic spline curve c(t)=T M G with the geometric constraint vector\nG=(p0, p1, p2, p3)^T\nThe basis matrix of the spline curve is\n$$\\bf{M}=\\begin{pmatrix} -4.5 & 13.5 & -13.5 & 4.5 \\\\ 9 & -22.5 & 18 & -4.5$$\n$$\\\\ -5.5 & 9 & -4.5 & 1 \\\\ 1 & 0 & 0 & 0 \\end{pmatrix}$$\nThe spline curve is used as profile curve for a surface-of-revolution.\nImplement this curve by defining its basis functions and completing the code fragment below.\nPlease write your answer into the answer space using the following format:\ndouble Basis1(double t){ return <Insert code>;} \ndouble Basis2(double t){ return <Insert code>;}\ndouble Basis3(double t){ return <Insert code>;} \ndouble Basis4(double t){ return <Insert code>;} \nCVec3df curve(float t)\n{\n  // return the curve point c(t) of type CVec3df   \n}\nThe first test case uses the geometric constraints:\nconst CVec3df p0(1, 0, 0);\nconst CVec3df p1(1.6666, 0, 0.2);\nconst CVec3df p2(2.3333, 0, 1.5);\nconst CVec3df p3(3, 0, 1);\nand should result into the image below:\nImage description: A surface of revolution is shown with a profile curve on the surface. The profile curve is described as the spline curve above.\nYou can assume that the CVec3df class supports the following operators returning an object of type CVec3df:\nCVec3df + CVec3df\nCVec3df * double // Note: the order is important, the scalar has to come after the vector when multiplying",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b35",
        "question": "Given is a function drawCube() which draws a unit cube centered at the origin with coloured dots on its top (see image below). The top front corner has a yellow dot, the top-back corner has a cyan dot and the top-left and top-right corners have grey and magenta dots, respectively.\nPlease write OpenGL code to render a double barrel ball gun as illustrated in the image below. The ball gun consists of a stand (bottom part), a horizontal bar on top of it, and two barrels on the left and right of the horizontal bar. All objects have a square cross section with a width of width. The stand and the barrels have a length of length. The horizontal bar as a length of distance. The barrels form an angle of \u03b8 (theta) with the xz-plane. The rotation axis is the centre line of the horizontal bar. The stand is centred on the y-axis. The whole ball gun is rotated by an angle \u03c6 (phi) around its centre axis.\nIMPORTANT:\nIn order for the automarker to work correctly you:\n(1) must use the function drawCube() to draw each robot arm\n(2) must draw the components in the order explained in the image above on the right: first the stand, then the horizontal bar, then the barrel on the positive z-axis and then the barrel on the negative x-axis.\n(3) must use the variables width, length, distance, phi, and theta, which have different values in the test cases.\n(4) must make sure that the dots at the top of each cube are in the correct positions. If you rotate the cuboids around their axes the object looks the same, but the transformation matrices are different and the automarker will mark it as wrong.\nTip: Start by drawing the stand and the horizontal bar. Rotating the stand will rotate the whole ball gun. In addition to glRotatef, glTranslatef, and glScalef, you might also want to use glPushMatrix() and glPopMatrix().",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b36a",
        "question": "In this exercise you need to complete the function below defining a Ray-CutSphere Intersection:\ndouble CutSphere::Intersect(Vector source, Vector d)\nNOTE: The pre-loaded answer box contains already code for the ray sphere intersection and sorts the intersection points such that t1 is the first intersection point with the original sphere.\nAdd additional code such that the function returns instead the intersection points with the \"cut-sphere\".\nThe cutting plane n.p=a is defined by the variables n (type Vector) and a (type double).\nHINT: Compute the ray-plane intersection and develop an algorithm to decide whether the ray intersects the round (un-cut part) of the sphere, the cutting plane, or doesn't intersect the cut sphere at all (e.g. the ray might pass through the cut-off part of the sphere)\nIMPORTANT: If the ray first intersects the cutting plane of the cut sphere (the flat part of it) then you need to set cuttingPlaneIntersected = true; . This is used in the normal calculation and without the automarker will mark your solution as false.\nNote: The following variables and functions are already defined for you to use:\nThe plane n.p=a is defined by the variables n (type Vector) and a (type double).\nVector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector\nVector: v1-v2 - subtracts v2 from v1 and returns resulting vector\nVector: v1 * t - scales the vector v1 by t and returns resulting vector\nVector v.Scale(float a, float b, float c) - scales each component of the vector v\nfloat v1.Dot(Vector v2) - returns the dot product of vector v1 and v2\nVector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2\nAfter completing the code in the pre-loaded answer box you should get the images below:\nImage description: The image shows a sphere shown in red with a chunk cut off, in front of a blue and green background. Some shadows of the object are cast on the ground.\nImage description: The image shows the cut off chunk placed on the ground, in front of a blue and green background. Some shadows of the object are cast on the ground.\nTemplate code:\ndouble CutSphere::Intersect(Vector source, Vector d)\n{\n\t// A, B, and C are the parameters of quadratic equation for finding the \n\t// ray intersection parameter t (see slide 16 of the \"Ray Tracing\" lecture notes)\n\tfloat A = d.Dot(d);\n\tfloat B = 2 * source.Dot(d);\n\tfloat C = source.Dot(source) - 1;\n\tfloat t; // the parameter t for the closest intersection point or ray with the sphere. If no intersection t=-1.0\n\t// BEGIN SOLUTION RAY-SPHERE INTERSECTION\n\tif (B * B - 4 * A * C <= 0) return t=-1;  // no hit\n\tfloat t1;\n\tif (B > 0)   // for numerical precision\n\t\tt1 = (-B - sqrt(B * B - 4 * A * C)) / (2 * A);\n\telse\n\t\tt1 = (-B + sqrt(B * B - 4 * A * C)) / (2 * A);\n\tfloat t2 = C / (A * t1); // easier way to get t2\n\t// END SOLUTION RAY-SPHERE INTERSECTION\n\t// if t1>t2 swap, so t1 is always first intersection point\n\tfloat temp;\n\tif (t1 > t2) {\n\t\ttemp = t1;\n\t\tt1 = t2;\n\t\tt2 = temp;\n\t}\n\tt = t1;\n\tcuttingPlaneIntersected = false; // variable of type bool - true if ray first intersects the flat part of the cut sphere\n\t// ===================================================================\n\t// == The above method code computes the intersection parameters of ==\n\t// == the ray with the sphere. Add additional code such that the    ==\n\t// == function returns instead the intersections points with the    ==\n\t// == \"cut-sphere\".                                                 ==\n\t// == Tip: Compute the ray-plane interscetion and develop an        ==\n\t// ==      algorithm to decide whether the ray intersected the      ==\n\t// ==      round (un-cut part) of the sphere, the cutting plane,    ==\n\t// ==      or doesn't intersect the cut spere at all (e.g. the ray  ==\n\t// ==      might pass through the cut-off part of the sphere        ==\n    // == IMPORTANT: If the ray first intersects the cutting plane of   ==\n\t// ==            the cut sphere (the flat part of it) then you need ==\n\t// ==            to set cuttingPlaneIntersected = true;             ==\n\t// ==            This is used in the normal calculation and without ==\n\t// ==            the automarker will mark your solution as false    ==\n\t// ===================================================================\n    // Please complete the missing code\n\treturn t;\n}",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b36b",
        "question": "In this exercise you need to complete the function below defining a Ray-CutSphere Intersection:\ndouble CutSphere::Intersect(Vector source, Vector d)\nNOTE: The pre-loaded answer box contains already code for the ray sphere intersection and sorts the intersection points such that t1 is the first intersection point with the original sphere.\nAdd additional code such that the function returns instead the intersection points with the \"cut-sphere\".\nThe cutting plane n.p=a is defined by the variables n (type Vector) and a (type double).\nHINT: Compute the ray-plane intersection and develop an algorithm to decide whether the ray intersects the round (un-cut part) of the sphere, the cutting plane, or doesn't intersect the cut sphere at all (e.g. the ray might pass through the cut-off part of the sphere)\nIMPORTANT: If the ray first intersects the cutting plane of the cut sphere (the flat part of it) then you need to set cuttingPlaneIntersected = true; . This is used in the normal calculation and without the automarker will mark your solution as false.\nNote: The following variables and functions are already defined for you to use:\nThe plane n.p=a is defined by the variables n (type Vector) and a (type double).\nVector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector\nVector: v1-v2 - subtracts v2 from v1 and returns resulting vector\nVector: v1 * t - scales the vector v1 by t and returns resulting vector\nVector v.Scale(float a, float b, float c) - scales each component of the vector v\nfloat v1.Dot(Vector v2) - returns the dot product of vector v1 and v2\nVector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2\nAfter completing the code in the pre-loaded answer box you should get the images below:\nImage description: The image shows a sphere shown in red with a chunk cut off, in front of a blue and green background. Some shadows of the object are cast on the ground.\nImage description: The image shows the cut off chunk placed on the ground, in front of a blue and green background. Some shadows of the object are cast on the ground.\nTemplate code:\ndouble CutSphere::Intersect(Vector source, Vector d)\n{\n\t// A, B, and C are the parameters of quadratic equation for finding the \n\t// ray intersection parameter t (see slide 16 of the \"Ray Tracing\" lecture notes)\n\tfloat A = d.Dot(d);\n\tfloat B = 2 * source.Dot(d);\n\tfloat C = source.Dot(source) - 1;\n\tfloat t; // the parameter t for the closest intersection point or ray with the sphere. If no intersection t=-1.0\n\t// BEGIN SOLUTION RAY-SPHERE INTERSECTION\n\tif (B * B - 4 * A * C <= 0) return t=-1;  // no hit\n\tfloat t1;\n\tif (B > 0)   // for numerical precision\n\t\tt1 = (-B - sqrt(B * B - 4 * A * C)) / (2 * A);\n\telse\n\t\tt1 = (-B + sqrt(B * B - 4 * A * C)) / (2 * A);\n\tfloat t2 = C / (A * t1); // easier way to get t2\n\t// END SOLUTION RAY-SPHERE INTERSECTION\n\t// if t1>t2 swap, so t1 is always first intersection point\n\tfloat temp;\n\tif (t1 > t2) {\n\t\ttemp = t1;\n\t\tt1 = t2;\n\t\tt2 = temp;\n\t}\n\tt = t1;\n\tcuttingPlaneIntersected = false; // variable of type bool - true if ray first intersects the flat part of the cut sphere\n\t// ===================================================================\n\t// == The above method code computes the intersection parameters of ==\n\t// == the ray with the sphere. Add additional code such that the    ==\n\t// == function returns instead the intersections points with the    ==\n\t// == \"cut-sphere\".                                                 ==\n\t// == Tip: Compute the ray-plane interscetion and develop an        ==\n\t// ==      algorithm to decide whether the ray intersected the      ==\n\t// ==      round (un-cut part) of the sphere, the cutting plane,    ==\n\t// ==      or doesn't intersect the cut spere at all (e.g. the ray  ==\n\t// ==      might pass through the cut-off part of the sphere        ==\n    // == IMPORTANT: If the ray first intersects the cutting plane of   ==\n\t// ==            the cut sphere (the flat part of it) then you need ==\n\t// ==            to set cuttingPlaneIntersected = true;             ==\n\t// ==            This is used in the normal calculation and without ==\n\t// ==            the automarker will mark your solution as false    ==\n\t// ===================================================================\n    // Please complete the missing code\n\treturn t;\n}",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b37a",
        "question": "In this exercise you need to complete the normal calculation for the Ray-CutSphere Intersection from the previous question. Note that you can complete this question even if you were unable to implement the intersection function correctly.\nPlease implement the function\nVector CutSphere::Normal(Vector p)\nNOTE: The function should return the correct normal of the \"cut: unit sphere at the ray intersection point p. Note that the cut-sphere is a unit sphere with centre at the origin. The normal of the cutting plane is n (type Vector).\nNOTE 2: You can assume that the boolean variable cuttingPlaneIntersected is defined and that it is true if p lies on the flat part of the \"cut\" unit sphere and false otherwise.\nNote: The following variables and functions are already defined for you to use:\nThe plane n.p=a is defined by the variables n (type Vector) and a (type double).\nVector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector\nVector: v1-v2 - subtracts v2 from v1 and returns resulting vector\nVector: v1 * t - scales the vector v1 by t and returns resulting vector\nVector v.Scale(float a, float b, float c) - scales each component of the vector v\nfloat v1.Dot(Vector v2) - returns the dot product of vector v1 and v2\nVector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2\nVector v.Normalize() - returns the normalised version of the vector v\nAfter completing the code in the pre-loaded answer box you should get the image below:\nImage description: The image shows a sphere shown in red with a chunk cut off, in front of a blue and green background. Some shadows of the object are cast on the ground.",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    },
    {
        "id": "2023b37b",
        "question": "In this exercise you need to complete the normal calculation for the Ray-CutSphere Intersection from the previous question. Note that you can complete this question even if you were unable to implement the intersection function correctly.\nPlease implement the function\nVector CutSphere::Normal(Vector p)\nNOTE: The function should return the correct normal of the \"cut: unit sphere at the ray intersection point p. Note that the cut-sphere is a unit sphere with centre at the origin. The normal of the cutting plane is n (type Vector).\nNOTE 2: You can assume that the boolean variable cuttingPlaneIntersected is defined and that it is true if p lies on the flat part of the \"cut\" unit sphere and false otherwise.\nNote: The following variables and functions are already defined for you to use:\nThe plane n.p=a is defined by the variables n (type Vector) and a (type double).\nVector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector\nVector: v1-v2 - subtracts v2 from v1 and returns resulting vector\nVector: v1 * t - scales the vector v1 by t and returns resulting vector\nVector v.Scale(float a, float b, float c) - scales each component of the vector v\nfloat v1.Dot(Vector v2) - returns the dot product of vector v1 and v2\nVector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2\nVector v.Normalize() - returns the normalised version of the vector v\nAfter completing the code in the pre-loaded answer box you should get the image below:\nImage description: The image shows a spherical cap, or a sphere with a portion cut off. The cut portion of the sphere is not shown, and the background behind that portion is shown, since light would past through the cut portion of the sphere.",
        "answer": "NULL",
        "generated": [
            "EMPTY 1",
            "EMPTY 2",
            "EMPTY 3",
            "EMPTY 4",
            "EMPTY 5",
            "EMPTY 6",
            "EMPTY 7",
            "EMPTY 8",
            "EMPTY 9",
            "EMPTY 10"
        ]
    }
]