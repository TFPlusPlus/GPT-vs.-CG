Consider a plane
P
defined by the equation
2x+z=1
and a point
M = \begin{pmatrix}-3\\2 \\ 7 \end{pmatrix}
on this plane.

Which statement about the normalized vector
v
being orthogonal to the plane
P
at
M
is true?



Select one:

a.
v = \frac{1}{\sqrt{62}}\begin{pmatrix}-3\\2\\7 \end{pmatrix}




b.
v = \frac{1}{\sqrt{5}}\begin{pmatrix}-3\\2\\7 \end{pmatrix}




c.
None of the others


d.
v = \frac{1}{\sqrt{5}}\begin{pmatrix}2\\0\\1 \end{pmatrix}




e.
v = \frac{1}{\sqrt{62}}\begin{pmatrix}2\\0\\1 \end{pmatrix}
The correct answer is:
v = \frac{1}{\sqrt{5}}\begin{pmatrix}2\\0\\1 \end{pmatrix}

~~

Consider the point
P
, represented in 3D homogenous coordinates as
P = \begin{pmatrix} 3 \\ 2 \\3 \\1 \end{pmatrix}
.

What statement about
P'
, the transformed point
P
after first performing a translation by
\begin{pmatrix} 1 \\ -1 \\ -1 \\ 0 \end{pmatrix}
, then a rotation by -90 degrees around the z-axis, then a scaling by 2 in the x and y axes is true?



a.
None of the others.


b.
P' = \begin{pmatrix} 8 \\ 2 \\ -2 \\ 1 \end{pmatrix}



c.
P' = \begin{pmatrix} -2 \\ 8 \\ 2 \\ 1 \end{pmatrix}



d.
P' = \begin{pmatrix} 2 \\ -8 \\ 2 \\ 1 \end{pmatrix}


e.
P' = \begin{pmatrix} 8 \\ 8 \\ 2 \\ 1 \end{pmatrix}


The correct answer is:
P' = \begin{pmatrix} 2 \\ -8 \\ 2 \\ 1 \end{pmatrix}

~~
Consider a scene with a single light source, that emits white light. This light passes through one translucent object such that red light is reflected while other light is transmitted. After passing through this object, the light then hits a second, opaque object that appears yellow.

You can assume that no objects in the scene other than the light source emit light, and that the only light interactions that may occur are transmission, reflection, and absorption.

Which of the following statements about the second object is true?

Question 3Answer

a.
The object's surface must reflect red light, and absorb blue and green light.


b.
The object's surface must absorb blue light, reflect green light, and may either absorb or reflect red light.


c.
The object's surface must reflect red and green light, and absorb blue light.


d.
The scene as described is not possible.


e.
None of the others.
~~
You are working for "Fancy Fun Furniture", a company selling furniture online using VR representations. Your manager asks you to create models of different tables and chairs, which all have a blocky appearance with rounded edges and corners. What modelling technique would be most suitable for this?
Question 4Select one:

a.
Define all polygons manual


b.
Parametric surfaces


c.
Point clouds


d.
Subdivision surfaces


e.
Implicit surfaces

The correct answer is: Subdivision surfaces

~~
Given is a equilateral triangle. What colours do you need to specify for the vertices in order to make the centre point light grey (RGB value (2/3, 2/3, 2/3))?


Question 5Select one:

a.
The vertices must be red, yellow and blue.


b.
The vertices must be cyan, magenta, and yellow.


c.
The vertices must be magenta, green and blue.


d.
The vertices must be cyan, red and yellow.

e.
The vertices must be red, green and blue.
The correct answer is: The vertices must be cyan, magenta, and yellow.
~~
Given is a 3D model of a clock where the normal at the centre of the clock face is aligned with the z-axis. The hour hand points at 12 o'clock. What OpenGL rotation command rotates the hour hand such that it points at 4 o'clock?

Question 6Select one:

a.
glRotatef(-135 0, 0, 1);


b.
glRotatef(135, 0, 0, 1);


c.
glRotatef(-120, 0, 0, 1);


d.
glRotatef(120, 0, 0, 1);


e.
glRotatef(150, 0, 0, 1);
The correct answer is: glRotatef(-120, 0, 0, 1);

~~
The image below on the left is used to texture map a rectangle as illustrated in the image below on the right. Assume the bottom-left vertex of the rectangle has the texture coordinates (2, 1) and that the texture parameter GL_REPEAT is set for both texture coordinate directions.

What are the texture coordinates of the other three vertices?

NOTE: the texture coordinate of the bottom-left vertex is (2,1) and not (0,0)!

texture mapped polygon
Question 7Select one:

a.
Bottom-right vertex: (-2, 1); Top-left vertex: (2, 2.5); Top-right vertex: (-2, 2.5)

b.
Bottom-right vertex: (4, 0); Top-left vertex: (0, 1.5); Top-right vertex: (4, 1.5)

c.
Bottom-right vertex: (-4, 0); Top-left vertex: (0, 1.5); Top-right vertex: (-4, 1.5)

d.
Bottom-right vertex: (-4, 1); Top-left vertex: (0, 2.5); Top-right vertex: (-4, 2.5)

e.
Bottom-right vertex: (6, 1.5); Top-left vertex: (2, 2.5); Top-right vertex: (6, 2.5)

The correct answer is: Bottom-right vertex: (-2, 1); Top-left vertex: (2, 2.5); Top-right vertex: (-2, 2.5)

~~

The texture image below on the left is mapped onto a triangle producing  the picture below on the right.

TextureMapping_M001_Final2022

Assumed the texture is repeated in both coordinate directions and the texture coordinate of the bottom left vertex is (0, 0).

What are the texture coordinates at the top-left and top-right vertex of the triangle?



Question 8Select one:

a.
The texture coordinate of the top-left vertex is (0, 1) and of the top-right vertex (3, 0).

b.
The texture coordinate of the top-left vertex is (1, 0) and of the top-right vertex (3, 0).

c.
The texture coordinate of the top-left vertex is (1, 0) and of the top-right vertex (0, 3).

d.
The texture coordinate of the top-left vertex is (0, 1) and of the top-right vertex (0, 3).

e.
The texture coordinate of the top-left vertex is (0, 1) and of the top-right vertex (3, 1).

The correct answer is: The texture coordinate of the top-left vertex is (0, 1) and of the top-right vertex (3, 0).

~~

Given is an ellipsoid obtained by first scaling a unit sphere by (s_x, s_y, s_z) and then translating it by \((t_x, t_y, t_z)\). What is the normal direction n (not necessarily normalised) at the point \(P=(p_x, p_y, p_z)\) on the surface of  the ellipsoid?

HINT: Solve this question using your solution to Q4 of the CodeRunner "Ray Tracing" programming quiz or use the fact that if an object is transformed by M then the normal is transformed by {\bf M}^{-T}. 

Question 9Select one:

a.
 \(n=(p_x/s_x-t_x, p_y/s_y-t_y, p_z/s_z-t_z)\)


b.
 \(n=((p_x-t_x)/s_x, (p_y-t_y)/s_y, (p_z-t_z)/s_z)\)


c.
 \(n=((p_x+t_x)/s_x^2, (p_y+t_y)/s_y^2, (p_z+t_z)/s_z^2)\)


d.
 \(n=((p_x-t_x)/s_x^2, (p_y-t_y)/s_y^2, (p_z-t_z)/s_z^2)\)


e.
 \(n=((p_x+t_x)/s_x, (p_y+t_y)/s_y, (p_z+t_z)/s_z)\)

The correct answer is:  \(n=((p_x-t_x)/s_x^2, (p_y-t_y)/s_y^2, (p_z-t_z)/s_z^2)\)

~~

Given is a sphere centered at the origin with radius r=3 and a ray

$$p(t)=
\begin{pmatrix} 4 \\ -1 \\ 2 \end{pmatrix}
+t
\begin{pmatrix} -2 \\ 1 \\ -1 \end{pmatrix}
$$.

Which of the following statements is true?

Question 10Select one:

a.
The ray intersects the sphere in two points p(t1) and p(t2) where t1<1 and t2>1.


b.
The ray intersects the sphere in exactly one point p(t) (i.e. it touches the sphere), where t>1.


c.
The ray intersects the sphere in exactly one point p(t) (i.e. it touches the sphere), where t<1.


d.
The ray does not intersect the sphere.


e.
The ray intersects the sphere in two points p(t1) and p(t2) where t1>1 and t2>1.

The correct answer is: The ray intersects the sphere in two points p(t1) and p(t2) where t1<1 and t2>1.

~~

Given is a quadratic spline with the power basis $$T=\begin{pmatrix} t^2 & t & 1\end{pmatrix}$$ and the basis matrix:



$$\begin{pmatrix}

2 & -1 & -1\\

1 & -2 & 1 \\
1 & 1 & -1
\end{pmatrix}$$

Which statement about the resulting basis functions B_1(t), B_2(t), and B_3(t) is true?

Question 11Select one:

a.
The basis functions are all cubic.


b.
B_1(t)=2*t^2-t-1


c.
The sum of the three basis functions is always 1.


d.
B_3(t) is positive for 0<=t<=1


e.
The basis functions are the basis functions of a quadratic Bezier curve.

The correct answer is: The sum of the three basis functions is always 1.

~~

Which coefficients of the linear mapping operation, g(x,y)=af(x,y) + b, will map the pixel value f(x,y)=75 to g(x,y)=88 and pixel value f(x,y)=155 to g(x,y)=216?


 

Which effect does this linear mapping operation defined by a and b have, when applied to an image?

~~~

Consider the 4x4 table representing the greyscale (8-bit) image J below. Compute the effect of a logarithmic contrast stretching on the image, which aims to increase the dynamic range of darker regions in the image.

The logarithmic contrast stretching operation transforms the input image J(x,y) pixelwise to an output image G(x,y) according to the equation:

G(x,y) = \frac{log(1+J(x,y))}{log(1 + Q)}

Here Q is the maximal greyvalue of the greyscale range of the input image.

The logarithmic function is applied to each input pixel of the 8 bit input range, and generates an output in the range between 0 and 1. You finally have to transform this output range to the same (8-bit) range that the input image has. Round to the nearest integer.

After computation of G, what is the pixel value of the final resulting image at the pixel location (x=1, y=3)?
3	8	8   8   8
2	16  4   4   16
1	32  128 255 32
0	16	64	64  16
    0	1	2	3
The bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.

Question 13Select one:

a.
255


b.
161


c.
74


d.
130


e.
101


f.
223


g.
192


h.
None of the others.
 
The correct answer is: 101

~~~
Consider the 4x4 table representing the grayscale image J below. What is the result when a 3x3 median filter is applied? For boundary handling, use BoundaryPaddingZero.

3	0	8	16	64
2	8	16	32	64
1	16	32	64	128
0	64	64	128	128
    0	1	2	3
The bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.

Value of median filtered image at x=0, y=3?
 

Value of median filtered image at x=2, y=1?
 


Value of median filtered image at x=3, y=1?

~~~

Given is a function drawShape() which draws a wireframe representation of the letter "L" in the xy-plane as shown in the image below.


Image description: A letter L is placed on the x-y plane. The vertices on the shape are p1 = (0, 0, 0), p2 = (0, 2, 0), p3 = (1.5, 0, 0).

Please write OpenGL code to transform this shape such that you obtain the scene displayed in the image below:


Image description: A letter L with twice the size is placed on the x-z plane. The vertices on the shape are p1 = (0, 0, 0), p2 = (0, 0, 4), p3 = (3, 0, 0).



IMPORTANT:

Please only use OpenGL transformations, e.g. glScalef, glTranslatef, glRotatef

Please do NOT draw the shape itself - this is done automatically by the uploaded code

~~~

Given is a function drawShape() which draws a wireframe representation of the letter "F" in the xy-plane as shown in the image below.


Wireframe representation of the letter "F" in the xy-plane

Please write OpenGL code to transform this shape such that you obtain the scene displayed in the image below:



Transformed shape



IMPORTANT:

Please only use OpenGL transformations, e.g. glScalef, glTranslatef, glRotatef

Please do NOT draw the shape itself - this is done automatically by the uploaded code

~~~

Given is an RGB colour cube with side length 2 as illustrated in the image below"


RGB colour cube with side length 2

Please write OpenGL code to rotate this cube as illustrated in the image below.

Transformed RGB colour cube



IMPORTANT:

Please only use OpenGL transformations, e.g. glTranslatef, glRotatef

Please do NOT draw the shape itself - this is done automatically by the uploaded code

~~~

Given is a function drawTorus() which draws a torus with colored "blobs" centred at the origin and aligned with the z-axis as shown in the image below.


Torus centered at origin and aligned with z-axis

Please write OpenGL code to render the the chain of tori displayed in the image below:

Chain of tori

Note that the second torus is rotated such that it lies in the xz-plane and has a centre of (1.5, 0, 0), and the third torus lies again in the zy-plane and has a centre of (0, 1.5, 0).



IMPORTANT:

Your code must first draw the torus centered at the origin, then the torus centered at (1.5, 0, 0), and then the torus centered at (0, 1.5, 0). Your code should have the format:

<insert your transformations>

drawTorus();

<insert your transformations>

drawTorus();

<insert your transformations>

drawTorus();



You can use any OpenGL transformations, e.g. glRotatef, glTranslatef, glScalef, glPushMatrix and glPopMatrix;

~~~
The image below is used to texture map a rectangle:

Mitre Peak

The texture mapping code to be used is:

glBegin(GL_QUADS);
glTexCoord2f(0,2);
glVertex3f(0,0,0);
glTexCoord2f(A,C);
glVertex3f(6,0,0);
glTexCoord2f(A,B);
glVertex3f(6,4,0);
glTexCoord2f(0,B);
glVertex3f(0,4,0);
glEnd();
and produces the image shown below:



Texture mapped rectangle

Please copy and paste the following code to define the correct values for the variables A, B and C, i.e.

A=<Your Answer>;
B=<Your Answer>;
C=<Your Answer>;

~~~

The image below is used to texture map a square:

Colour square

The texture mapping code to be used is:

glBegin(GL_QUADS);
glTexCoord2f(0.0,0.5);
glVertex3f(0,0,0);
glTexCoord2f(A,B);
glVertex3f(4,0,0);
glTexCoord2f(C,D);
glVertex3f(4,4,0);
glTexCoord2f(E,F);
glVertex3f(0,4,0);
glEnd();
and produces the image shown below:

Textured square

Please use the following code to define the correct values for the variables A, B, C, D, E, F. NOTE: The texture coordinates must be between 0 and 1. Write the correct values into the answer space using C/C++ notation.

A=?;
B=?;

etc.

~~~

In this exercise you need to complete the function below defining an intersection between a Ray and a convex quadrilateral with circular hole. The convex quadrilateral (and its circular hole) lie on a plane with the normal n. The quadrilateral is defined by four vertices A, B, C and D, and the circular hole by its centre and radius.


Complete the template in the answer space for the function for computing the intersection between a ray and a quadrilateral with a circular hole. You can use the algorithms explained in the lecture slide and/or use any of your solutions of the graded and ungraded CodeRunner quizzes.

NOTE: A point is inside a convex quadrilateral, if it lies on the same side of all edges when traversing the edges in clockwise or anti-clockwise order. We can hence use the same inside-outside test as for the triangle, except that we have four instead of three edges.



double QuadWithCircleHole::Intersect(Vector source, Vector d)
{
	// complete calculation of ray-quadrilateral-with-circular-hole intersection in the answer box below
	// and return correct value for t. If there is no intersection t should be -1.0
}
Note: The following variables and functions are already defined for you to use:

Vector A, B, C, D - coordinates of the 4 vertices of the convex quadrilateral in winding order (either clockwise or anti-clockwise)

Vector n - normal of the plane of the quadrilateral

Vector Centre - centre of the circular hole

double radius - radius of the circular hole



Vector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector

Vector: v1-v2 - subtracts v2 from v1 and returns resulting vector

Vector: v1 * t - scales the vector v1 by t and returns resulting vector

Vector v.Scale(float a, float b, float c) - scales each component of the vector v

float v1.Dot(Vector v2) - returns the dot product of vector v1 and v2

Vector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2

You can compute the length of a vector v as "sqrt(v.Dot(v))"

Please paste the completed code fragment into the answer space. If your solution is correct you should get the following image (note: the quadrilateral is the green surface at the bottom and the circular hole appears blue (since we can see the background colour through it):

OpenGL_RayTracing_RayQuadCircleHoleIntersection_M008

~~~
Given is a cubic spline curve c(t)=T M G with the geometric constraint vector
G=(p0, p1, r0, r0.5)^T
The curve c(t) is defined by the four conditions c(0)=p0 (start point), c(1)=p1 (end point), c'(0)=r0 (start tangent), and c'(0.5)=r0.5 (mid-point tangent).

Implement this curve by computing its basis functions and completing the code fragment below.

TIP: You can use the same idea we used in the lecture to derive the basis functions of the Hermite curve.
Note that in order to get the basis functions you need to invert a 4x4 matrix.
This is easiest done by using an online tool such as:
https://www.wolframalpha.com/calculators/matrix-inverse-calculator

Please write your answer into the answer space using the following format:

double Basis1(double t){ return <Insert code>;} // B1(t) 
double Basis2(double t){ return <Insert code>;} // B2(t) 
double Basis3(double t){ return <Insert code>;} // B3(t)
double Basis4(double t){ return <Insert code>;} // B4(t)

CVec3df c(float t, CVec3df p0, CVec3df p1, CVec3df r0, CVec3df r05) { 
   CVec3df p=<Insert code>; 
   return p; 
}
The first test case uses the geometric constraints

p0.setVector(4, 0, 0);      // This is p0
p1.setVector(0, 0, 3);      // This is p1
r0.setVector(-10, 10, 0);   // This is r0
r05.setVector(0, 0, 10);    // This is r05
and should result in the image below:

OpenGL_ParametricCurvesSurfs_ConstructSplineCurve_H008


~~~
Given is a greyscale 8 bit input image in the form of a pixel array (a list of pixel rows, with each row represented again as a list). Every pixel contains an integer value between 0 and 255.

Write a Python3 function 'computeInterquartileRange3x3(pixel_array, image_width, image_height)' which computes and returns a filtered image containing the interquartile range of the values in the 3x3 pixel neighourhood. Similar to the standard deviation, the interquartile range measures the variation of greyvalues in a neighbourhood.

We define the interquartile range as the difference between the 25th percentile and the 75th percentile of the values in the 3x3 neighbourhood. While the 50th percentile is the median of all values in the neighbourhood, the 25th percentile is the median of the values smaller (<) than the median, and the 75th percentile is the median of the values larger (>) than the median. Remember, if any of these subsets has an even number of values, then we compute the mean of the two values in the middle.

Border handling: Border pixels should be handled with the BorderIgnore strategy, with pixels at the boundary of the output image set to 0.

Return the result image in our list of lists representation. Resulting pixels are floating point values, without any rounding!



Note: You may assume that the Python3 function 'createInitializedGreyscalePixelArray(image_width, image_height, initValue)' is available, which creates an empty greyscale array (values 0) as a list of lists of integers or a greyscale array with values 0.0 as a list of lists of floats (if initValue is 0.0).

For example:

Test	Result
image_width = 6
image_height = 5
pixel_array = [ [6, 3, 2, 6, 4, 7], 
                [5, 3, 2, 7, 0, 6], 
                [6, 2, 7, 7, 1, 7], 
                [7, 6, 6, 2, 7, 3], 
                [2, 2, 2, 5, 1, 2] ]
printPixelArray(computeInterquartileRange3x3(pixel_array, image_width, image_height))
0.0 0.0 0.0 0.0 0.0 0.0
0.0 4.0 5.0 5.5 4.5 0.0
0.0 4.0 5.0 5.5 5.5 0.0
0.0 4.5 4.5 5.5 5.5 0.0
0.0 0.0 0.0 0.0 0.0 0.0
image_width = 7
image_height = 6
pixel_array = [ [244, 126, 101, 174, 168, 75, 62], 
                [155, 145, 15, 149, 116, 163, 238], 
                [63, 138, 132, 207, 74, 227, 163], 
                [25, 9, 85, 172, 202, 108, 193], 
                [85, 123, 49, 53, 106, 60, 197], 
                [113, 196, 35, 19, 126, 130, 48] ] 
printPixelArray(computeInterquartileRange3x3(pixel_array, image_width, image_height))
0.0 0.0 0.0 0.0 0.0 0.0 0.0
0.0 68.0 48.0 83.5 95.0 123.0 0.0
0.0 121.5 110.5 107.5 92.5 102.5 0.0
0.0 90.5 104.0 123.5 137.5 109.5 0.0
0.0 88.0 120.5 107.0 94.5 112.0 0.0
0.0 0.0 0.0 0.0 0.0 0.0 0.0
~~~

Given is a greyscale input image in the form of a pixel array (a list of pixel rows, with each row represented again as a list). Every pixel contains an integer value between 0 and nr_bins-1! For a 3 bit input image, nr_bins is 8.

Write a Python3 function 'computeLookupTableHistEq(pixel_array, image_width, image_height, nr_bins)' which computes the lookup table for histogram equalization of the input image according to the strategy we discussed in the lecture.

Return solely the lookup table as a list datastructure, with the length of the lookup table being equal to the number of bins. The datatype of the lookup table is floating point. You don't have to do any rounding of the result values.



Note: You can assume that a method computeCumulativeHistogram(pixel_array, image_width, image_height, nr_bins) is available for your use, which you can call from within your code (see below).


def computeCumulativeHistogram(pixel_array, image_width, image_height, nr_bins = 256):

    # compute histogram
    histogram = [0.0 for q in range(nr_bins)]
    
    for y in range(image_height):
        for x in range(image_width):
            histogram[pixel_array[y][x]] += 1.0


    # compute cumulative histogram
    cumulative_histogram = [0.0 for q in range(nr_bins)]

    running_sum = 0.0
    for q in range(nr_bins):
        running_sum += histogram[q]
        cumulative_histogram[q] = running_sum

    return cumulative_histogram
For example:

Test	Result
image_width = 6
image_height = 5
pixel_array = [ [6, 3, 2, 6, 4, 7], 
                [5, 3, 2, 7, 0, 6], 
                [6, 2, 7, 7, 1, 7], 
                [7, 6, 6, 2, 7, 3], 
                [2, 2, 2, 5, 1, 2] ]
nr_bins = 8
lookup_table= computeLookupTableHistEq(pixel_array, image_width, image_height, nr_bins)
for q in range(len(lookup_table)):
   print("{}: {}".format(q, round(lookup_table[q], 2)))
0: 0.0
1: 0.48
2: 2.41
3: 3.14
4: 3.38
5: 3.86
6: 5.31
7: 7.0
image_width = 6
image_height = 5
pixel_array = [ [3, 7, 2, 3, 2, 3], 
                [0, 4, 3, 1, 4, 4], 
                [3, 1, 2, 2, 2, 2], 
                [1, 3, 3, 1, 2, 2], 
                [4, 4, 3, 2, 0, 0] ]
nr_bins = 8
lookup_table= computeLookupTableHistEq(pixel_array, image_width, image_height, nr_bins)
for q in range(len(lookup_table)):
   print("{}: {}".format(q, round(lookup_table[q], 2)))
0: 0.0
1: 1.04
2: 3.37
3: 5.44
4: 6.74
5: 6.74
6: 6.74
7: 7.0
~~~