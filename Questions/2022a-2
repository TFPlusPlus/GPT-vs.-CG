2022a01

Given a triangle comprised of the following vertex array:
vertices = {(0.0, 0.0, 0.0), (2.0, 3.0, 0.0), (-3.0, 3.0, -1.0)}
If the triangle is drawn using the indices {0, 1, 2}, and anticlockwise winding order represents front faces, which of the following represents the surface normal of the front face of the triangle?
a. $$\frac{1}{\sqrt{238}}\begin{pmatrix} 3 \\ -2 \\-15 \end{pmatrix}$$
b. $$\frac{1}{\sqrt{238}}\begin{pmatrix} 3 \\ -15 \\-2 \end{pmatrix}$$
c. $$\frac{1}{\sqrt{238}}\begin{pmatrix} -3 \\ 2 \\15 \end{pmatrix}$$
d. None of the others.
e. $$\frac{1}{\sqrt{238}}\begin{pmatrix} -3 \\ 15 \\2 \end{pmatrix}$$

The correct answer is:
$$\frac{1}{\sqrt{238}}\begin{pmatrix} -3 \\ 2 \\15 \end{pmatrix}$$

2022a02

The orthogonal projection of vector
$$\textbf{u} = \begin{pmatrix}0\\2\\3 \end{pmatrix}$$
onto vector
$$\textbf{v} = \begin{pmatrix} 1 \\3\\0 \end{pmatrix}$$
is equal to:
Select one:
a. $$\frac{6}{10}\begin{pmatrix}0 \\2 \\3 \end{pmatrix}$$
b. $$\frac{6}{10}\begin{pmatrix}1 \\3 \\0 \end{pmatrix}$$
c. None of the others
d. $$\frac{6}{\sqrt{10}} \begin{pmatrix}0\\2 \\3 \end{pmatrix}$$
e. $$\frac{6}{\sqrt{10}}$$

The correct answer is:
$$\frac{6}{10}\begin{pmatrix}1 \\3 \\0 \end{pmatrix}$$

2022a03

Given a plane
P
defined by the equation:
2x+2y+z=2
, and a point
$$Q = \begin{pmatrix} 1 \\1 \\-2 \end{pmatrix}$$
,
What is the smallest absolute distance between
P
and
Q
?
Select one:
a. None of the others
b. 1
c. 13
d. 2
e. 0
, Q is on the plane, P.

The correct answer is:
0
, Q is on the plane, P.

2022a04

Consider a matrix of 3D geometric transformations in homogeneous coordinates. Which of the following statements about the matrix
$$M = \begin{bmatrix}-1 & 0 & 0 & -4 \\ 0 & -1 & 0 & -1 \\ 0 & 0 & 1 & -4 \\ 0 & 0 & 0 & 1\end{bmatrix}$$
is true?
Select one:
a. M represents a shear parallel to the z axis with magnitude 4 followed by a scaling along the x axis and y axis by -1.
b. M represents a rotation about the z axis by -180 degrees followed by a translation by
$$M = \begin{bmatrix}-1 & 0 & 0 & -4 \\ 0 & -1 & 0 & -1 \\ 0 & 0 & 1 & -4 \\ 0 & 0 & 0 & 1\end{bmatrix}$$
.
c. M represents a scaling along the x axis and y axis by -1 followed by a shear parallel to the z axis with magnitude 4.
d. None of the others
e. M represents a translation by
$$\begin{pmatrix}4 \\ 1 \\ -4\end{pmatrix}$$
followed by a rotation about the z axis by -180 degrees.

The correct answer is: M represents a translation by
$$\begin{pmatrix}4 \\ 1 \\ -4\end{pmatrix}$$
followed by a rotation about the z axis by -180 degrees.

2022a05a

Given are the vertices (labelled in the image)
const int numVertices=8;
const float vertices[numVertices][2] = {{100,100},{400,100},{100,200},{400,200},{100,300},{400,300},{100,400},{400,400}};
Which of the following represents a possible indices array that will generate the image shown below if we use the OpenGL commands glBegin(GL_TRIANGLES) and glEnd()?
Image description: An hourglass shape is shown with the vertices labelled with its index in the array.
a. None of the others.
b. {0, 1, 2, 0, 3, 2, 0, 5, 2, 0, 7, 2, 1, 4, 3, 1, 6, 3, 4, 5, 7, 4, 7, 6}
c. {0, 1, 2, 3, 4, 5, 6, 7}
d. {4, 5, 7, 4, 7, 6, 0, 1, 3, 0, 3, 2, 0, 5, 7, 0, 7, 2, 4, 1, 3, 4, 3, 6}
e. {0, 1, 3, 0, 3, 2, 1, 3, 4, 4, 3, 6, 4, 6, 7, 4, 7, 5, 7, 2, 5, 7, 0, 5}

The correct answer is:
{4, 5, 7, 4, 7, 6, 0, 1, 3, 0, 3, 2, 0, 5, 7, 0, 7, 2, 4, 1, 3, 4, 3, 6}

2022a05b

Given are the vertices (labelled in the image)
const int numVertices=8;
const float vertices[numVertices][2] = {{100,100},{400,100},{100,200},{400,200},{100,300},{400,300},{100,400},{400,400}};
Which of the following represents a possible indices array that will generate the image shown below if we use the OpenGL commands glBegin(GL_TRIANGLES) and glEnd()?
Image description: The shape is formed with multiple shapes listed here. The first shape is a rectangle with the vertices 4, 5, 6, 7; the second shape is a rectangle with the vertices 0, 1, 2, 3; the third shape is a parallelogram with the vertices 0, 2, 5, 7; the fourth shape is a parallelogram with the vertices 1, 3, 4, 6.
a. None of the others.
b. {0, 1, 2, 0, 3, 2, 0, 5, 2, 0, 7, 2, 1, 4, 3, 1, 6, 3, 4, 5, 7, 4, 7, 6}
c. {0, 1, 2, 3, 4, 5, 6, 7}
d. {4, 5, 7, 4, 7, 6, 0, 1, 3, 0, 3, 2, 0, 5, 7, 0, 7, 2, 4, 1, 3, 4, 3, 6}
e. {0, 1, 3, 0, 3, 2, 1, 3, 4, 4, 3, 6, 4, 6, 7, 4, 7, 5, 7, 2, 5, 7, 0, 5}

The correct answer is:
{4, 5, 7, 4, 7, 6, 0, 1, 3, 0, 3, 2, 0, 5, 7, 0, 7, 2, 4, 1, 3, 4, 3, 6}

2022a06

Which of the following statements about drawing meshes is true?
a. By using a mesh data structure, multiple instances of a mesh may be drawn using the same mesh data and different transformations.
b. Meshes can only be used when drawing with triangle primitives.
c. By using a mesh data structure, multiple instances of a mesh may be drawn without increasing rendering time.
d. None of the others.
e. Using an indices array to represent vertex usage will always result in less memory being required to represent a mesh.

The correct answer is:
By using a mesh data structure, multiple instances of a mesh may be drawn using the same mesh data and different transformations.

2022a07

Consider a surface that reflects the colour magenta when three lights are shining on it: one red, one green, one blue.
What will be the reflected colour if the blue light is removed?
a. Green
b. Yellow
c. Black
d. Magenta
e. Red

The correct answer is:
Red

2022a08

The CIE XYZ colour space may be represented as a projection on the 2D plane: x + y + Z = 1.
Given the color (3, 9, 3), what is the corresponding 2D colour?
Select one:
a. None of the others
b. (3, 9)
c. (0.2, 0.6)
d. (3, 15)
e. (0.3, 0.9)

The correct answer is: (0.2, 0.6)

2022a09

Which of the following statements is true for a spectral density function (SDF)?
Select one:
a. None of the others
b. All light sources can be defined by their SDF.
c. The SDF describes the light absorption of a surface.
d. Only natural light can be defined by the SDF.
e. Only artificial light sources can be defined by their SDF.

The correct answer is: All light sources can be defined by their SDF.

2022a10a

Consider the following image of a sphere:
Image description: A sphere is shown surrounded by darkness.
Assuming a scene where the light intensities and reflection coefficients for ambient, diffuse, and specular are non-zero, which types of reflection are enabled for this scene?
a. Ambient, Diffuse, and Specular
b. Diffuse only
c. Ambient and Diffuse
d. Diffuse and Specular
e. Ambient Only

The correct answer is:
Diffuse only

2022a10b

Consider the following image of a sphere:
Image description: A sphere is shown in space. The space surrounding it is black, the sphere itself is shown with a medium level of brightness, and there are no highlights shown on the sphere.
Assuming a scene where the light intensities and reflection coefficients for ambient, diffuse, and specular are non-zero, which types of reflection are enabled for this scene?
a. Ambient, Diffuse, and Specular
b. Diffuse only
c. Ambient and Diffuse
d. Diffuse and Specular
e. Ambient Only

The correct answer is:
Diffuse only

2022a11

Consider a viewport of 800x800 pixels, with a coordinate system that ranges from 0-800 in the x and y axes, where (0, 0) is the bottom left corner of the viewport, and (800, 800) is the top right corner of the viewport.
In this viewport are drawn three triangles, where triangle T1 is drawn in red, triangle T2 is drawn in green, and triangle T3 is drawn in blue. The triangles are also being redrawn in wireframe, such that border pixels are drawn in black. The clear-colour for the viewport is white.
The triangles are being drawn in the order T1, T2, T3, with projection and depth testing set up such that if two triangles occupy the same pixel, the pixel will always be the colour of the more recently drawn triangle.
If the projected vertex locations of the triangles in the viewport are as follows:
T1: {(0, 0, 0), (0, 800, 0), (800, 800, 0)}
T2: {(260, 800, 0), (540, 800, 0), (380, 390, 0)}
T3 {(120, 440, 0), (420, 440, 0), (410, 380, 0)}
What colour will the pixel located at the viewport coordinates (410, 410) be?
a. Blue
b. White
c. Black
d. Red
e. Green

The correct answer is:
Blue

2022a12

Which of the following statements about the Phong illumination model is false?
Select one:
a. Ambient reflection is constant over the entire surface.
b. Diffuse reflection does not vary with the angle between surface normal and view vector.
c. Diffuse reflection models rough surfaces such as clay and cardboard.
d. Diffuse reflection does not vary with the angle between surface normal and light direction.
e. Ambient reflection does NOT depend on the surface normal.

The correct answer is: Diffuse reflection does not vary with the angle between surface normal and light direction.

2022a13

Write a function colinear(), that takes as parameters three 3D vectors representing points, and returns a boolean: true if all three points lie on the same line, false otherwise. Your function should have the following signature:
bool colinear(Vector3 p, Vector3 q, Vector3 r)
You can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z, and that the following functions are available to you:
double dot(Vector3 u, Vector3 v) //dot product
Vector3 cross(Vector3 u, Vector3 v) //cross product
You can assume that the Vector3 class has the following member functions available to you:
Vector3 Vector3.normalized() //returns a vector pointing in the same direction with length 1
double Vector3.magnitude() //returns the length of the vector
You can assume that the Vector3 class supports the following operators:
Vector3 + Vector3
Vector3 - Vector3

NULL

2022a14

Write a function surfaceNormal(), which takes as parameters an array of 3D vectors representing the vertices of an arbitrarily shaped polygon, and an integer representing the number of vertices that make up the polygon. Your function should compute and return a unit vector that best represents the surface normal of the polygon.
You should assume that vertices are given in anticlockwise order, and that front faces are determined using anticlockwise winding order.
You should not assume that the polygon is well formed. Vertices may be co-linear, and they are not necessarily co-planar.
Your function should have the following signature:
Vector3 surfaceNormal(Vector3 vertices[], int numVertices)
You can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z, and that the following functions are available to you:
double dot(Vector3 u, Vector3 v) //dot product
Vector3 cross(Vector3 u, Vector3 v) //cross product
You can assume that the Vector3 class has the following member functions available to you:
Vector3 Vector3::normalized() //returns a vector pointing in the same direction with length 1
double Vector3::magnitude() //returns the length of the vector
You can assume that the Vector3 class supports the following operators:
Vector3 + Vector3
Vector3 - Vector3
Vector3 * double

NULL

2022a15a

Write a function drawGrid(), that generates the image below:
Image description: An arbitrary sheet floating in space.
Your function should have the following signature:
void drawGrid(double width, double height)
The grid consists of rows/columns of squares that span the x-z plane, with each square being made up of two triangles. The width parameter gives the number of of squares the grid contains on the x-axis, and the height parameter gives the number of squares the grid contains on the z-axis.
Each square is exactly one unit wide on both the x and z axes.
The y axis value of each vertex is derived from its location on the x and z axes. The y-axis value is equal to the cosine (in radians) of the x-axis value + the cosine (in radians) of the z-axis value.
You must use GL_TRIANGLES to draw the mesh. You do not need to specify vertex colours.
The vertices must be given in anticlockwise order for the triangles as seen from above. In each pair of triangles, the triangle closer to the origin must be drawn starting from the closest vertex to the origin (minimum x and z), and the triangle farther away from the origin must be drawn starting from the farthest vertex from the origin (maximum x and z).
The grid should fill in each column (each group of height tiles that share x-axis values) before proceeding to the next column.
The image above shows the grid drawn in wireframe. You do not need to specify that drawing will be done in wireframe.
You can assume that if required, you have access to a Vector3 class that represents a 3D vector, and exposes fields named x, y, and z.
You can assume that you have access to standard trigonometric functions such as cos(), and that they assume input parameters are in radians by default.
Important note:
Coderunner requires certain OpenGL functions to use special versions:
Instead of glVertex3d(), use CRVertex3d()

NULL

2022a15b

Write a function drawGrid(), that generates the image below:
Image description: An arbitrary sheet floating in space. The sheet is made up of a grid of squares, with each square being made up of two triangles. The sheet is shown in wireframe.
Your function should have the following signature:
void drawGrid(double width, double height)
The grid consists of rows/columns of squares that span the x-z plane, with each square being made up of two triangles. The width parameter gives the number of of squares the grid contains on the x-axis, and the height parameter gives the number of squares the grid contains on the z-axis.
Each square is exactly one unit wide on both the x and z axes.
The y axis value of each vertex is derived from its location on the x and z axes. The y-axis value is equal to the cosine (in radians) of the x-axis value + the cosine (in radians) of the z-axis value.
You must use GL_TRIANGLES to draw the mesh. You do not need to specify vertex colours.
The vertices must be given in anticlockwise order for the triangles as seen from above. In each pair of triangles, the triangle closer to the origin must be drawn starting from the closest vertex to the origin (minimum x and z), and the triangle farther away from the origin must be drawn starting from the farthest vertex from the origin (maximum x and z).
The grid should fill in each column (each group of height tiles that share x-axis values) before proceeding to the next column.
The image above shows the grid drawn in wireframe. You do not need to specify that drawing will be done in wireframe.
You can assume that if required, you have access to a Vector3 class that represents a 3D vector, and exposes fields named x, y, and z.
You can assume that you have access to standard trigonometric functions such as cos(), and that they assume input parameters are in radians by default.
Important note:
Coderunner requires certain OpenGL functions to use special versions:
Instead of glVertex3d(), use CRVertex3d()

NULL

2022a16a

Write a function projectVertex(), that computes the projection of a vertex on to a plane for the purpose of creating a shadow.
The plane is given in the form ax + by + cz + d = 0
Your function should have the following signature:
Vector3 projectVertex(Vector3 vertex, double a, double b, double c, double d)
The function should return the location of a vertex given by the vertex parameter when projected from the origin on to a plane given by the a, b, c,  & d parameters.
If working correctly, the program will produce the following output:
Image description: A ruby shape on top of a dark triangle on top of a grey square.
You can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z.
Your code can assume that this is a straightforward case for generating shadows: the light source (the origin of the projection) is located at (0, 0, 0), and you do not need to account for any transformations on the object.
You do not need to handle the actual display of the object or the shadow, only the calculation of the shadow vertex location.

NULL

2022a16b

Write a function projectVertex(), that computes the projection of a vertex on to a plane for the purpose of creating a shadow.
The plane is given in the form ax + by + cz + d = 0
Your function should have the following signature:
Vector3 projectVertex(Vector3 vertex, double a, double b, double c, double d)
The function should return the location of a vertex given by the vertex parameter when projected from the origin on to a plane given by the a, b, c,  & d parameters.
If working correctly, the program will produce the following output:
Image description: A red object resembling the shape of a ruby is shown floating in space, with a grey square representing the plane, a triangular shadow of the object is shown on the plane as black.
You can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z.
Your code can assume that this is a straightforward case for generating shadows: the light source (the origin of the projection) is located at (0, 0, 0), and you do not need to account for any transformations on the object.
You do not need to handle the actual display of the object or the shadow, only the calculation of the shadow vertex location.

NULL

2022a17a

Write a function phongDirectionalSource() which implements the achromatic version of the Phong Illumination equation for a directional light source.
If the function is implemented correctly you should get the following result (Note: this image is rendered using only your implementation and does not use OpenGL lights or materials)
Image description: A white circle on top of a grey circle on top of a yellow background.
Your function should have the following signature:
double phongDirectionalSource(double ambientIntensity, double diffuseIntensity, double specularIntensity, double ambientReflecCoef, double diffuseReflecCoef, double specularReflecCoef, double shininess, Vector3 pointOnSurface, Vector3 surfaceNormal, Vector3 incomingLightDirection, Vector3 viewPoint)
A Vector3 class representing a 3D vector is available to you, with the following member functions:
Vector3 Vector3::normalized() //returns a vector pointing in the same direction with length 1
double Vector3::magnitude() //returns the length of the vector
void Vector3::normalize() //normalises the vector (destructive)
In addition, you can assume the + and - operators are available for the Vector3 class.
You can assume that the following functions are also defined:
double dot(Vector3 a, Vector3 b) //returns the dot product of a and b
Vector3 cross (Vector3 a, Vector3 b) //returns the cross product of a and b
double pow(double a, double b) //returns a to the power of b
Hint: The parameter incomingLightDirection refers to the direction of travel of light rays emitted from the light source.

NULL

2022a17b

Write a function phongDirectionalSource() which implements the achromatic version of the Phong Illumination equation for a directional light source.
If the function is implemented correctly you should get the following result (Note: this image is rendered using only your implementation and does not use OpenGL lights or materials)
Image description: The background is bright yellow, and a grey sphere is shown with a medium level of lighting, with a bright white highlight covering a small portion of the surface of the sphere.
Your function should have the following signature:
double phongDirectionalSource(double ambientIntensity, double diffuseIntensity, double specularIntensity, double ambientReflecCoef, double diffuseReflecCoef, double specularReflecCoef, double shininess, Vector3 pointOnSurface, Vector3 surfaceNormal, Vector3 incomingLightDirection, Vector3 viewPoint)
A Vector3 class representing a 3D vector is available to you, with the following member functions:
Vector3 Vector3::normalized() //returns a vector pointing in the same direction with length 1
double Vector3::magnitude() //returns the length of the vector
void Vector3::normalize() //normalises the vector (destructive)
In addition, you can assume the + and - operators are available for the Vector3 class.
You can assume that the following functions are also defined:
double dot(Vector3 a, Vector3 b) //returns the dot product of a and b
Vector3 cross (Vector3 a, Vector3 b) //returns the cross product of a and b
double pow(double a, double b) //returns a to the power of b
Hint: The parameter incomingLightDirection refers to the direction of travel of light rays emitted from the light source.

NULL
