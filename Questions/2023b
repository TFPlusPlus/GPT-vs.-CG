Consider a surface that reflects the colour yellow when three lights are shining on it: one red, one green, one blue.

What will be the reflected colour if the red light is removed?


a.
Yellow


b.
Green


c.
Black


d.
Red


e.
Cyan

The correct answer is:
Green
~~

Given is a 3D medical imaging data set of a head which specifies for each point the radiodensity of the material, i.e., to what extend the material blocks x-rays. For example, bone has a higher value (is less transmissible) than muscle, skin, and fluid. What surface representation is most suitable for rendering the bone layer of the head as illustrated in the image below?
Skull
Select one:

a.
Parametric surfaces


b.
CSG (Constructive Solid Geometry)


c.
Subdivision surfaces


d.
Implicit surfaces


e.
First using a CGS object and then smoothing it using a subdivision surface.

The correct answer is: Implicit surfaces
~~

Which of the following statements about rendering in OpenGL is false (if any)?
Select one:

a.
We can render a cube consisting of 6 square polygons without a depth buffer if we render back faces first and then front faces.


b.
When displaying an animated scene we need to use double buffering to avoid rendering artifacts.


c.
None of the other statements is false, i.e., they are all true.

d.
OpenGL uses the winding order of polygons to determine front and back faces.


e.
When rendering closed 3D surfaces, such as a sphere or cube, we must enable back-face culling since otherwise the resulting image will look wrong.


The correct answer is: When rendering closed 3D surfaces, such as a sphere or cube, we must enable back-face culling since otherwise the resulting image will look wrong.
~~

Given is a equilateral triangle. What colours do we need to specify for the vertices in order to make the centre point dark grey (RGB value (1/3, 1/3, 1/3))?
Select one:

a.
The vertices must be cyan, red and yellow.


b.
The vertices must be magenta, green and blue.

c.
The vertices must be cyan, magenta, and yellow.

d.
The vertices must be red, yellow and blue.


e.
The vertices must be red, green and blue.

The correct answer is: The vertices must be red, green and blue.
~~
Which of the following statements about parametric curves and surfaces is true?
Select one:

a.
The normal of a parametric surface p(s,t) is obtained by interpolating p(0,0), p(0,1), p(1,0), and p(1,1).

b.
When defining a surface-of-revolution the profile curve can be a spline curve, e.g., a Catmul-Rom spline.


c.
Squares and discs can not be represented as parametric surfaces.


d.
The Hermit curve is a quadratic spline.


e.
Bezier curves are always cubic, e.g., quadratic Bezier curves do not exist.

The correct answer is: When defining a surface-of-revolution the profile curve can be a spline curve, e.g., a Catmul-Rom spline.
~~
Given is a light source at the position
L=(1, 3, 0)^T
and an object with the point
P=(1, 2, 1)
.

If we draw the projected shadow of the object on the plane y=1, what is the position P' of the point P projected on the plane y=1?

Hint: Make yourself an illustration of the situation.

Select one:

a.
P'=(2, 1, 3)^T


b.
P'=(1, 1, 2)^T



c.
P'=(2, 1, 0)^T



d.
P'=(0, 1, 1)^T



e.
P'=(1, 1, 3)^T


The correct answer is:
P'=(1, 1, 2)^T

~~
Given are the following vertices:

const int numVertices=7;
const float vertices[numVertices][2] = { {50,50},{300,50},{50,150},{50,200},{200,200},{50,300},{300,300} };



Consider the image shown below.

2D shape

Which calling sequence of these vertices (using glVertex2fv) results in the shape in the image above, if we use the OpenGL commands glBegin(GL_TRIANGLE_FAN) and glEnd()?




Select one:

a.
4, 1, 0, 2, 3, 5, 6


b.
6, 1, 0, 2, 4, 3, 5


c.
0, 1, 2, 3, 4, 5, 6


d.
4, 3, 5, 6, 1, 0, 2


e.
1, 0, 2, 4, 3, 5, 6

The correct answer is: 4, 3, 5, 6, 1, 0, 2
~~
Given is a plane 3x+2y-z=3 and a ray
p(t)= \begin{pmatrix} 1 \\ 0  \\ 1 \end{pmatrix} + t * \begin{pmatrix} -1 \\ c  \\ 0 \end{pmatrix}.

For what value of c is the ray parallel to the plane?
Select one:

a.
c=0


b.
c=0.5


c.
c=1.5


d.
c=-0.5


e.
c=1

The correct answer is: c=1.5
~~
Given is a function drawHouse() which draws a wire frame house in the xy-plane as shown in the image below:

2D House


We now transform the house in two different ways before drawing it:

Drawing 1:
glScalef(2.0, 1.0, 1.0);
drawHouse();

Drawing 2:
glScalef(2.0, 1.0, -1.0);
drawHouse();

Which of the following statements is correct?
Select one:

a.
The two drawings look the same, but the MODEL_VIEW matrices used to transform the house before drawing are different.


b.
The two drawings look different, and the MODEL_VIEW matrices used to transform the house before drawing are different.


c.
The two drawings look the same, and the MODEL_VIEW matrices used to transform the house before drawing are the same.


d.
The transformation is not possible (generates an error).


e.
The two drawings look different, but the MODEL_VIEW matrices used to transform the house before drawing are the same.

The correct answer is: The two drawings look the same, but the MODEL_VIEW matrices used to transform the house before drawing are different.
~~
Which of the 3D homogeneous matrices below first translates a point by the vector
P = \begin{pmatrix} 2 \\ 3 \\ 1  \end{pmatrix}
and then rotates it by 90 degree anti-clockwise around the y-axis?


Answer

a.
None of the others.


b.
\begin{pmatrix} 1 & 0 & 0 & 2 \\ 0 & 1 & 0 & 3
 \\ 0 & 0 & 1 & 1 \\ 0 & 0 & 0 & 1 
\end{pmatrix}



c.
\begin{pmatrix} 0 & 0 & -1 & -1 \\ 0 & 1 & 0 & 3
 \\ 1 & 0 & 0 & 2 \\ 0 & 0 & 0 & 1 
\end{pmatrix}



d.
\begin{pmatrix} -1 & 0 & 0 & -2 \\ 0 & 1 & 0 & 3 \\ 0 & 0 & -1 & -1 \\ 0 & 0 & 0 & 1 
\end{pmatrix}



e.
\begin{pmatrix} 0 & 0 & 1 & 1 \\ 0 & 1 & 0 & 3 \\ -1 & 0 & 0 & -2 \\ 0 & 0 & 0 & 1 \end{pmatrix}


The correct answer is:
\begin{pmatrix} 0 & 0 & 1 & 1 \\ 0 & 1 & 0 & 3 \\ -1 & 0 & 0 & -2 \\ 0 & 0 & 0 & 1 \end{pmatrix}
~~
Given is a triangle with the vertices
A = \begin{pmatrix} 4 \\ 0 \\ 0  \end{pmatrix}, \mbox{   } B = \begin{pmatrix} -1 \\ 0 \\ 0  \end{pmatrix}, \mbox{   }C = \begin{pmatrix} 0 \\ 2 \\ 0  \end{pmatrix}

The RGB colours at these three points are
C_A=(0.0, 0.0, 1.0), \mbox{   }C_B=(0.6, 0.4, 0.2), \mbox{   }C_C=(0.5, 1.0, 0.0)
.

If the triangle is rendered using OpenGL, what is the colour at the point
P = \begin{pmatrix} 0 \\ 1 \\ 0  \end{pmatrix}?


Tip: Make yourself an illustration. Note that the triangle lies on the xy-plane. You should be able to determine the weighting factors for the colour interpolation using your illustration, without doing any complex calculations.

Select one:

a.
C_P=(0.49, 0.66, 0.18)



b.
C_P=(0.45, 0.7, 0.15)



c.
C_P=(0.55, 0.69, 0.2)



d.
C_P=(0.5, 0.6, 0.15)



e.
C_P=(0.52, 0.65, 0.17)


The correct answer is:
C_P=(0.49, 0.66, 0.18)
~~
Given is the following texture image:
Texture image

What texture coordinates do we need to specify if we want to use this texture image to create the textured triangle shown below?
Texture image
Select one:

a.
Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.5)
Texture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)
Texture coordinates for the top vertex of the triangle: (0.75, 1.0)

b.
Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.0)
Texture coordinates for the bottom-right vertex of the triangle: (1.0, 0.0)
Texture coordinates for the top vertex of the triangle: (1.0, 1.0)


c.
Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.0)
Texture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)
Texture coordinates for the top vertex of the triangle: (0.75, 1.0)


d.
Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.75)
Texture coordinates for the bottom-right vertex of the triangle: (0.5, 0.5)
Texture coordinates for the top vertex of the triangle: (0.75, 1.0)


e.
Texture coordinates for the bottom-left vertex of the triangle: (0.75, 0.0)
Texture coordinates for the bottom-right vertex of the triangle: (0.75, 1.0)
Texture coordinates for the top vertex of the triangle: (0.0, 0.5)

The correct answer is: Texture coordinates for the bottom-left vertex of the triangle: (0.0, 0.5)
Texture coordinates for the bottom-right vertex of the triangle: (0.75, 0.0)
Texture coordinates for the top vertex of the triangle: (0.75, 1.0)
~~

Texture mapped polygons

Select one:

a.
Texture coordinate for P1: (0, 0)
Texture coordinate for P2: (4, 0)
Texture coordinate for P3: (0, 1)
Texture coordinate for P4: (2, 1)
Texture coordinate for P5: (4, 1)
Texture coordinate for P6: (2, 3)
Texture coordinate for P7: (4, 3)
Texture coordinate for P8: (6, 3)
Texture coordinate for P9: (2, 4)
Texture coordinate for P10: (6, 4)

b.
Texture coordinate for P1: (0, 0)
Texture coordinate for P2: (2, 0)
Texture coordinate for P3: (0, 0.5)
Texture coordinate for P4: (1, 0.5)
Texture coordinate for P5: (2, 0.5)
Texture coordinate for P6: (1, 1.5)
Texture coordinate for P7: (2, 1.5)
Texture coordinate for P8: (3, 1.5)
Texture coordinate for P9: (1, 2)
Texture coordinate for P10: (3, 2)


c.
Texture coordinate for P1: (0, 0)
Texture coordinate for P2: (2, 0)
Texture coordinate for P3: (0, 1)
Texture coordinate for P4: (2, 1)
Texture coordinate for P5: (4, 1)
Texture coordinate for P6: (2, 2)
Texture coordinate for P7: (4, 2)
Texture coordinate for P8: (6, 2)
Texture coordinate for P9: (2, 3)
Texture coordinate for P10: (6, 3)


d.
Texture coordinate for P1: (0, 0)
Texture coordinate for P2: (4, 0)
Texture coordinate for P3: (0, 0.5)
Texture coordinate for P4: (2, 0.5)
Texture coordinate for P5: (4, 0.5)
Texture coordinate for P6: (2, 1.5)
Texture coordinate for P7: (4, 1.5)
Texture coordinate for P8: (6, 1.5)
Texture coordinate for P9: (2, 2)
Texture coordinate for P10: (6, 2)


e.
None of the others.
The correct answer is: Texture coordinate for P1: (0, 0)
Texture coordinate for P2: (2, 0)
Texture coordinate for P3: (0, 0.5)
Texture coordinate for P4: (1, 0.5)
Texture coordinate for P5: (2, 0.5)
Texture coordinate for P6: (1, 1.5)
Texture coordinate for P7: (2, 1.5)
Texture coordinate for P8: (3, 1.5)
Texture coordinate for P9: (1, 2)
Texture coordinate for P10: (3, 2)
~~
An object is defined with respect to the xyz (world) coordinate system. What OpenGL command can be used to to align that object with a new uvn-coordinate system sharing the same origin and with the unit vectors: 
u = \begin{pmatrix} -1 \\ 0 \\ 0  \end{pmatrix}, \mbox{    }  v = \begin{pmatrix} 0 \\ -1 \\ 0  \end{pmatrix}, \mbox{    } n = \begin{pmatrix} 0 \\ 0 \\ -1  \end{pmatrix} \mbox{  }?


a.
glRotatef(180, -1, -1, -1)

b.
glRotatef(180, 0, 0, 1)


c.
glScalef(-1, -1, -1)

d.
glTranslatef(-1, -1, -1)


e.
glRotatef(180, 1, 1, 1)
The correct answer is: glScalef(-1, -1, -1)
~~
Given is a quadratic spline with the power basis
T=\begin{pmatrix} t^2 & t & 1\end{pmatrix}
and the basis matrix:
\begin{pmatrix} 1 & -2 & 1 \\ -2 & 2 & 0 \\ 1 & 0 & 0 \end{pmatrix}


Which statement about the resulting basis functions B_1(t), B_2(t), and B_3(t) is true?
Select one:

a.
B_1(t)=-2*t^2+1

b.
The sum of the three basis functions is always 0.

c.
The basis functions are all cubic.

d.
The basis functions are the basis functions of a quadratic Bezier curve.

e.
B_3(1)=0
The correct answer is: The basis functions are the basis functions of a quadratic Bezier curve.
~~
Given is a profile curve c(t)=(x(t), 0, z(t)), 0 ≤ t ≤ 1, which lies in the xz-plane. The resulting surface-of-revolution is shown in the image below. What is the parametric equation of the profile curve indicated in blue in the image below?
Surface of revolution
Select one:

a.
c(t)=\begin{cases}
\begin{pmatrix} 6*t \\ 0 \\ 3-2*t \end{pmatrix} & \text{if } 0 \le t \le 0.5\\
\begin{pmatrix} 2*t+2 \\ 0 \\ 4*(1-t) \end{pmatrix} & \text{if } 0.5 \le t \le 1
\end{cases}

b.
c(t)=\begin{cases}
\begin{pmatrix} 3*t \\ 0 \\ 3-2*t \end{pmatrix} & \text{if } 0 \le t \le 0.5\\
\begin{pmatrix} t+3 \\ 0 \\ 4*(1-t) \end{pmatrix} & \text{if } 0.5 \le t \le 1
\end{cases}



c.
c(t)=\begin{cases}
\begin{pmatrix} 6*t \\ 0 \\ 3-t \end{pmatrix} & \text{if } 0 \le t \le 0.5\\
\begin{pmatrix} 2*t+2 \\ 0 \\ 2-t \end{pmatrix} & \text{if } 0.5 \le t \le 1
\end{cases}



d.
c(t)=\begin{cases}
\begin{pmatrix} 3*t \\ 0 \\ 3-t \end{pmatrix} & \text{if } 0 \le t \le 0.5\\
\begin{pmatrix} t+3 \\ 0 \\ 2-t \end{pmatrix} & \text{if } 0.5 \le t \le 1
\end{cases}



e.
c(t)=\begin{cases}
\begin{pmatrix} 3*t \\ 0 \\ 3-0.5*t \end{pmatrix} & \text{if } 0 \le t \le 0.5\\
\begin{pmatrix} 2*t+1 \\ 0 \\ 3-2*t \end{pmatrix} & \text{if } 0.5 \le t \le 1
\end{cases}

The correct answer is:
c(t)=\begin{cases}
\begin{pmatrix} 6*t \\ 0 \\ 3-2*t \end{pmatrix} & \text{if } 0 \le t \le 0.5\\
\begin{pmatrix} 2*t+2 \\ 0 \\ 4*(1-t) \end{pmatrix} & \text{if } 0.5 \le t \le 1
\end{cases}
~~
What is the parametric equation of the donut-shaped surface p(t)=(x(s,t), y(s,t), z(s,t)), 0 ≤ s,t ≤ 1 shown in the image below?

Hint 1: The surface is a surface-of-revolution as discussed in the lecture. The profile curve is an ellipsoid shown in the image below in blue.


Donut surface
Select one:

a.
p(t)=
\begin{pmatrix} (1.5*cos(2 \pi t) + 2.5) cos (2 \pi s) \\ (1.5*cos(2 \pi t) + 2.5) sin (2 \pi s) \\ sin (2 \pi t) \end{pmatrix}

b.
p(t)=
\begin{pmatrix} 1.5*cos(2 \pi t) cos (2 \pi s) +2.5  \\ 1.5*cos(2 \pi
 t) sin (2 \pi s)  \\ sin (2 \pi t) \end{pmatrix}



c.
p(t)=
\begin{pmatrix} 1.5*cos(2 \pi t) cos (2 \pi s) + 2.5  \\ 1.5*cos(2 \pi
 t) sin (2 \pi s) +2.5 \\ sin (2 \pi t) \end{pmatrix}



d.
p(t)=
\begin{pmatrix} 3*cos(2 \pi t) cos (2 \pi s) \\ cos(2 \pi
 t) sin (2 \pi s) \\ sin (2 \pi s) \end{pmatrix}



e.
p(t)=
\begin{pmatrix} 3*cos(2 \pi t) cos (2 \pi s) + 2.5 \\ cos(2 \pi
 t) sin (2 \pi s) \\ sin (2 \pi s) \end{pmatrix}

The correct answer is:
p(t)=
\begin{pmatrix} (1.5*cos(2 \pi t) + 2.5) cos (2 \pi s) \\ (1.5*cos(2 \pi t) + 2.5) sin (2 \pi s) \\ sin (2 \pi t) \end{pmatrix}
~~
Which of the matrices below is the correct MODEL_VIEW matrix after executing the following OpenGL commands:

glMatrixMode(GL_MODELVIEW );
glLoadIdentity();
glRotatef(-90, 0, 0, 1);
glTranslatef(2, 0, 1);
glScalef(1, 3, 2);
Question 18Answer

a.
\begin{pmatrix} 0 & 1 & 0 & 2 \\ 3 & 0 & 0 & 0
 \\ 0 & 0 & 2 & 1 \\ 0 & 0 & 0 & 1 
\end{pmatrix}



b.
\begin{pmatrix} 0 & -1 & 0 & 2 \\ 3 & 0 & 0 & 0
 \\ 0 & 0 & 2 & 1 \\ 0 & 0 & 0 & 1 
\end{pmatrix}



c.
\begin{pmatrix} 1 & 0 & 0 & 2 \\ 0 & 3 & 0 & 0 \\ 0 & 0 & 2 & 1 \\ 0 & 0 & 0 & 1 
\end{pmatrix}



d.
\begin{pmatrix} 0 & 1 & 0 & 2 \\ -3 & 0 & 0 & 0
 \\ 0 & 0 & 2 & 1 \\ 0 & 0 & 0 & 1 
\end{pmatrix}


e.
\begin{pmatrix} 0 & 3 & 0 & 0 \\ -1 & 0 & 0 & -2 \\ 0 & 0 & 2 & 1 \\ 0 & 0 & 0 & 1 \end{pmatrix}

The correct answer is:
\begin{pmatrix} 0 & 3 & 0 & 0 \\ -1 & 0 & 0 & -2 \\ 0 & 0 & 2 & 1 \\ 0 & 0 & 0 & 1 \end{pmatrix}

~~
Given is a uvn-coordinate system with the origin 
O_{uvn} = \begin{pmatrix} 2 \\ -1  \\ -2 \end{pmatrix}
and the coordinate axis 
{\bf u} = \begin{pmatrix} -1 \\ 0  \\ 0 \end{pmatrix}\text{ ,  } {\bf v} = \begin{pmatrix} 0 \\ 0  \\ 1 \end{pmatrix}\text{  and } {\bf n} = \begin{pmatrix} 0 \\ -1  \\ 0 \end{pmatrix}

Given is a point P with the uvn-coordinates 
{\bf p}_{uvn} = \begin{pmatrix} 2 \\ 1  \\ 3 \end{pmatrix}
.

What are the xyz-coordinates (world coordinates) of this point?
Select one:

a.
\begin{pmatrix} -3 \\ 1  \\ -3 \end{pmatrix}



b.
\begin{pmatrix} 0  \\ -4  \\ -1 \end{pmatrix}



c.
\begin{pmatrix} -1 \\ -3  \\ -2 \end{pmatrix}



d.
\begin{pmatrix} -1 \\ -2  \\ -1 \end{pmatrix}



e.
\begin{pmatrix} 1 \\ -3  \\ -5 \end{pmatrix}


The correct answer is:
\begin{pmatrix} 0  \\ -4  \\ -1 \end{pmatrix}

~~
A plane n.p=d defines a half-space, where the half space are all points where n.p<=d.
For example, for the plane x=0 the half space are all points with an x-coordinate <=0.

Using this definition we can now define a "cut-sphere" as the intersection of a sphere S and a half-space defined by the plane P. I.e., the "cut-sphere" contains all points which are inside the sphere and inside the half-space defined by P. The image below shows an example.
Cut-sphere

Which of the statements below about the ray intersection with a "cut-sphere" (defined by a sphere S and a plane P) is false?

NOTE: You can assume that the "cut-sphere" is in front of the eye point.
Select one:

a.
If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P and the sphere S AND the intersection parameter with the plane P is between the two intersection parameters with the sphere S, then the intersection point with the "cut-sphere" is equal to the first intersection point with the sphere S.


b.
If the dot product of the ray direction and the normal of P is positive AND the ray intersects the plane P before it intersects the sphere S, then the "cut-sphere" object does not exist (i.e., the intersection of the sphere and half-space is empty).


c.
If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P before it intersects the sphere S, then the "cut-sphere" object is equal to the sphere S (i.e., the intersection of the sphere and half-space is the sphere and nothing gets cut off.).

d.
The surface normal of a cut-sphere is either the normal of the sphere S or the normal of the plane P dependent on where the ray intersects the "cut-sphere" first.


e.
If the dot product of the ray direction and the normal of P is positive AND the ray intersects the plane P after it intersects the sphere S, then the intersection point with the "cut-sphere" is given by the intersection point with the sphere S.

The correct answer is: If the dot product of the ray direction and the normal of P is negative AND the ray intersects the plane P and the sphere S AND the intersection parameter with the plane P is between the two intersection parameters with the sphere S, then the intersection point with the "cut-sphere" is equal to the first intersection point with the sphere S.
~~
Consider the 5x5 grayscale image, J, defined by the grid lattice below. Given also, is the a 3x3 Gaussian Kernel, K.

What is the resulting value at pixel location (2,2) of the image obtained by applying Gaussian Kernel K, to image J?

4	8	8	8	8	8
3	16	16	16	16	16
2	48	48	48	48	48
1	32	32	32	32	32
0	8	8	8	8	8
0	1	2	3	4Image J	
2	1/16	1/8	1/16
1	1/8	1/4	1/8
0	1/16	1/8	1/16
0	1	2
Gaussian Kernel K

Note: Do not process all pixels that are within a 1 pixel border around the image.
Question 21Select one:

a.
None of the others


b.
40

c.
36


d.
32


e.
28

The correct answer is: 36
~~
Consider the 4x4 binary image, J, defined by the grid lattice below. Given also, is the square-like 3x3 structuring element,S, which contains all "1"-value pixels and has the origin at the center (1,1). The horizontal is x axis and the vertical is y axis. Each pixel location is denoted as (x,y) of position index.

Use "Padding 0" (Extending border values outside with zeros).

What is the resulting value at pixel location (3, 2) of the image obtained after performing a binary dilation of image J with structuring element S?

3	1	0	1	0
2	0	1	0	0
1	1	0	1	0
0	1	0	0	1
0	1	2	3
Image J	
2	1	1	1
1	1	1	1
0	1	1	1
0	1	2
Structuring Element S

Select one:

a.
1


b.
None of the others


c.
0


d.
2


e.
Undefined


The correct answer is: 1
~~
Consider the 4x4 table representing the greyscale (8-bit) image J below. What is the image value at the pixel location (x=0, y=2) after performing the histogram equalization? The image value has to be rounded to the nearest integer.

3	16	64	32	8
2	16	16	16	16
1	64	16	16	8
0	16	8	32	64
0	1	2	3
The bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.
Select one:

a.
None of the others


b.
157


c.
128


d.
16


e.
136

The correct answer is: 157
~~
Consider the 4x4 table representing the greyscale image J below. What is the pixel value for the cumulative histogram count of 11?

3	8	4	16	16
2	32	32	32	8
1	0	0	128	8
0	8	255	16	8
0	1	2	3
The bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.
Select one:

a.
0


b.
3


c.
4


d.
None of the others


e.
16

The correct answer is: 16
~~
Consider the 5x5 binary image, J, defined by the grid lattice below. Given also, is the cross-like 3x3 structuring element,S, which contains "1"-value pixels except at the corners and has the origin at the center (1,1).

What is the value at pixel location (2,2) of the morphological gradient of image J with structuring element S?

4	0	0	0	0	0
3	0	0	1	0	0
2	0	1	1	1	0
1	0	0	1	0	0
0	0	0	0	0	0
0	1	2	3	4Image J	
2	0	1	0
1	1	1	1
0	0	1	0
0	1	2
Structuring Element S

Note: Do not process all pixels that are within a 1 pixel border around the image.
Select one:

a.
0


b.
Undefined


c.
2


d.
1


e.
None of the others


The correct answer is: 0
~~
Consider the greyscale image J defined below What will be the threshold (rounded to the nearest integer) computed after running three iterations of the adaptive threshold technique as described in class?

3	128	16	64	16
2	128	32	32	16
1	128	128	8	128
0	8	8	16	64
0	1	2	3
The bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.
Select one:

a.
63


b.
73


c.
56


d.
58


e.
68

The correct answer is: 63
~~
Consider the 4x4 table representing the grayscale image J below. What is the result when a 3x3 median filter is applied? For boundary handling, use BoundaryPaddingZero.

3	0	8	16	64
2	8	16	32	64
1	16	32	64	128
0	64	64	128	128
0	1	2	3
The bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.

Value of median filtered image at x=0, y=3? Answer 1 Question 27
16

Value of median filtered image at x=2, y=1? Answer 2 Question 27
16


Value of median filtered image at x=3, y=1? Answer 3 Question 27
16

~~~
Which coefficients of the linear mapping operation, g(x,y)=af(x,y) + b, will map the pixel value f(x,y)=75 to g(x,y)=88 and pixel value f(x,y)=155 to g(x,y)=216?

Answer 1 Question 28
a is 0.6 and b is 32

Which effect does this linear mapping operation defined by a and b have, when applied to an image?

Answer 2 Question 28
contrast is increased and brightness is increased
~~~
Consider the 4x4 table representing the greyscale (8-bit) image J below. Compute the effect of a logarithmic contrast stretching on the image, which aims to increase the dynamic range of darker regions in the image.

The logarithmic contrast stretching operation transforms the input image J(x,y) pixelwise to an output image G(x,y) according to the equation:

G(x,y) = \frac{log(1+J(x,y))}{log(1 + Q)}

Here Q is the maximal greyvalue of the greyscale range of the input image.

The logarithmic function is applied to each input pixel of the 8 bit input range, and generates an output in the range between 0 and 1. You finally have to transform this output range to the same (8-bit) range that the input image has. Round to the nearest integer.

After computation of G, what is the pixel value of the final resulting image at the pixel location (x=1, y=0)?

3	8	8
8
8
2	16
4
4
16
1	32
128	255
32
0	16	64	64
16
0	1	2	3
The bottom left cell is defined as (0,0). The y-axis is vertical and increases up the image. The x-axis is horizontal and increases to the right.
Select one:

a.
101


b.
None of the others.


c.
161


d.
223


e.
255


f.
192


g.
130


h.
74

The correct answer is: 192
~~
Given is an RGB colour cube with side length 2 as illustrated in the image below"


RGB colour cube with side length 2

Please write OpenGL code to transform the cube as shown in the image below. The cube should be scaled by 2 in z-direction, the face with the black, green, blue and cyan vertex should form an angle of 70 degree with the yz-plane, and the edge from black to blue should be parallel to the z-axis with a distance of 2 and should lie on the yz-plane.

Transformed colour cube



IMPORTANT:

Please only use OpenGL transformations, e.g. glTranslatef, glRotatef

Please do NOT draw the cube itself - this is done automatically by the uploaded code
~~~
Given is a function drawTorus() which draws a torus with colored "blobs" centred at the origin and aligned with the z-axis as shown in the image below.


Torus centered at origin and aligned with z-axis

Please write OpenGL code to render the two tori displayed in the image below:

2 Tori

Note that the first torus lies on the xy-plane with centre (1, 1, 0), and the second  torus lies on the yz-plane with centre (0, 1, 1).



IMPORTANT:

Your code must draw the tori in the order described above. Your code should have the format:

<insert your transformations>
drawTorus();
<insert your transformations>
drawTorus();

Note: transformations refers to OpenGL transformations, e.g. glRotatef, glTranslatef, glScalef, glPushMatrix and glPopMatrix
~~~
Write a function animateBouncyBall(), which takes as parameters the position p of a ball and its velocity v and a plane in dot-normal form given by n (unit normal) and d. The function updates the ball's position and velocity for one animation step. Your function should have the following signature:

void animateBouncyBall(Vector3& p, Vector3& v, Vector3& n, double& d)

Note: The "&" symbol represents a reference variable, i.e., any change to this variable will be visible outside the function. You can use it like a normal variable of type Vector3.

You can assume that the ball's position p is initially on the outside of the plane (the side the normal points to). Your function should update p such that its new value is p+v and the velocity v stays unchanged. However, if the new point p+v is on the other side of the plane, then you must reflect the vector v on the plane and the new velocity is vreflected and the new point is p+vreflected.
Note: You can ignore that the point p is not exactly on the plane when reflected.

The image below illustrates how the position and velocity of the ball change if the function animateBouncyBall() is called multiple times.
Illustration trajectory bouncy ball
You can assume that Vector3 is a class that represents a 3D vector, and exposes fields named x, y, and z, and that the following functions are available to you:

double dot(Vector3 u, Vector3 v) //dot product

Vector3 cross(Vector3 u, Vector3 v) //cross product

You can assume that the Vector3 class has the following member functions available to you:

Vector3 Vector3.normalized() //returns a vector pointing in the same direction with length 1

double Vector3.magnitude() //returns the length of the vector

You can assume that the Vector3 class supports the following operators returning an object of type Vector3:

Vector3 + Vector3

Vector3 - Vector3

Vector3 * double // Note: the order is important, the scalar has to come after the vector when multiplying

For example:

Test	Result
Vector3 n=Vector3(1, 0, 0); // plane unit normal
double d=0;                 // plane distance from origin
Vector3 p = Vector3(0.5, 0.0, 0.0);
Vector3 v = Vector3(-0.2, 0.0, 0.0);
printf("position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\n", p.x, p.y, p.z, v.x, v.y, v.z);
animateBouncyBall(p, v, n, d);
printf("position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\n", p.x, p.y, p.z, v.x, v.y, v.z);
animateBouncyBall(p, v, n, d);
printf("position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\n", p.x, p.y, p.z, v.x, v.y, v.z);
animateBouncyBall(p, v, n, d);
printf("position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\n", p.x, p.y, p.z, v.x, v.y, v.z);
animateBouncyBall(p, v, n, d);
printf("position=(%.2lf,%.2lf,%.2lf) velocity=(%.2lf,%.2lf,%.2lf)\n", p.x, p.y, p.z, v.x, v.y, v.z);
position=(0.50,0.00,0.00) velocity=(-0.20,0.00,0.00)
position=(0.30,0.00,0.00) velocity=(-0.20,0.00,0.00)
position=(0.10,0.00,0.00) velocity=(-0.20,0.00,0.00)
position=(0.30,0.00,0.00) velocity=(0.20,0.00,0.00)
position=(0.50,0.00,0.00) velocity=(0.20,0.00,0.00)
~~~
In this question we want to create the front and right side of the texture mapped muesli box shown in the image below:

Muesli box model


The 3D model uses a quadstrip for the front and right side and a quadrilateral for the top side, which are textured using the texture image below. Note that the sections of the texture image used for the front and right side of the box are rectangular (illustrated in green in the image below) and the section of the texture image used for the top side of the box is a trapezoid (illustrated in blue in the image below).

Texture image

Please only use the texture coordinates indicated in the image above in order to define the missing values for s1, s2, s3, s4, s5 and t1, t2, t3 in the code shown in the answer box. Please do not change anything else.
~~~
Given is a cubic spline curve c(t)=T M G with the geometric constraint vector
G=(p0, p1, p2, p3)^T
The basis matrix of the spline curve is

\bf{M}=\begin{pmatrix} -4.5 & 13.5 & -13.5 & 4.5 \\ 9 & -22.5 & 18 & -4.5
    \\ -5.5 & 9 & -4.5 & 1 \\ 1 & 0 & 0 & 0 \end{pmatrix}



The spline curve is used as profile curve for a surface-of-revolution.

Implement this curve by defining its basis functions and completing the code fragment below.
Please write your answer into the answer space using the following format:


double Basis1(double t){ return <Insert code>;} 
double Basis2(double t){ return <Insert code>;}
double Basis3(double t){ return <Insert code>;} 
double Basis4(double t){ return <Insert code>;} 

CVec3df curve(float t)
{
  // return the curve point c(t) of type CVec3df   
}


The first test case uses the geometric constraints:
const CVec3df p0(1, 0, 0);
const CVec3df p1(1.6666, 0, 0.2);
const CVec3df p2(2.3333, 0, 1.5);
const CVec3df p3(3, 0, 1);

and should result into the image below:

Surface-of-revolution

You can assume that the CVec3df class supports the following operators returning an object of type CVec3df:

CVec3df + CVec3df

CVec3df * double // Note: the order is important, the scalar has to come after the vector when multiplying


~~~
Given is a function drawCube() which draws a unit cube centered at the origin with coloured dots on its top (see image below). The top front corner has a yellow dot, the top-back corner has a cyan dot and the top-left and top-right corners have grey and magenta dots, respectively.


Unit Cube centered at origin with dots

Please write OpenGL code to render a double barrel ball gun as illustrated in the image below. The ball gun consists of a stand (bottom part), a horizontal bar on top of it, and two barrels on the left and right of the horizontal bar. All objects have a square cross section with a width of width. The stand and the barrels have a length of length. The horizontal bar as a length of distance. The barrels form an angle of θ (theta) with the xz-plane. The rotation axis is the centre line of the horizontal bar. The stand is centred on the y-axis. The whole ball gun is rotated by an angle φ (phi) around its centre axis.

The values for width, length, distance, φ (phi) and θ (theta) are specified in the test cases.

Double barrel ball gun

The picture below shows an enlargement of the image on the right in order to better show the colours of the corners of the transformed cubes:
Enlarged image

IMPORTANT:

In order for the automarker to work correctly you:

(1) must use the function drawCube() to draw each robot arm

(2) must draw the components in the order explained in the image above on the right: first the stand, then the horizontal bar, then the barrel on the positive z-axis and then the barrel on the negative x-axis.

(3) must use the variables width, length, distance, phi, and theta, which have different values in the test cases.

(4) must make sure that the dots at the top of each cube are in the correct positions. If you rotate the cuboids around their axes the object looks the same, but the transformation matrices are different and the automarker will mark it as wrong.



Tip: Start by drawing the stand and the horizontal bar. Rotating the stand will rotate the whole ball gun. In addition to glRotatef, glTranslatef, and glScalef, you might also want to use glPushMatrix() and glPopMatrix().


~~~
In this exercise you need to complete the function below defining a Ray-CutSphere Intersection:
double CutSphere::Intersect(Vector source, Vector d)
NOTE: The pre-loaded answer box contains already code for the ray sphere intersection and sorts the intersection points such that t1 is the first intersection point with the original sphere.
Add additional code such that the function returns instead the intersection points with the "cut-sphere".
The cutting plane n.p=a is defined by the variables n (type Vector) and a (type double).

HINT: Compute the ray-plane intersection and develop an algorithm to decide whether the ray intersects the round (un-cut part) of the sphere, the cutting plane, or doesn't intersect the cut sphere at all (e.g. the ray might pass through the cut-off part of the sphere)

IMPORTANT: If the ray first intersects the cutting plane of the cut sphere (the flat part of it) then you need to set cuttingPlaneIntersected = true; . This is used in the normal calculation and without the automarker will mark your solution as false.

Note: The following variables and functions are already defined for you to use:

The plane n.p=a is defined by the variables n (type Vector) and a (type double).

Vector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector

Vector: v1-v2 - subtracts v2 from v1 and returns resulting vector

Vector: v1 * t - scales the vector v1 by t and returns resulting vector

Vector v.Scale(float a, float b, float c) - scales each component of the vector v

float v1.Dot(Vector v2) - returns the dot product of vector v1 and v2

Vector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2

After completing the code in the pre-loaded answer box you should get the images below:

Cut sphere

cut sphere 2

  
Feedback
Test case 1
Output image:

Embedded Image
Test case 2
Output image:

Embedded Image
Test	Input	Expected	Got	Mark	
1
// small part on top of sphere cut off
s->n = Vector(0.57735026919, 0.57735026919, 0.57735026919);
s->a = 0.8;
color=(0.13, 0.29, 0.14)
color=(0.13, 0.29, 0.14)
color=(0.13, 0.29, 0.14)
color=(0.13, 0.29, 0.14)
color=(0.13, 0.29, 0.14)
color=(0.13, 0.28, 0.14)
color=(0.12, 0.28, 0.14)
color=(0.12, 0.28, 0.14)
color=(0.12, 0.27, 0.13)
color=(0.12, 0.27, 0.13)
color=(0.12, 0.26, 0.13)
color=(0.11, 0.26, 0.13)
color=(0.09, 0.19, 0.09)
color=(0.08, 0.18, 0.08)
color=(0.08, 0.17, 0.08)
color=(0.07, 0.15, 0.07)
color=(0.06, 0.13, 0.06)
color=(0.07, 0.13, 0.07)
color=(0.05, 0.10, 0.05)
color=(0.03, 0.06, 0.04)
color=(0.37, 0.09, 0.09)
color=(0.50, 0.12, 0.15)
color=(0.49, 0.11, 0.11)
color=(0.50, 0.12, 0.15)
color=(0.55, 0.13, 0.14)
color=(0.13, 0.29, 0.14)
color=(0.13, 0.29, 0.14)
color=(0.13, 0.29, 0.14)
color=(0.13, 0.29, 0.14)
color=(0.13, 0.29, 0.14)
color=(0.13, 0.28, 0.14)
color=(0.12, 0.28, 0.14)
color=(0.12, 0.28, 0.14)
color=(0.12, 0.27, 0.13)
color=(0.12, 0.27, 0.13)
color=(0.12, 0.26, 0.13)
color=(0.11, 0.26, 0.13)
color=(0.09, 0.19, 0.09)
color=(0.08, 0.18, 0.08)
color=(0.08, 0.17, 0.08)
color=(0.07, 0.15, 0.07)
color=(0.06, 0.13, 0.06)
color=(0.07, 0.13, 0.07)
color=(0.05, 0.10, 0.05)
color=(0.03, 0.06, 0.04)
color=(0.37, 0.09, 0.09)
color=(0.53, 0.17, 0.24)
color=(0.47, 0.11, 0.11)
color=(0.68, 0.20, 0.21)
color=(0.60, 0.14, 0.16)
0
2
// most of the sphere cut off - only small part at bottom visible
s->n = Vector(0, 0.979795897, 0.2);
s->a = -0.5;
color=(0.13, 0.29, 0.14)
color=(0.13, 0.29, 0.14)
color=(0.13, 0.29, 0.14)
color=(0.13, 0.29, 0.14)
color=(0.13, 0.29, 0.14)
color=(0.13, 0.28, 0.14)
color=(0.12, 0.28, 0.14)
color=(0.12, 0.28, 0.14)
color=(0.12, 0.27, 0.13)
color=(0.12, 0.27, 0.13)
color=(0.12, 0.26, 0.13)
color=(0.11, 0.26, 0.13)
color=(0.11, 0.24, 0.12)
color=(0.10, 0.23, 0.11)
color=(0.10, 0.21, 0.11)
color=(0.09, 0.19, 0.10)
color=(0.08, 0.17, 0.09)
color=(0.07, 0.13, 0.07)
color=(0.05, 0.10, 0.05)
color=(0.03, 0.06, 0.04)
color=(0.13, 0.29, 0.14)
color=(0.13, 0.29, 0.14)
color=(0.13, 0.29, 0.14)
color=(0.13, 0.29, 0.14)
color=(0.13, 0.29, 0.14)
color=(0.13, 0.28, 0.14)
color=(0.12, 0.28, 0.14)
color=(0.12, 0.28, 0.14)
color=(0.12, 0.27, 0.13)
color=(0.12, 0.27, 0.13)
color=(0.12, 0.26, 0.13)
color=(0.11, 0.26, 0.13)
color=(0.09, 0.19, 0.09)
color=(0.08, 0.18, 0.08)
color=(0.08, 0.17, 0.08)
color=(0.07, 0.15, 0.07)
color=(0.06, 0.13, 0.06)
color=(0.07, 0.13, 0.07)
color=(0.05, 0.10, 0.05)
color=(0.03, 0.06, 0.04)
color=(0.37, 0.09, 0.09)
color=(0.53, 0.17, 0.24)
color=(0.47, 0.11, 0.11)
color=(0.68, 0.20, 0.21)
color=(0.60, 0.14, 0.16)
0
~~~
In this exercise you need to complete the normal calculation for the Ray-CutSphere Intersection from the previous question. Note that you can complete this question even if you were unable to implement the intersection function correctly.

Please implement the function
Vector CutSphere::Normal(Vector p)
NOTE: The function should return the correct normal of the "cut: unit sphere at the ray intersection point p. Note that the cut-sphere is a unit sphere with centre at the origin. The normal of the cutting plane is n (type Vector).

NOTE 2: You can assume that the boolean variable cuttingPlaneIntersected is defined and that it is true if p lies on the flat part of the "cut" unit sphere and false otherwise.



Note: The following variables and functions are already defined for you to use:

The plane n.p=a is defined by the variables n (type Vector) and a (type double).

Vector: v1+v2 - adds the vectors v1 and v2 and returns resulting vector

Vector: v1-v2 - subtracts v2 from v1 and returns resulting vector

Vector: v1 * t - scales the vector v1 by t and returns resulting vector

Vector v.Scale(float a, float b, float c) - scales each component of the vector v

float v1.Dot(Vector v2) - returns the dot product of vector v1 and v2

Vector v1.Cross(Vector v2) - returns the cross product of vector v1 and v2

Vector v.Normalize() - returns the normalised version of the vector v

After completing the code in the pre-loaded answer box you should get the image below:

Cut sphere
~~~
Given is a binary 8 bit input image in the form of a pixel array (a list of pixel rows, with each row represented again as a list). Every pixel contains an integer value which is either 0 or a single other non-zero value (e.g. 1 or 255), thus representing a binary image.

Write a Python3 function ‘morphologicalGradient(pixel_array, image_width, image_height)’ which computes and returns the morphological gradient image. We define the input pixel value larger than 0 as the value of the foreground structure.

We assume a cross shaped morphological structuring element of size 3x3, where all kernel elements adjacent to the centre, or the centre are set to 1 (flat, 4-neighourhood structuring element). The resulting image has to contain 1 for the pixels that are part of the morphological gradient structure, regardless of the value of the foreground structure in the input binary image.

Border handling: Note that when applying the 3x3 dilation, the filtering procedure has to access pixels that are outside the input image. For this function we assume that pixels outside the image border are background pixels (i.e. equal to 0, BoundaryZeroPadding).

You may assume that the Python3 function 'createInitializedGreyscalePixelArray(image_width, image_height)' is available, which creates an empty greyscale array (values 0) as a list of lists of integers.

The test case code will run a function to output the returned image array visually.


For example:

Test	Input	Result
image_width = 16
image_height = 16
pixel_array = [ 
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] ]
gradient_img = morphologicalGradient(pixel_array, image_width, image_height)
printPixelArray(gradient_img)
image_width = 16
image_height = 16
pixel_array = [ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0],
                [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0],
                [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0],
                [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0],
                [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
                [0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
                [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
                [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
gradient_img = morphologicalGradient(pixel_array, image_width, image_height)
printPixelArray(gradient_img)
Test	Input	Expected	Got	
image_width = 16
image_height = 16
pixel_array = [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] ]
gradient_img = morphologicalGradient(pixel_array, image_width, image_height)
printPixelArray(gradient_img)
~~~
Given is a greyscale 3 bit input image in the form of a pixel array (a list of pixel rows, with each row represented again as a list). Every pixel contains an integer value between 0 and 7 (inclusive).

Building on your knowledge of histograms, write a Python3 function ‘histogramPairs(pixel_array, image_width, image_height)’ which computes a two-dimensional histogram that counts (as an integer) how many times each pixel value (i) is present to the right of another pixel value (j). This will require you to create a 2D array with a height and width equal to the number of possible pixel intensities. The pixel value i corresponds to the row, and j corresponds to the column in the 2D array.

Return the histogram as a list of lists (2D greyscale pixel array).

You may assume that the Python3 function 'createInitializedGreyscalePixelArray(image_width, image_height)' is available, which creates an empty greyscale/2D array (values 0) as a list of lists of integers.

The test case code will run a function to output the returned list of lists as a table.


For example:

Test	Input	Result
image_width = 8
image_height = 8
image_arr = [[0, 0, 0, 0, 0, 0, 0, 0], 
            [1, 1, 1, 1, 1, 1, 1, 1], 
            [2, 2, 2, 2, 2, 2, 2, 2], 
            [3, 3, 3, 3, 3, 3, 3, 3],
            [4, 4, 4, 4, 4, 4, 4, 4], 
            [5, 5, 5, 5, 5, 5, 5, 5], 
            [6, 6, 6, 6, 6, 6, 6, 6], 
            [7, 7, 7, 7, 7, 7, 7, 7]]
histogram = histogramPairs(image_arr, image_width, image_height)
#Format output as a table
output_table(histogram)
0	0	0	0	0	0	0	0
1	1	1	1	1	1	1	1
2	2	2	2	2	2	2	2
3	3	3	3	3	3	3	3
4	4	4	4	4	4	4	4
5	5	5	5	5	5	5	5
6	6	6	6	6	6	6	6
7	7	7	7	7	7	7	7
0	1	2	3	4	5	6	7
0	7	0	0	0	0	0	0	0
1	0	7	0	0	0	0	0	0
2	0	0	7	0	0	0	0	0
3	0	0	0	7	0	0	0	0
4	0	0	0	0	7	0	0	0
5	0	0	0	0	0	7	0	0
6	0	0	0	0	0	0	7	0
7	0	0	0	0	0	0	0	7
image_width = 4
image_height = 4
image_arr = [[5, 1, 7, 5], 
             [3, 2, 4, 4], 
             [3, 5, 5, 4], 
             [3, 0, 5, 6]]
histogram = histogramPairs(image_arr, image_width, image_height)
#Format output as a table
output_table(histogram)
5	1	7	5
3	2	4	4
3	5	5	4
3	0	5	6
0	1	2	3	4	5	6	7
0	0	0	0	1	0	0	0	0
1	0	0	0	0	0	1	0	0
2	0	0	0	1	0	0	0	0
3	0	0	0	0	0	0	0	0
4	0	0	1	0	1	1	0	0
5	1	0	0	1	0	1	0	1
6	0	0	0	0	0	1	0	0
7	0	1	0	0	0	0	0	0
~~~
Given is a grayscale 8 bit input image in the form of a pixel array (a list of pixel rows, with each row represented again as a list). Every pixel contains an integer value between 0 and 255. Write a Python3 function ‘angleOfGradients(pixel_array, image_width, image_height)’ that calculates and returns the average angle of the gradients across the image, and the angle at each pixel in the image.

To do this, you will need to compute the Sobel gradient images in the x and y direction using the filters given below, calculate the angle (\theta) at each pixel using the equation θ = atan2(gy, gx), and then average the angles.

To compute the average angle, you should sum the result of the sine of the angles (sa), the sum of the cosine of the angles (ca), and calculate the mean angle as atan2(sa, ca). Then convert this angle to degrees by multiplying by 180/math.pi.

Horizontal = \begin{bmatrix}1 & 0 & -1\\2 & 0 & -2\\1 & 0 & -1\end{bmatrix}

Vertical= \begin{bmatrix}1 & 2 & 1\\0 & 0 & 0\\-1 & -2 & -1\end{bmatrix}

Return your result using the dictionary structure provided: with the array of angles across the image (in radians) and the average angle (in degrees). You will receive partial marks for returning the correct angles at each image position, and full marks for returning both.

You can use the built-in functions math.sin(), math.cos(), and math.atan2().

You may assume that the Python3 function 'createInitializedGreyscalePixelArray(image_width, image_height)' is available, which creates an empty greyscale array (values 0) as a list of lists of integers.

Border handling: Note that when applying the Sobel filters, the filtering procedure has to access pixels that are outside the input image. For this function, we will ignore the pixels near the boundary (i.e. BoundaryIgnore).


For example:

Test	Input	Result
image_width = 8
image_height = 8

image_arr = [[224, 208, 192, 176, 160, 144, 128, 112], 
             [208, 192, 176, 160, 144, 128, 112, 96], 
             [192, 176, 160, 144, 128, 112, 96, 80], 
             [176, 160, 144, 128, 112, 96, 80, 64], 
             [160, 144, 128, 112, 96, 80, 64, 48], 
             [144, 128, 112, 96, 80, 64, 48, 32], 
             [128, 112, 96, 80, 64, 48, 32, 16], 
             [112, 96, 80, 64, 48, 32, 16, 0]]

result = angleOfGradients(image_arr, image_width, image_height)
printPixelArray(result["angle image"])
print("Average angle:", round(result["average angle"],2), "degrees")
224	208	192	176	160	144	128	112
208	192	176	160	144	128	112	96
192	176	160	144	128	112	96	80
176	160	144	128	112	96	80	64
160	144	128	112	96	80	64	48
144	128	112	96	80	64	48	32
128	112	96	80	64	48	32	16
112	96	80	64	48	32	16	0
0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00
0.00	0.79	0.79	0.79	0.79	0.79	0.79	0.00
0.00	0.79	0.79	0.79	0.79	0.79	0.79	0.00
0.00	0.79	0.79	0.79	0.79	0.79	0.79	0.00
0.00	0.79	0.79	0.79	0.79	0.79	0.79	0.00
0.00	0.79	0.79	0.79	0.79	0.79	0.79	0.00
0.00	0.79	0.79	0.79	0.79	0.79	0.79	0.00
0.00	0.00	0.00	0.00	0.00	0.00	0.00	0.00
Average angle: 45.0 degrees
~~~